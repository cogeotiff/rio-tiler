{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rio-tiler","text":"<p> User friendly Rasterio plugin to read raster datasets. </p> <p> </p> <p>Documentation: cogeotiff.github.io/rio-tiler/</p> <p>Source Code: cogeotiff/rio-tiler</p>"},{"location":"#description","title":"Description","text":"<p><code>rio-tiler</code> was initially designed to create slippy map tiles from large raster data sources and render these tiles dynamically on a web map. Since <code>rio-tiler</code> v2.0, we added many more helper methods to read data and metadata from any raster source supported by Rasterio/GDAL. This includes local and remote files via HTTP, AWS S3, Google Cloud Storage, etc.</p> <p>At the low level, <code>rio-tiler</code> is just a wrapper around the rasterio and GDAL libraries.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Read any dataset supported by GDAL/Rasterio</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    print(image.dataset)  # rasterio opened dataset\n    img = image.read()    # similar to rasterio.open(\"my.tif\").read() but returns a rio_tiler.models.ImageData object\n</code></pre> </li> <li> <p>User friendly <code>tile</code>, <code>part</code>, <code>feature</code>, <code>point</code> reading methods</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    img = image.tile(x, y, z)            # read mercator tile z-x-y\n    img = image.part(bbox)               # read the data intersecting a bounding box\n    img = image.feature(geojson_feature) # read the data intersecting a geojson feature\n    img = image.point(lon,lat)           # get pixel values for a lon/lat coordinates\n</code></pre> </li> <li> <p>Enable property assignment (e.g nodata) on data reading</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    img = image.tile(x, y, z, nodata=-9999) # read mercator tile z-x-y\n</code></pre> </li> <li> <p>STAC support</p> <pre><code>from rio_tiler.io import STACReader\n\nwith STACReader(\"item.json\") as stac:\n    print(stac.assets)  # available asset\n    img = stac.tile(  # read tile for asset1 and indexes 1,2,3\n        x,\n        y,\n        z,\n        assets=\"asset1\",\n        indexes=(1, 2, 3),  # same as asset_indexes={\"asset1\": (1, 2, 3)},\n    )\n\n    # Merging data from different assets\n    img = stac.tile(  # create an image from assets 1,2,3 using their first band\n        x,\n        y,\n        z,\n        assets=(\"asset1\", \"asset2\", \"asset3\",),\n        asset_indexes={\"asset1\": 1, \"asset2\": 1, \"asset3\": 1},\n    )\n</code></pre> </li> <li> <p>Xarray support (&gt;=4.0)</p> <p><pre><code>import xarray\nfrom rio_tiler.io import XarrayReader\n\nds = xarray.open_dataset(\n    \"https://pangeo.blob.core.windows.net/pangeo-public/daymet-rio-tiler/na-wgs84.zarr/\",\n    engine=\"zarr\",\n    decode_coords=\"all\",\n    consolidated=True,\n)\nda = ds[\"tmax\"]\nwith XarrayReader(da) as dst:\n    print(dst.info())\n    img = dst.tile(1, 1, 2)\n</code></pre> Note: The XarrayReader needs optional dependencies to be installed <code>pip install rio-tiler[\"xarray\"]</code>.</p> </li> <li> <p>Non-Geo Image support (&gt;=4.0)</p> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpeg\") as src:\n    im = src.tile(0, 0, src.maxzoom)  # read top-left `tile`\n    im = src.part((0, 100, 100, 0))  # read top-left 100x100 pixels\n    pt = src.point(0, 0)  # read pixel value\n</code></pre> <p>Note: <code>ImageReader</code> is also compatible with proper geo-referenced raster datasets.</p> </li> <li> <p>Mosaic (merging or stacking)</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\n\ndef reader(file, x, y, z, **kwargs):\n    with Reader(file) as image:\n        return image.tile(x, y, z, **kwargs)\n\nimg, assets = mosaic_reader([\"image1.tif\", \"image2.tif\"], reader, x, y, z)\n</code></pre> </li> <li> <p>Native support for multiple TileMatrixSet via morecantile</p> <pre><code>import morecantile\nfrom rio_tiler.io import Reader\n\n# Use EPSG:4326 (WGS84) grid\nwgs84_grid = morecantile.tms.get(\"WorldCRS84Quad\")\nwith Reader(\"my.tif\", tms=wgs84_grid) as src:\n    img = src.tile(1, 1, 1)\n</code></pre> </li> </ul>"},{"location":"#install","title":"Install","text":"<p>You can install <code>rio-tiler</code> using pip</p> <pre><code>$ python -m pip install -U pip\n$ python -m pip install -U rio-tiler\n</code></pre> <p>or install from source:</p> <pre><code>$ git clone https://github.com/cogeotiff/rio-tiler.git\n$ cd rio-tiler\n$ python -m pip install -U pip\n$ python -m pip install -e .\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":""},{"location":"#rio-tiler-pds","title":"rio-tiler-pds","text":"<p><code>rio-tiler</code> v1 included several helpers for reading popular public datasets (e.g. Sentinel 2, Sentinel 1, Landsat 8, CBERS) from cloud providers. This functionality is now in a separate plugin, enabling easier access to more public datasets.</p>"},{"location":"#rio-tiler-mvt","title":"rio-tiler-mvt","text":"<p>Create Mapbox Vector Tiles from raster sources</p>"},{"location":"#implementations","title":"Implementations","text":"<p>titiler: A lightweight Cloud Optimized GeoTIFF dynamic tile server.</p> <p>cogeo-mosaic: Create mosaics of Cloud Optimized GeoTIFF based on the mosaicJSON specification.</p>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#authors","title":"Authors","text":"<p>The <code>rio-tiler</code> project was begun at Mapbox and was transferred to the <code>cogeotiff</code> Github organization in January 2019.</p> <p>See AUTHORS.txt for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"colormap/","title":"Colormaps","text":"<p>Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data.</p> <p>You can load one of <code>rio-tiler</code>'s default colormaps from the <code>rio_tiler.colormap.cmap</code> object, and then pass it to <code>rio_tiler.utils.render</code>:</p> <pre><code>from rio_tiler.colormap import cmap\nfrom rio_tiler.io import Reader\n\n# Get Colormap\n# You can list available colormap names with `cmap.list()`\ncm = cmap.get(\"cfastie\")\n\nwith Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as src:\n    img = src.tile(239, 220, 9)\n\n    # Rescale the data linearly from 0-10000 to 0-255\n    img.rescale(\n        in_range=((0, 10000),),\n        out_range=((0, 255),)\n    )\n\n    # Apply colormap and create a PNG buffer\n    buff = img.render(colormap=cm) # this returns a buffer (PNG by default)\n</code></pre> <p>The <code>render</code> method accept colormap in form of: <pre><code>{\n  value1: (R, G, B, Alpha),\n  value2: (R, G, B, Alpha),\n  ...\n}\n</code></pre></p> <p>Colormaps can be <code>discrete</code> (having sparse value) or <code>linear</code> (with values strictly from 0 to 255).</p>"},{"location":"colormap/#custom-colormaps","title":"Custom colormaps","text":"<p>The <code>rio_tiler.colormap.cmap</code> object holds the list of default colormaps and also allow users to registered new ones.</p> <p>discrete (with custom entries, not limited to uint8 type)</p> <pre><code>from rio_tiler.colormap import cmap\n\ncmap = cmap.register(\n    {\n        \"custom_classes\": {\n          0: (0, 0, 0, 0),\n          100: (255, 0, 0, 255),\n          200: (0, 255, 0, 255),\n          300: (0, 0, 255, 255),\n        }\n    }\n)\n</code></pre> <p>linear (with 256 values from 0 to 255)</p> <pre><code># ref: https://github.com/cogeotiff/rio-tiler/issues/382\nimport matplotlib\nimport numpy\n\nndvi = matplotlib.colors.LinearSegmentedColormap.from_list(\n    'ndvi', [\n        '#422112',\n        '#724C01',\n        '#CEA712',\n        '#FFA904',\n        '#FDFE00',\n        '#E6EC06',\n        '#BACF00',\n        '#8BB001',\n        '#72A002',\n        '#5B8D03',\n        '#448102',\n        '#2C7001',\n        '#176100',\n    ],\n    256,\n)\n\nx = numpy.linspace(0, 1, 256)\ncmap_vals = ndvi(x)[:, :]\ncmap_uint8 = (cmap_vals * 255).astype('uint8')\nndvi_dict = {idx: tuple(value) for idx, value in enumerate(cmap_uint8)}\n\ncmap = cmap.register({\"ndvi\": ndvi_dict})\n</code></pre>"},{"location":"colormap/#intervals-colormaps","title":"Intervals colormaps","text":"<p>Starting with <code>rio-tiler</code> 3.0, intervals colormap support has been added. This is useful when you want to define color breaks for a given data.</p> <p>Warnings</p> <p>For <code>intervals</code>, colormap has to be in form of <code>Sequence[Tuple[Sequence, Sequence]]</code>: <pre><code>[\n  ((min, max), (r, g, b, a)),\n  ((min, max), (r, g, b, a)),\n  ...\n]\n</code></pre></p> <pre><code>from rio_tiler.colormap import apply_cmap\n\ndata = numpy.random.randint(0, 255, size=(1, 256, 256))\ncmap = [\n    ((0, 1), (0, 0, 0, 0)),\n    ((1, 10), (255, 255, 255, 255)),\n    ((10, 100), (255, 0, 0, 255)),\n    ((100, 256), (255, 255, 0, 255)),\n]\n\ndata, mask = apply_cmap(data, cmap)\n</code></pre>"},{"location":"colormap/#default-rio-tilers-colormaps","title":"Default rio-tiler's colormaps","text":""},{"location":"colormap/#automatically-load-custom-colormap","title":"Automatically load custom colormap","text":"<p>User can set <code>COLORMAP_DIRECTORY</code> env variable to tell rio-tiler to search for <code>.npy</code> or <code>.json</code> files holding custom colormaps.</p>"},{"location":"colormap/#references","title":"References","text":"<ul> <li>Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html</li> <li><code>cfastie</code>: publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap</li> <li><code>rplumbo</code>: cogeotiff/rio-tiler!90</li> <li><code>schwarzwald</code>: soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html</li> </ul>"},{"location":"colormap/#update-images-for-new-colormaps","title":"Update images for new colormaps","text":"<p>To regenerate these images for new colormaps, update the list of colormaps at the top of <code>docs/scripts/colormap_thumb.py</code> and then run</p> <pre><code>python docs/scripts/colormap_thumb.py\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Issues and pull requests are more than welcome.</p>"},{"location":"contributing/#dev-install","title":"dev install","text":"<pre><code>git clone https://github.com/cogeotiff/rio-tiler.git\ncd rio-tiler\npython -m pip install -e \".[test,dev]\"\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov rio_tiler --cov-report term-missing\n</code></pre>"},{"location":"contributing/#performance-tests","title":"Performance tests","text":"<pre><code>python -m pip install -e \".[benchmark]\"\npython -m pytest tests/benchmarks/benchmarks.py --benchmark-only --benchmark-columns 'min, max, mean, median' --benchmark-sort 'min'\n</code></pre>"},{"location":"contributing/#pre-commit","title":"pre-commit","text":"<p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/cogeotiff/rio-tiler.git\ncd rio-tiler\npython -m pip install -e .[\"docs\"]\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>$ mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.):</p> <pre><code>$ mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre> <pre><code>pdocs as_markdown \\\n   --output_dir docs/src/api/ \\\n   --exclude_source \\\n   --overwrite \\\n   rio_tiler.colormap \\\n   rio_tiler.constants \\\n   rio_tiler.errors \\\n   rio_tiler.expression \\\n   rio_tiler.models \\\n   rio_tiler.io.base \\\n   rio_tiler.io.rasterio \\\n   rio_tiler.io.stac \\\n   rio_tiler.io.xarray \\\n   rio_tiler.mosaic.methods.base \\\n   rio_tiler.mosaic.methods.defaults \\\n   rio_tiler.mosaic.reader \\\n   rio_tiler.profiles \\\n   rio_tiler.reader \\\n   rio_tiler.tasks \\\n   rio_tiler.utils\n</code></pre>"},{"location":"experimental/","title":"Experimental Features","text":"<p>In this section you will find documentation for new, experimental features in rio-tiler. These features are subject to change or removal, and we are looking for feedback and suggestions before making them a permanent part of Pydantic.</p>"},{"location":"experimental/#feedback","title":"Feedback","text":"<p>We welcome feedback on experimental features! Please open an issue on the rio-tiler GitHub repository to share your thoughts, requests, or suggestions.</p> <p>We also encourage you to read through existing feedback and add your thoughts to existing issues.</p>"},{"location":"experimental/#warnings-on-import","title":"Warnings on Import","text":"<p>When you import an experimental feature from the <code>experimental</code> module, you'll see a warning message that the feature is experimental. You can disable this warning with the following:</p> <pre><code>import warnings\nfrom rio_tiler.errors import RioTilerExperimentalWarning\n\nwarnings.filterwarnings('ignore', category=RioTilerExperimentalWarning)\n</code></pre>"},{"location":"experimental/#vsifile-reader","title":"VSIFile Reader","text":"<p>Required dependencies: - <code>vsifile&gt;=0.2</code></p> <p>A rio-tiler Reader using VSIFile/Obstore as file system handler. Starting with GDAL&gt;=3.0, VSI plugin was added in order to enable users to provide their own file system handler (class handling the file requests).</p> <p>The reader is considered experimental because <code>VSIFile</code> is still under development. Users should also note that changes available in GDAL&gt;=3.10 will drastically improve the performance of this reader (github.com/vincentsarago/vsifile/issues/13#issuecomment-2683310594)</p> <pre><code>from rio_tiler.experimental.vsifile import VSIReader\n\nwith VSIReader(\"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/15/T/VK/2023/10/S2B_15TVK_20231008_0_L2A/TCI.tif\") as src:\n    print(src.info())\n\n&gt;&gt;&gt; bounds=(399960.0, 4890240.0, 509760.0, 5000040.0) crs='http://www.opengis.net/def/crs/EPSG/0/32615' band_metadata=[('b1', {}), ('b2', {}), ('b3', {})] band_descriptions=[('b1', ''), ('b2', ''), ('b3', '')] dtype='uint8' nodata_type='Nodata' colorinterp=['red', 'green', 'blue'] scales=[1.0, 1.0, 1.0] offsets=[0.0, 0.0, 0.0] colormap=None driver='GTiff' count=3 width=10980 height=10980 overviews=[2, 4, 8, 16] nodata_value=0.0\n</code></pre>"},{"location":"experimental/#links","title":"Links","text":"<ul> <li>OSGeo/gdal!1289</li> <li>rasterio/rasterio!2141</li> </ul>"},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#read-data","title":"Read data","text":"<p><code>rio-tiler</code> has Readers classes which have methods to access data in <code>Tile</code>, <code>Part</code> (bbox), <code>Feature</code> (GeoJSON), <code>Point</code> (lon, lat) or as a whole.</p> <p>Here is a quick overview of how to use rio-tiler's main reader <code>rio_tiler.io.rasterio.Reader</code>:</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData, PointData\n\ntile_x = 691559\ntile_y = 956905\ntile_zoom = 21\n\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    # Read data for a slippy map tile\n    img = dst.tile(tile_x, tile_y, tile_zoom, tilesize=256)\n    assert isinstance(img, ImageData)  # Image methods return data as rio_tiler.models.ImageData object\n\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 256, 256)\n    print(img.mask.shape)\n    &gt;&gt;&gt; (256, 256)\n\n    # Read the entire data\n    img = dst.read()\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 11666, 19836)\n\n    # Read part of a data for a given bbox (we use `max_size=1024` to limit the data transfer and read lower resolution data)\n    img = dst.part([-61.281, 15.539, -61.279, 15.541], max_size=1024)\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 1024, 1024)\n\n    # Read data for a given geojson polygon (we use `max_size=1024` to limit the data transfer and read lower resolution data)\n    img = dst.feature(geojson_feature, max_size=1024)\n\n    # Get a preview (size is maxed out to 1024 by default to limit the data transfer and read lower resolution data)\n    img = dst.preview()\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 603, 1024)\n\n    # Get pixel values for a given lon/lat coordinate\n    values = dst.point(-61.281, 15.539)\n    assert isinstance(img, PointData)  # Point methods return data as rio_tiler.models.PointData object\n    print(values.data)\n    &gt;&gt;&gt; [47, 62, 43]\n</code></pre> <p>The <code>rio_tiler.io.rasterio.Reader</code> class has other interesting features, please see User Guide - Readers.</p>"},{"location":"intro/#render-the-data-as-an-image-pngjpeg","title":"Render the data as an image (PNG/JPEG)","text":"<pre><code>with Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    img = dst.tile(691559, 956905, 21, tilesize=256)\n\n    # Encode the data in PNG (default)\n    buff = img.render()\n\n    # Encode the data in JPEG\n    buff = img.render(img_format=\"JPEG\")\n</code></pre>"},{"location":"intro/#rescale-non-byte-data-andor-apply-colormap","title":"Rescale non-byte data and/or apply colormap","text":"<pre><code>from rio_tiler.colormap import cmap\n\n# Get Colormap\ncm = cmap.get(\"viridis\")\n\nwith Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as dst:\n    img = dst.tile(239, 220, 9)\n\n    # Rescale the data from 0-10000 to 0-255\n    img.rescale(\n        in_range=((0, 10000),),\n        out_range=((0, 255),),\n    )\n\n    # Apply colormap and create a PNG buffer\n    buff = img.render(colormap=cm) # this returns a buffer (PNG by default)\n</code></pre>"},{"location":"intro/#use-creation-options-to-match-mapnik-defaults","title":"Use creation options to match <code>mapnik</code> defaults.","text":"<pre><code>from rio_tiler.profiles import img_profiles\n\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    img = dst.tile(691559, 956905, 21, tilesize=256)\n\n    options = img_profiles.get(\"webp\")\n\n    print(options)\n    &gt;&gt;&gt; {'quality': 75, 'lossless': False}\n\n    buff = img.render(img_format=\"webp\", **options)\n</code></pre> <p>Note: Starting with <code>rio-tiler==2.1</code>, when the output datatype is not valid for a driver (e.g <code>float</code> for <code>PNG</code>), <code>rio-tiler</code> will automatically rescale the data using the <code>min/max</code> value for the datatype (ref: cogeotiff/rio-tiler!391).</p>"},{"location":"intro/#write-image-to-file","title":"Write image to file","text":"<pre><code>with open(\"my.png\", \"wb\") as f:\n  f.write(buff)\n</code></pre>"},{"location":"intro/#numpytile","title":"NumpyTile","text":"<p>You can also export image data to a numpy binary format (<code>NPY</code>).</p> <pre><code>with Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as dst:\n    img = dst.tile(239, 220, 9)\n\n    buff = img.render(img_format=\"npy\")\n\n    npy_tile = numpy.load(BytesIO(buff))\n    assert npy_tile.shape == (2, 256, 256)  # mask is added to the end of the data\n\n    buff = img.render(img_format=\"npy\", add_mask=False)\n\n    npy_tile = numpy.load(BytesIO(buff))\n    assert npy_tile.shape == (1, 256, 256)\n</code></pre> <p>Learn more about the NumpyTile specification here.</p>"},{"location":"intro/#rio-tilers-magic-partial-reading","title":"<code>rio-tiler</code>'s magic: Partial reading","text":"<p>When the output image size, or the AOI is smaller than the input image, <code>GDAL</code> will try to perform decimated and/or spatial reads on the raster source, minimizing the amount data to transfer. Because of this, performance will be optimal when the source format permits efficient partial reads.</p> <p>The Cloud-Optimized GeoTIFF (COG) format is the recommended format for rio-tiler because it's natively: - internally tiled - has a header with a <code>map</code> of all the tiles - can have internal overviews</p> <p>To learn more about efficiency of COG vs other file formats, check out this blog post.</p>"},{"location":"models/","title":"Models","text":""},{"location":"models/#imagedata","title":"ImageData","text":"<p>Reader methods returning image data  (<code>tile</code>, <code>part</code>, <code>feature</code> and <code>preview</code>) return a data holding class: <code>rio_tiler.models.ImageData</code>.</p> <p>This class has helper methods like <code>render</code> which forward internal data and mask to <code>rio_tiler.utils.render</code> method, but also helps preserving geospatial information (<code>bounds</code> and <code>crs</code>) about the data.</p>"},{"location":"models/#attributes","title":"Attributes","text":"<ul> <li>array: image array (numpy.ma.MaskedArray)</li> <li>assets: assets list used to create the data array (list, optional)</li> <li>bounds: bounds of the data (rasterio.coords.BoundingBox, optional)</li> <li>crs: coordinate reference system for the data (rasterio.crs.CRS, optional)</li> <li>metadata: additional metadata (dict, optional)</li> <li>band_names: image band's names (e.g <code>[\"b1\", \"b2\"]</code>)</li> <li>band_descriptions: image band's descriptions (e.g <code>[\"Green\", \"Red\"]</code>)</li> <li>dataset_statistics: Dataset's min/max values (list of (min,max), optional)</li> <li>cutline_mask: array representing the mask for <code>feature</code> methods</li> <li>alpha_nask: array reprsenting the alpha mask (allowing partial transparency)</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\nd = numpy.zeros((3, 256, 256))\nm = numpy.zeros((3, 256, 256), dtype=\"bool\")\n\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nprint(ImageData(data))\n&gt;&gt;&gt; ImageData(\n    array=masked_array(...),\n    assets=None,\n    bounds=None,\n    crs=None,\n    metadata={},\n    band_names=['b1', 'b2', 'b3'],\n    dataset_statistics=None,\n    cutline_mask=array(),\n)\n</code></pre>"},{"location":"models/#properties","title":"Properties","text":"<ul> <li>width: number of column in the data array (int)</li> <li>height: number of row in the data array (int)</li> <li>count: number of bands in the data array (int)</li> <li>transform: Affine transform created from the bounds and crs (affine.Affine)</li> <li>data: Return data part of the masked array.</li> <li>mask: Return the mask part in form of rasterio dataset mask.</li> </ul>"},{"location":"models/#classmethods","title":"ClassMethods","text":"<ul> <li> <p>from_bytes(): Create an ImageData instance from a Raster buffer</p> <pre><code>with open(\"img.tif\", \"rb\") as f:\n    img = ImageData.from_bytes(f.read())\n</code></pre> </li> <li> <p>create_from_list(): Create ImageData from a sequence of ImageData objects.</p> <pre><code>r = ImageData(numpy.zeros((1, 256, 256)))\ng = ImageData(numpy.zeros((1, 256, 256)))\nb = ImageData(numpy.zeros((1, 256, 256)))\n\nimg = ImageData.create_from_list([r, g, b])\n</code></pre> </li> </ul>"},{"location":"models/#methods","title":"Methods","text":"<ul> <li> <p>data_as_image(): Return the data array reshaped into an image processing/visualization software friendly order</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\nd = numpy.zeros((3, 256, 256))\nm = numpy.zeros((3, 256, 256), dtype=\"bool\")\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nimg = ImageData(data)\nprint(img.data.shape)\n&gt;&gt;&gt; (3, 256, 256)\n\nimage = img.data_as_image()\nprint(image.shape)\n&gt;&gt;&gt; (256, 256, 3)\n</code></pre> </li> <li> <p>clip(): Clip data and mask to a bbox (in the ImageData CRS).</p> <p>New in version 4.0.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((3, 1024, 1024), dtype=\"uint8\")\nimg = ImageData(data, crs=\"epsg:4326\", bounds=(-180, -90, 180, 90))\n\nimg_c = img.clip((-100, -50, 100, 50))\nassert img_c.count == 3\nassert img_c.bounds == (-100, -50, 100, 50)\n</code></pre> </li> <li> <p>resize(): Resize data and mask.</p> <p>New in version 4.0.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((3, 1024, 1024), dtype=\"uint8\")\nimg = ImageData(data)\n\nimg_r = img.resize(256, 256)\nassert img_r.count == 3\nassert img_r.width == 256\nassert img_r.height == 256\n</code></pre> </li> <li> <p>reproject(): Reproject the ImageData to a user defined projection</p> <pre><code>data = numpy.zeros((3, 1024, 1024), dtype=\"uint8\")\nimg = ImageData(data, crs=\"epsg:4326\", bounds=(-180, -90, 180, 90))\nimg = img.reproject(dst_crs=\"epsg:3857\")\n</code></pre> </li> <li> <p>post_process(): Apply rescaling or/and <code>color-operations</code> formula to the data array. Returns a new ImageData instance.</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'int64'\n\nprint(img.data.max())\n&gt;&gt;&gt; 2999\n\n# rescale the data from 0 -&gt; 3000 to 0 -&gt; 255\n# by default rio-tiler will apply the same `in_range` for all the bands\nimage = img.post_process(in_range=((0, 3000),))\n\n# or provide range for each bands\nimage = img.post_process(in_range=((0, 3000), (0, 1000), (0, 2000)))\n\nassert isinstance(image, ImageData)\n\nprint(image.data.dtype)\n&gt;&gt;&gt; 'uint8'\n\nprint(image.data.max())\n&gt;&gt;&gt; 254\n\n# rescale and apply color-operations formula\nimage = img.post_process(\n    in_range=((0, 3000),),\n    color_formula=\"Gamma RGB 3.1\",\n)\nassert isinstance(image, ImageData)\n</code></pre> </li> <li> <p>statistics(): Return statistics from ImageData.</p> <p>New in version 4.1.7</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((1, 256, 256), dtype=\"uint8\")\ndata[0, 0:10, 0:10] = 0\ndata[0, 10:11, 10:11] = 100\nimg = ImageData(data)\nstats = img.statistics(categorical=True)\n\nprint(stats[\"b1\"].min)\n&gt;&gt;&gt; 0\n\nprint(stats[\"b1\"].max)\n&gt;&gt;&gt; 100\n\nprint(stats[\"b1\"].majority)\n&gt;&gt;&gt; 0\n\nprint(stats[\"b1\"].minority)\n&gt;&gt;&gt; 100\n\nprint(stats[\"b1\"].unique)\n&gt;&gt;&gt; 2.0\n</code></pre> </li> <li> <p>rescale(): linear rescaling of the data in place</p> <p>New in version 3.1.5</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'int64'\n\nprint(img.data.max())\n&gt;&gt;&gt; 2999\n\n# rescale and apply color-operations formula\nimg.rescale(in_range=((0, 3000),),)\nprint(img.data.max())\n&gt;&gt;&gt; 254\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint8'\n</code></pre> </li> <li> <p>apply_color_formula(): Apply <code>color-operations</code>'s color formula in place</p> <p>New in version 3.1.5</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 16000, (3, 256, 256)).astype(\"uint16\")\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint16'\n\nimg.apply_color_formula(\"Gamma RGB 3.5\")\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint8'\n\nprint(img.data.max())\n&gt;&gt;&gt; 170\n</code></pre> </li> <li> <p>apply_colormap(): Apply colormap to the image data</p> <p>New in version 4.1.6</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ncm = {0: (0, 0, 0, 255), 1: (255, 255, 255, 255)}\nim = ImageData(numpy.zeros((1, 256, 256), dtype=\"uint8\")).apply_colormap(cm)\nassert im.data.shape == (3, 256, 256)\nassert im.data[:, 0, 0].tolist() == [0, 0, 0]\nassert im.mask[0, 0] == 255\nassert im.mask.all()\n</code></pre> </li> <li> <p>apply_expression(): Apply band math expression</p> <p>New in version 4.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\n\nimg = ImageData(data)\nprint(img.band_names)\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]  # Defaults\n\nratio = img.apply_expression(\"b1/b2\")  # Returns a new ImageData object\nassert isinstance(ratio, ImageData)\n\nprint(ratio.band_names)\n&gt;&gt;&gt; [\"b1/b2\"]\n\nprint(ratio.data.shape)\n&gt;&gt;&gt; (1, 256, 256)\n</code></pre> </li> <li> <p>render(): Render the data/mask to an image buffer (forward data and mask to rio_tiler.utils.render).</p> <pre><code>import numpy\nfrom rasterio.io import MemoryFile\nfrom rio_tiler.models import ImageData\n\ndef get_meta(content):\n    with MemoryFile(content) as mem:\n        with mem.open() as dst:\n            return dst.meta\n\ndata = numpy.zeros((3, 256, 256), dtype=\"uint8\")\n\nimg = ImageData(data)\n\n# create a PNG image\nbuf = img.render(img_format=\"png\")\nprint(get_meta(buf))\n&gt;&gt;&gt; {\n    'driver': 'PNG',\n    'dtype': 'uint8',\n    'nodata': None,\n    'width': 256,\n    'height': 256,\n    'count': 4,\n    'crs': None,\n    'transform': Affine(1.0, 0.0, 0.0, 0.0, 1.0, 0.0)\n}\n\n# create a JPEG image\nbuf = img.render(img_format=\"jpeg\")\nprint(get_meta(buf))\n&gt;&gt;&gt; {\n    'driver': 'JPEG',\n    'dtype': 'uint8',\n    'nodata': None,\n    'width': 256,\n    'height': 256,\n    'count': 3,\n    'crs': None,\n    'transform': Affine(1.0, 0.0, 0.0, 0.0, 1.0, 0.0)\n}\n</code></pre> </li> </ul> <p>Note: Starting with <code>rio-tiler==2.1</code>, when the output datatype is not valid for a driver (e.g <code>float</code> for <code>PNG</code>), <code>rio-tiler</code> will automatically rescale the data using the <code>min/max</code> value for the datatype (ref: cogeotiff/rio-tiler!391).</p> <ul> <li> <p>to_raster(): Save ImageData array to raster file</p> <pre><code>img = ImageData(numpy.zeros((1, 256, 256)))\nimg.to_raster(\"img.tif\", driver=\"GTiff\")\n</code></pre> </li> </ul>"},{"location":"models/#pointdata","title":"PointData","text":"<p>New in version 4.0</p>"},{"location":"models/#attributes_1","title":"Attributes","text":"<ul> <li>array: image array (numpy.ma.MaskedArray)</li> <li>assets: assets list used to create the data array (list, optional)</li> <li>coordinates: Coordinates of the point (Tuple[float, float], optional)</li> <li>crs: coordinate reference system for the data (rasterio.crs.CRS, optional)</li> <li>metadata: additional metadata (dict, optional)</li> <li>band_names: image band's names (e.g <code>[\"b1\", \"b2\"]</code>)</li> <li>band_descriptions: image band's descriptions (e.g <code>[\"Green\", \"Red\"]</code>)</li> <li>pixel_location: X, Y coordinates in raster space (Tuple[float, float], optional)</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import PointData\n\nd = numpy.zeros((3))\nm = numpy.zeros((1), dtype=\"bool\")\n\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nprint(PointData(data))\n&gt;&gt;&gt; PointData(\n    array=masked_array(data=[0.0, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20),\n    band_names=['b1', 'b2', 'b3'],\n    coordinates=None,\n    crs=None,\n    assets=None,\n    metadata={},\n)\n)\n</code></pre>"},{"location":"models/#properties_1","title":"Properties","text":"<ul> <li>count: number of bands in the data array (int)</li> <li>data: Return data part of the masked array.</li> <li>mask: Return the mask part in form of rasterio dataset mask.</li> </ul>"},{"location":"models/#methods_1","title":"Methods","text":"<ul> <li>apply_expression(): Apply band math expression</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import PointData\n\ndata = numpy.random.randint(0, 3000, (3))\n\npts = PointData(data)\nprint(pts.band_names)\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]  # Defaults\n\nratio = pts.apply_expression(\"b1/b2\")  # Returns a new PointData object\nassert isinstance(ratio, PointData)\n\nprint(ratio.band_names)\n&gt;&gt;&gt; [\"b1/b2\"]\n\nprint(ratio.count)\n&gt;&gt;&gt; 1\n</code></pre>"},{"location":"models/#others","title":"Others","text":"<p>Readers methods returning metadata like results (<code>info()</code> and <code>statistics()</code>) return pydantic models to make sure the values are valids.</p>"},{"location":"models/#info","title":"Info","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import Info\n\n# Schema\nprint(Info.schema())\n&gt;&gt;&gt; {\n    \"$defs\": {\n        \"BoundingBox\": {\n            \"maxItems\": 4,\n            \"minItems\": 4,\n            \"prefixItems\": [\n                {\n                    \"title\": \"Left\"\n                },\n                {\n                    \"title\": \"Bottom\"\n                },\n                {\n                    \"title\": \"Right\"\n                },\n                {\n                    \"title\": \"Top\"\n                }\n            ],\n            \"type\": \"array\"\n        }\n    },\n    \"additionalProperties\": true,\n    \"description\": \"Dataset Info.\",\n    \"properties\": {\n        \"bounds\": {\n            \"$ref\": \"#/$defs/BoundingBox\"\n        },\n        \"crs\": {\n            \"title\": \"Crs\",\n            \"type\": \"string\"\n        },\n        \"band_metadata\": {\n            \"items\": {\n                \"maxItems\": 2,\n                \"minItems\": 2,\n                \"prefixItems\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"object\"\n                    }\n                ],\n                \"type\": \"array\"\n            },\n            \"title\": \"Band Metadata\",\n            \"type\": \"array\"\n        },\n        \"band_descriptions\": {\n            \"items\": {\n                \"maxItems\": 2,\n                \"minItems\": 2,\n                \"prefixItems\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"string\"\n                    }\n                ],\n                \"type\": \"array\"\n            },\n            \"title\": \"Band Descriptions\",\n            \"type\": \"array\"\n        },\n        \"dtype\": {\n            \"title\": \"Dtype\",\n            \"type\": \"string\"\n        },\n        \"nodata_type\": {\n            \"enum\": [\n                \"Alpha\",\n                \"Mask\",\n                \"Internal\",\n                \"Nodata\",\n                \"None\"\n            ],\n            \"title\": \"Nodata Type\",\n            \"type\": \"string\"\n        },\n        \"colorinterp\": {\n            \"anyOf\": [\n                {\n                    \"items\": {\n                        \"type\": \"string\"\n                    },\n                    \"type\": \"array\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ],\n            \"default\": null,\n            \"title\": \"Colorinterp\"\n        },\n        \"scales\": {\n            \"anyOf\": [\n                {\n                    \"items\": {\n                        \"type\": \"number\"\n                    },\n                    \"type\": \"array\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ],\n            \"default\": null,\n            \"title\": \"Scales\"\n        },\n        \"offsets\": {\n            \"anyOf\": [\n                {\n                    \"items\": {\n                        \"type\": \"number\"\n                    },\n                    \"type\": \"array\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ],\n            \"default\": null,\n            \"title\": \"Offsets\"\n        },\n        \"colormap\": {\n            \"anyOf\": [\n                {\n                    \"additionalProperties\": {\n                        \"maxItems\": 4,\n                        \"minItems\": 4,\n                        \"prefixItems\": [\n                            {\n                                \"type\": \"integer\"\n                            },\n                            {\n                                \"type\": \"integer\"\n                            },\n                            {\n                                \"type\": \"integer\"\n                            },\n                            {\n                                \"type\": \"integer\"\n                            }\n                        ],\n                        \"type\": \"array\"\n                    },\n                    \"type\": \"object\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ],\n            \"default\": null,\n            \"title\": \"Colormap\"\n        }\n    },\n    \"required\": [\n        \"bounds\",\n        \"crs\",\n        \"band_metadata\",\n        \"band_descriptions\",\n        \"dtype\",\n        \"nodata_type\"\n    ],\n    \"title\": \"Info\",\n    \"type\": \"object\"\n}\n\n# Example\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    info = src.info()\n\nprint(info.nodata_type)\n&gt;&gt;&gt; \"None\"\n\nprint(info.model_dump_json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [\n        683715.3266400001,\n        1718548.5702,\n        684593.2680000002,\n        1719064.90736\n    ],\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/32620\",\n    \"band_metadata\": [\n        [\n            \"b1\",\n            {}\n        ],\n        [\n            \"b2\",\n            {}\n        ],\n        [\n            \"b3\",\n            {}\n        ]\n    ],\n    \"band_descriptions\": [\n        [\n            \"b1\",\n            \"\"\n        ],\n        [\n            \"b2\",\n            \"\"\n        ],\n        [\n            \"b3\",\n            \"\"\n        ]\n    ],\n    \"dtype\": \"uint8\",\n    \"nodata_type\": \"Mask\",\n    \"colorinterp\": [\n        \"red\",\n        \"green\",\n        \"blue\"\n    ],\n    \"scales\": [\n        1,\n        1,\n        1\n    ],\n    \"offsets\": [\n        0,\n        0,\n        0\n    ],\n    \"driver\": \"GTiff\",\n    \"count\": 3,\n    \"width\": 19836,\n    \"height\": 11666,\n    \"overviews\": [\n        2,\n        4,\n        8,\n        16,\n        32,\n        64\n    ]\n}\n</code></pre> <p>Note: starting with <code>rio-tiler&gt;=2.0.8</code>, additional metadata can be set (e.g. driver, count, width, height, overviews in <code>Reader.info()</code>)</p>"},{"location":"models/#bandstatistics","title":"BandStatistics","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import BandStatistics\n\n# Schema\nprint(BandStatistics.schema())\n&gt;&gt;&gt; {\n    \"title\": \"BandStatistics\",\n    \"description\": \"Image statistics\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"min\": {\n            \"title\": \"Min\",\n            \"type\": \"number\"\n        },\n        \"max\": {\n            \"title\": \"Max\",\n            \"type\": \"number\"\n        },\n        \"mean\": {\n            \"title\": \"Mean\",\n            \"type\": \"number\"\n        },\n        \"count\": {\n            \"title\": \"Count\",\n            \"type\": \"number\"\n        },\n        \"sum\": {\n            \"title\": \"Sum\",\n            \"type\": \"number\"\n        },\n        \"std\": {\n            \"title\": \"Std\",\n            \"type\": \"number\"\n        },\n        \"median\": {\n            \"title\": \"Median\",\n            \"type\": \"number\"\n        },\n        \"majority\": {\n            \"title\": \"Majority\",\n            \"type\": \"number\"\n        },\n        \"minority\": {\n            \"title\": \"Minority\",\n            \"type\": \"number\"\n        },\n        \"unique\": {\n            \"title\": \"Unique\",\n            \"type\": \"number\"\n        },\n        \"histogram\": {\n            \"title\": \"Histogram\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"anyOf\": [\n                        {\n                            \"type\": \"number\"\n                        },\n                        {\n                            \"type\": \"integer\"\n                        }\n                    ]\n                }\n            }\n        },\n        \"valid_percent\": {\n            \"title\": \"Valid Percent\",\n            \"type\": \"number\"\n        },\n        \"masked_pixels\": {\n            \"title\": \"Masked Pixels\",\n            \"type\": \"number\"\n        },\n        \"valid_pixels\": {\n            \"title\": \"Valid Pixels\",\n            \"type\": \"number\"\n        }\n    },\n    \"required\": [\n        \"min\",\n        \"max\",\n        \"mean\",\n        \"count\",\n        \"sum\",\n        \"std\",\n        \"median\",\n        \"majority\",\n        \"minority\",\n        \"unique\",\n        \"histogram\",\n        \"valid_percent\",\n        \"masked_pixels\",\n        \"valid_pixels\"\n    ]\n}\n\n# Example\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n    assert isinstance(stats[\"b1\"], BandStatistics)\n\nprint(stats[\"b1\"].min)\n&gt;&gt;&gt; 0.0\n\nprint(stats[\"b1\"].model_dump_json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"min\": 0,\n    \"max\": 255,\n    \"mean\": 93.16424226523633,\n    \"count\": 617472,\n    \"sum\": 57526311,\n    \"std\": 59.261322978176324,\n    \"median\": 94,\n    \"majority\": 0,\n    \"minority\": 253,\n    \"unique\": 256,\n    \"histogram\": [\n        [\n            100540,\n            43602,\n            87476,\n            112587,\n            107599,\n            73453,\n            43623,\n            21971,\n            15006,\n            11615\n        ],\n        [\n            0,\n            25.5,\n            51,\n            76.5,\n            102,\n            127.5,\n            153,\n            178.5,\n            204,\n            229.5,\n            255\n        ]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 617472,\n    \"percentile_2\": 0,\n    \"percentile_98\": 228\n}\n</code></pre>"},{"location":"models/#links","title":"Links","text":"<p>Attrs - Classes Without Boilerplate https://www.attrs.org/en/stable/</p> <p>Pydantic - Define how data should be in pure, canonical python https://pydantic-docs.helpmanual.io</p>"},{"location":"mosaic/","title":"Mosaic","text":"<p>The <code>rio-tiler-mosaic</code> library has been moved into <code>rio-tiler</code>. The goal of the <code>rio_tiler.mosaic</code> module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest.</p> <p>Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the <code>rio-tiler.mosaic</code> module provides pixel selection methods which define how to handle these cases for each pixel:</p> <ul> <li>First: select value from the first non-missing asset</li> <li>Highest: loop though all the assets and return the highest value</li> <li>Lowest: loop though all the assets and return the lowest value</li> <li>Mean: compute the mean value of the whole stack</li> <li>Median: compute the median value of the whole stack</li> <li>Stdev: compute the standard deviation value of the whole stack</li> <li>LastBandHigh: Use last band (highest) as a decision factor (note: the last band will be excluded from in the output)</li> <li>LastBandLow: Use last band (lowest) as a decision factor (note: the last band will be excluded from in the output)</li> </ul>"},{"location":"mosaic/#api","title":"API","text":""},{"location":"mosaic/#image","title":"Image","text":"<p><pre><code>rio_tiler.mosaic.mosaic_reader(\n    mosaic_assets: Sequence[str],\n    reader: Callable[..., ImageData],\n    *args: Any,\n    pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod,\n    chunk_size: Optional[int] = None,\n    threads: int = MAX_THREADS,\n    allowed_exceptions: Tuple = (TileOutsideBounds,),\n    **kwargs,\n)\n</code></pre> Inputs:</p> <ul> <li>mosaic_assets : list, tuple of rio-tiler compatible assets (url or sceneid)</li> <li>reader: Callable that returns a <code>ImageData</code> instance or a tuple of <code>numpy.array</code></li> <li>*args: arguments to be forwarded to the callable.</li> <li>pixel_selection : optional pixel selection algorithm (default: \"first\").</li> <li>chunk_size: optional, control the number of assets to process per loop.</li> <li>threads: optional, number of threads to use in each loop.</li> <li>allowed_exceptions: optional, allow some exceptions to be ignored.</li> <li>**kwargs: tiler specific keyword arguments.</li> </ul> <p>Returns: - img, assets_used : tuple of ImageData and list of used assets to construct the output data.</p>"},{"location":"mosaic/#examples","title":"Examples","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.models import ImageData\n\n\ndef tiler(src_path: str, *args, **kwargs) -&gt; ImageData:\n    with Reader(src_path) as src:\n        return src.tile(*args, **kwargs)\n\nmosaic_assets = [\"mytif1.tif\", \"mytif2.tif\", \"mytif3.tif\"]\nx = 1000\ny = 1000\nz = 9\n\n# Use Default First value method\nimg, _ = mosaic_reader(mosaic_assets, tiler, x, y, z)\nassert isinstance(img, ImageData)\nassert img.data.shape == (3, 256, 256)\n\n# Use Highest value: defaults.HighestMethod()\nimg, _ = mosaic_reader(\n    mosaic_assets,\n    tiler,\n    x,\n    y,\n    z,\n    pixel_selection=defaults.HighestMethod()\n)\n</code></pre>"},{"location":"mosaic/#point","title":"Point","text":"<p><pre><code>rio_tiler.mosaic.mosaic_point_reader(\n    mosaic_assets: Sequence[str],\n    reader: Callable[..., PointData],\n    *args: Any,\n    pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod,\n    chunk_size: Optional[int] = None,\n    threads: int = MAX_THREADS,\n    allowed_exceptions: Tuple = (TileOutsideBounds,),\n    **kwargs,\n)\n</code></pre> Inputs:</p> <ul> <li>mosaic_assets : list, tuple of rio-tiler compatible assets (url or sceneid)</li> <li>reader: Callable that returns a <code>PointData</code> instance</li> <li>*args: arguments to be forwarded to the callable.</li> <li>pixel_selection : optional pixel selection algorithm (default: \"first\").</li> <li>chunk_size: optional, control the number of assets to process per loop.</li> <li>threads: optional, number of threads to use in each loop.</li> <li>allowed_exceptions: optional, allow some exceptions to be ignored.</li> <li>**kwargs: tiler specific keyword arguments.</li> </ul> <p>Returns: - point, assets_used : tuple of PointData and list of used assets to construct the output data.</p>"},{"location":"mosaic/#examples_1","title":"Examples","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.models import PointData\n\n\ndef point_reader(src_path: str, *args, **kwargs) -&gt; PointData:\n    with Reader(src_path) as src:\n        return src.point(*args, **kwargs)\n\nmosaic_assets = [\"mytif1.tif\", \"mytif2.tif\", \"mytif3.tif\"]\n\n\n# Use Default First value method\npt, _ = mosaic_point_reader(mosaic_assets, point_reader, -40, 32)\nassert isinstance(pt, PointData)\nassert len(pt.data) == 3\n\n# Use Highest value: defaults.HighestMethod()\nimg, _ = mosaic_point_reader(\n    mosaic_assets,\n    point_reader,\n    -40,\n    32,\n    pixel_selection=defaults.HighestMethod()\n)\n</code></pre>"},{"location":"mosaic/#the-mosaicmethod-interface","title":"The <code>MosaicMethod</code> interface","text":"<p>the <code>rio_tiler.mosaic.methods.base.MosaicMethodBase</code> abstract base class defines an interface for all <code>pixel selection</code> methods allowed by <code>rio_tiler.mosaic.mosaic_reader</code>. its methods and properties are:</p>"},{"location":"mosaic/#properties","title":"Properties","text":"<ul> <li>is_done: returns a boolean indicating if the process is done filling the array</li> <li>data: returns the output mosaic array (numpy.masked.array)</li> </ul>"},{"location":"mosaic/#methods","title":"Methods","text":"<ul> <li>feed(array: numpy.ma.ndarray): update the tile and mask</li> </ul>"},{"location":"mosaic/#writing-your-own-pixel-selection-method","title":"Writing your own Pixel Selection method","text":"<p>The rules for writing your own <code>pixel selection algorithm</code> class are as follows:</p> <ul> <li>Must inherit from <code>MosaicMethodBase</code></li> <li>Must provide concrete implementations of all the above methods.</li> </ul> <p>See <code>rio_tiler.mosaic.methods.defaults</code> classes for examples.</p>"},{"location":"mosaic/#smart-multi-threading","title":"Smart Multi-Threading","text":"<p>When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, <code>rio_tiler.mosaic.mosaic_reader</code> is fetching the tiles in parallel (threads) but to limit the number of files we also embedded the fetching in a loop (creating 2 level of processing):</p> <p><pre><code>mosaic_assets = [\"1.tif\", \"2.tif\", \"3.tif\", \"4.tif\", \"5.tif\", \"6.tif\"]\n\n# 1st level loop - Creates chunks of assets\nfor chunks in _chunks(mosaic_assets, chunk_size):\n\n    # 2nd level loop - Uses threads for process each `chunk`\n    with futures.ThreadPoolExecutor(max_workers=max_threads) as executor:\n        future_tasks = [(executor.submit(_tiler, asset), asset) for asset in chunks]\n</code></pre> By default the chunk_size is equal to the number or threads (or the number of assets if no threads=0)</p>"},{"location":"mosaic/#more-on-threading","title":"More on threading","text":"<p>The number of threads used can be set in the function call with the <code>threads=</code> options. By default it will be equal to <code>multiprocessing.cpu_count() * 5</code> or to the <code>RIO_TILER_MAX_THREADS</code> environment variable. In some case, threading can slow down your application. You can set threads to <code>0</code> or <code>1</code> to run the tiler in a loop without using a ThreadPool (ref: #207).</p> <p>Benchmark: <pre><code>--------------------------------- benchmark '1images': 6 tests ---------------------------------\nName (time in ms)         Min                Max               Mean             Median\n------------------------------------------------------------------------------------------------\n1images-0threads      64.3108 (1.0)      66.9192 (1.0)      65.0202 (1.0)      64.9370 (1.0)\n1images-4threads      69.0893 (1.07)     70.9919 (1.06)     69.6718 (1.07)     69.5102 (1.07)\n1images-1threads      69.4884 (1.08)     71.8967 (1.07)     70.0853 (1.08)     69.9804 (1.08)\n1images-5threads      69.5552 (1.08)     75.5498 (1.13)     71.7882 (1.10)     70.9849 (1.09)\n1images-3threads      69.7684 (1.08)     74.4098 (1.11)     70.6282 (1.09)     70.2353 (1.08)\n1images-2threads      69.9258 (1.09)     73.8798 (1.10)     70.8861 (1.09)     70.3682 (1.08)\n------------------------------------------------------------------------------------------------\n\n----------------------------------- benchmark '5images': 6 tests -----------------------------------\nName (time in ms)          Min                 Max                Mean              Median\n----------------------------------------------------------------------------------------------------\n5images-5threads      104.1609 (1.0)      123.4442 (1.0)      110.4130 (1.0)      110.0683 (1.0)\n5images-4threads      160.0952 (1.54)     170.7994 (1.38)     163.6062 (1.48)     161.8923 (1.47)\n5images-3threads      161.2354 (1.55)     172.0363 (1.39)     165.1222 (1.50)     164.6513 (1.50)\n5images-2threads      214.2413 (2.06)     220.7737 (1.79)     217.7740 (1.97)     217.9166 (1.98)\n5images-0threads      228.2062 (2.19)     242.9397 (1.97)     231.9848 (2.10)     229.2843 (2.08)\n5images-1threads      248.6630 (2.39)     251.8809 (2.04)     250.5195 (2.27)     251.2667 (2.28)\n----------------------------------------------------------------------------------------------------\n</code></pre> ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838</p>"},{"location":"readers/","title":"Readers","text":"<p><code>rio-tiler</code>'s  Reader are built from its abstract base classes (<code>BaseReader</code>, <code>MultiBandReader</code>, <code>MultiBaseReader</code>). Those Classes implements defaults interfaces which helps the integration in broader application. To learn more about <code>rio-tiler</code>'s base classes see Base classes and custom readers</p>"},{"location":"readers/#rio_tileriorasterioreader","title":"rio_tiler.io.rasterio.Reader","text":"<p>The <code>Reader</code> is designed to work with simple raster datasets (e.g COG, GeoTIFF, ...).</p> <p>The class is derived from the <code>rio_tiler.io.base.BaseReader</code> base class. <pre><code>from rio_tiler.io import Reader\n\nReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.rasterio.Reader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes","title":"Attributes","text":"<ul> <li>input (str): filepath</li> <li>dataset (rasterio dataset, optional): rasterio opened dataset</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> <li>colormap (dict, optional): dataset's colormap</li> <li>options (rio_tiler.reader.Options, optional): Options to forward to rio_tiler.reader functions (e.g nodata, vrt_options, resampling)</li> </ul>"},{"location":"readers/#properties","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>minzoom: dataset's minzoom (in TMS)</li> <li>maxzoom: dataset's maxzoom (in TMS)</li> <li>transform: dataset's Affine transform</li> <li>height: dataset's height</li> <li>width: dataset's width</li> </ul> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"myfile.tif\") as src:\n    print(src.dataset)\n    print(src.tms.identifier)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.bounds)\n    print(src.crs)\n    print(src.colormap)\n\n&gt;&gt; &lt;open DatasetReader name='myfile.tif' mode='r'&gt;\nWebMercatorQuad\n16\n22\n(683715.3266400001, 1718548.5702, 684593.2680000002, 1719064.90736)\nEPSG:32620\n{}\n</code></pre>"},{"location":"readers/#methods","title":"Methods","text":"<ul> <li> <p>get_geographic_bounds(crs: rasterio.crs.CRS): Get dataset bounds in geographic projection</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"myfile.tif\") as src:\n    print(src.get_geographic_bounds(\"EPSG:4326\"))\n\n(-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n</code></pre> </li> <li> <p>read(): Read the entire dataset</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    img = src.read()\n    assert isinstance(img, ImageData)\n    assert img.crs == src.dataset.crs\n    assert img.assets == [\"myfile.tif\"]\n    assert img.width == src.dataset.width\n    assert img.height == src.dataset.height\n    assert img.count == src.dataset.count\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.read(indexes=1)  # or src.read(indexes=(1,))\n    assert img.count == 1\n    assert img.band_names == [\"b1\"]\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.read(expression=\"b1/b2\")\n    assert img.count == 1\n    assert img.band_names == [\"b1/b2\"]\n</code></pre> </li> <li> <p>tile(): Read map tile from a raster</p> <pre><code>from rio_tiler.contants import WEB_MERCATOR_CRS\nfrom rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.tile(tile_x, tile_y, tile_z, **kwargs)\n    img = src.tile(1, 2, 3, tilesize=256)\n    assert isinstance(img, ImageData)\n    assert img.crs == WEB_MERCATOR_CRS\n    assert img.assets == [\"myfile.tif\"]\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, indexes=1)\n    assert img.count == 1\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, expression=\"B1/B2\")\n    assert img.count == 1\n\n# Using buffer\n# Sometime, to avoid edge artefacts, you may want to read buffered tile data.\n# ref:\n# - https://github.com/cogeotiff/rio-tiler/issues/365\n# - https://github.com/cogeotiff/rio-tiler/pull/405\nwith Reader(\"myfile.tif\") as src:\n    # add 0.5 pixel on each side of the tile\n    img = src.tile(1, 2, 3, buffer=0.5)\n    assert img.width == 257\n    assert img.height == 257\n\n    # add 1 pixel on each side of the tile\n    img = src.tile(1, 2, 3, buffer=1)\n    assert img.width == 258\n    assert img.height == 258\n</code></pre> </li> <li> <p>part(): Read a raster for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.part((minx, miny, maxx, maxy), **kwargs)\n    img = src.part((10, 10, 20, 20))\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (10, 10, 20, 20)\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n\n# Limit output size\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), max_size=2000)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), expression=\"b1/b2\")\n</code></pre> </li> <li> <p>feature(): Read a raster for a geojson feature. By default the feature is considered to be in WGS84.</p> <pre><code>from rio_tiler.constants import WGS84_CRS\nfrom rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-54.45, 73.05],\n                [-55.05, 72.79],\n                [-55.61, 72.46],\n                [-53.83, 72.36],\n                [-54.45, 73.05],\n            ]\n        ],\n    },\n}\n\nwith Reader(\"myfile.tif\") as src:\n    # src.part(geojson_feature, **kwargs)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (-55.61, 72.36, -53.83, 73.05)  # bbox of the input feature\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n\n# Limit output size\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, max_size=2000)\n\n# Read high resolution\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, max_size=None)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, expression=\"b1/b2\")\n</code></pre> </li> <li> <p>preview(): Read a preview of a raster</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview()\n    assert isinstance(img, ImageData)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview(indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview(expression=\"b1+2;b1*4\")\n</code></pre> </li> <li> <p>point(): Read the pixel values of a raster for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import PointData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.point(lon, lat)\n    pt = src.point(-100, 25)\n    assert isinstance(pt, PointData)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    pt = src.point(-100, 25, indexes=1)\n    print(pt.data)\n&gt;&gt;&gt; [1]\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    pt = src.point(-100, 25, expression=\"b1+2;b1*4\")\n    print(pt.data)\n&gt;&gt;&gt; [3, 4]\n</code></pre> </li> <li> <p>info(): Return simple metadata about the dataset</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import Info\n\nwith Reader(\"myfile.tif\") as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.model_dump(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [373185.0, 8019284.949381611, 639014.9492102272, 8286015.0],\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/32621\"\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"nodata_type\": \"Nodata\",\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255],\n        ...\n    },\n    \"driver\": \"GTiff\",\n    \"count\": 1,\n    \"width\": 1000,\n    \"height\": 2000,\n    \"overviews\": [2, 4, 8],\n}\n</code></pre> </li> <li> <p>statistics(): Return image statistics (Min/Max/Stdev)</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"myfile.tif\") as src:\n    stats = src.statistics()\n    assert isinstance(stats, dict)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...),\n    'b2': BandStatistics(...),\n    'b3': BandStatistics(...)\n}\n\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    \"min\": 1,\n    \"max\": 7872,\n    \"mean\": 2107.524612053134,\n    \"count\": 1045504,\n    \"sum\": 2203425412,\n    \"std\": 2271.0065537857326,\n    \"median\": 2800,\n    \"majority\": 1,\n    \"minority\": 7072,\n    \"unique\": 15,\n    \"histogram\": [\n        [...],\n        [...]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 1045504,\n    \"percentile_98\": 6896,\n    \"percentile_2\": 1\n}\n\nwith Reader(\"myfile_with_colormap.tif\") as src:\n    stats = src.statistics(categorical=True, categories=[1, 2])  # we limit the categories to 2 defined value (defaults to all dataset values)\n    assert isinstance(stats, dict)\n\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...)\n}\n# For categorical data, the histogram will represent the density of EACH value.\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    ...\n    \"histogram\": [\n        [1, 2],\n        [100, 20000]\n    ],\n    ...\n}\n</code></pre> </li> </ul>"},{"location":"readers/#read-options","title":"Read Options","text":"<p><code>Reader</code> accepts several input options which will be forwarded to the <code>rio_tiler.reader.read</code> function (low level function accessing the data), those options can be set as reader's attribute or within each method calls:</p> <ul> <li>nodata: Overwrite the nodata value (or set if not present)</li> <li>unscale: Apply internal rescaling factors</li> <li>vrt_options: Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions)</li> <li>resampling_method: Set default <code>resampling_method</code></li> <li>reprojection_method: Set default <code>reprojection_method</code></li> <li>post_process: Function to apply after the read operations</li> </ul> <pre><code>with Reader(\"my_cog.tif\", options={\"nodata\": 0}) as src:\n   src.tile(1, 1, 1)\n\n# is equivalent to\n\nwith Reader(\"my_cog.tif\") as src:\n    src.tile(1, 1, 1, nodata=0)\n</code></pre>"},{"location":"readers/#rio_tileriostacstacreader","title":"rio_tiler.io.stac.STACReader","text":"<p>In <code>rio-tiler</code> v2, we added a <code>rio_tiler.io.STACReader</code> to allow tile/metadata fetching of assets withing a STAC item.</p> <p>The class is derived from the <code>rio_tiler.io.base.MultiBaseReader</code> base class which help handling responses from multiple <code>BaseReader</code> (each asset will be read with a <code>BaseReader</code>). <pre><code>from rio_tiler.io import STACReader\n\nSTACReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.stac.STACReader,\n rio_tiler.io.base.MultiBaseReader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_1","title":"Attributes","text":"<ul> <li>input (str): STAC Item path, URL or S3 URL</li> <li>item: PySTAC item</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> <li>minzoom (int, optional): dataset's minimum zoom level (for input tms)</li> <li>maxzoom (int, optional): dataset's maximum zoom level (for input tms)</li> <li>include_assets (set, optional): Set of assets to include from the <code>available</code> asset list</li> <li>exclude_assets (set, optional): Set of assets to exclude from the <code>available</code> asset list</li> <li>include_asset_types (set, optional): asset types to consider as valid type for the reader</li> <li>exclude_asset_types (set, optional): asset types to consider as invalid type for the reader</li> <li>default_assets (sequence, optional): default assets to use for the reader if nothing else is provided.</li> <li>reader (BaseReader, optional): Reader to use to read assets (defaults to rio_tiler.io.rasterio.Reader)</li> <li>reader_options (dict, optional): Options to forward to the reader init</li> <li>fetch_options (dict, optional): Options to pass to the <code>httpx.get</code> or <code>boto3</code> when fetching the STAC item</li> </ul>"},{"location":"readers/#properties_1","title":"Properties","text":"<ul> <li>assets: Asset list.</li> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>transform: dataset's Affine transform (from PROJ extension)</li> <li>height: dataset's height (from PROJ extension)</li> <li>width: dataset's width (from PROJ extension)</li> </ul> <pre><code>from rio_tiler.io import STACReader\n\nwith STACReader(\n    \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\",\n    exclude_assets={\"thumbnail\"}\n) as stac:\n    print(stac.input)\n    print(stac.item)\n    print(stac.assets)\n    print(stac.tms.identifier)\n    print(stac.minzoom)\n    print(stac.maxzoom)\n    print(stac.bounds)\n    print(stac.crs)\n\n&gt;&gt;&gt; https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\n&lt;Item id=S2A_34SGA_20200318_0_L2A&gt;\n['overview', 'visual', 'B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B11', 'B12', 'AOT', 'WVP', 'SCL']\nWebMercatorQuad\n0\n24\n[23.293255090449595, 31.505183020453355, 24.296453548295318, 32.51147809805106]\nEPSG:4326\n</code></pre>"},{"location":"readers/#methods_1","title":"Methods","text":"<p>The <code>STACReader</code> has the same methods as the <code>Reader</code> (defined by the BaseReader/MultiBaseReader classes).</p> <p>Important</p> <ul> <li>Most of <code>STACReader</code> methods require to set either <code>assets=</code> or <code>expression=</code> option.</li> <li><code>asset_indexes</code> and <code>asset_expression</code> are available for all STACReader methods except <code>info</code>.</li> </ul> <ul> <li> <p>tile(): Read map tile from a STAC Item</p> <pre><code>from rio_tiler.io import STACReader\n\nstac_url = \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\"\n\n# Using `assets=`\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.tile(x, y, z, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\", \"B02\"],\n    )\n    assert img.count == 2  # each assets have one band\n\nprint(img.assets)\n&gt;&gt;&gt; [\n    'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/34/S/GA/2020/3/S2A_34SGA_20200318_0_L2A/B01.tif',\n    'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/34/S/GA/2020/3/S2A_34SGA_20200318_0_L2A/B02.tif',\n]\nprint(img.band_names)\n&gt;&gt;&gt; ['B01_b1', 'B02_b1']\n\n# Using `expression=`\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"}) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        expression=\"B01_b1/B02_b1\",\n    )\n    assert img.count == 1\n\n# Using `assets=` + `asset_indexes` (select a specific index in an asset)\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\"],\n        asset_indexes={\n            \"B01\": (1, 1, 1),  # return the first band 3 times\n        }\n    )\n    assert img.count == 3\n</code></pre> </li> <li> <p>part(): Read a STAC item for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</p> <pre><code>bbox = (23.8, 31.9, 24.1, 32.2)\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.part((minx, miny, maxx, maxy), assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.part(bbox, assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> </li> <li> <p>feature(): Read a STAC item for a geojson feature. By default the feature is considered to be in WGS84.</p> <pre><code>feat = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"coordinates\": [\n            [\n                [23.8, 32.2],\n                [23.8, 31.9],\n                [24.1, 31.9],\n                [24.1, 32.2],\n                [23.8, 32.2]\n            ]\n        ],\n        \"type\": \"Polygon\"\n    }\n}\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.feature(feature, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.feature(feat, assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> </li> <li> <p>preview(): Read a preview of STAC Item</p> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.preview(assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.preview(assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> </li> <li> <p>point(): Read the pixel values for assets for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</p> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.point(lon, lat, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    data = stac.point(24.1, 31.9, assets=[\"B01\", \"B02\"])\n\nprint(data.data)\n&gt;&gt;&gt; [\n    3595,  # values for B01\n    3198  # values for B02\n]\n</code></pre> </li> <li> <p>info(): Return simple metadata about the assets</p> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.info(assets=?, **kwargs)\n    info = stac.info(assets=[\"B01\", \"B02\"])\n\nprint(list(info))\n&gt;&gt;&gt; [\"B01\", \"B02\"]\n\nprint(info[\"B01\"].json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [373185.0, 8019284.949381611, 639014.9492102272, 8286015.0],\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/32621\"\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"uint16\",\n    \"nodata_type\": \"Nodata\",\n    \"colorinterp\": [\"gray\"],\n    \"nodata_value\": 0.0,\n    \"width\": 1830,\n    \"driver\": \"GTiff\",\n    \"height\": 1830,\n    \"overviews\": [2, 4, 8],\n    \"count\": 1\n}\n</code></pre> </li> <li> <p>statistics(): Return per assets statistics (Min/Max/Stdev)</p> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.statistics(assets=[\"B01\", \"B02\"], max_size=128)\n\n# stats will be in form or {\"asset\": {\"band\": BandStatistics(), ...}, ...}\nprint(list(stats))\n&gt;&gt;&gt; [\"B01\", \"B02\"]\n\nprint(list(stats[\"B01\"]))\n&gt;&gt;&gt; [\"b1\"]  # B01 has only one band entry \"1\"\n\nprint(stats[\"B01\"][\"b1\"].json(exclude_none=True))\n{\n    \"min\": 283.0,\n    \"max\": 7734.0,\n    \"mean\": 1996.959687371452,\n    \"count\": 12155.0,\n    \"sum\": 24273045.0,\n    \"std\": 1218.4455268717047,\n    \"median\": 1866.0,\n    \"majority\": 322.0,\n    \"minority\": 283.0,\n    \"unique\": 4015.0,\n    \"histogram\": [\n        [3257.0, 2410.0, 2804.0, 1877.0, 1050.0, 423.0, 199.0, 93.0, 31.0, 11.0],\n        [283.0, 1028.1, 1773.2, 2518.3, 3263.4, 4008.5, 4753.6, 5498.7, 6243.8, 6988.900000000001, 7734.0]\n    ],\n    \"valid_percent\": 74.19,\n    \"masked_pixels\": 4229.0,\n    \"valid_pixels\": 12155.0,\n    \"percentile_2\": 326.08000000000004,\n    \"percentile_98\": 5026.76\n}\n</code></pre> </li> <li> <p>merged_statistics(): Return statistics when merging assets</p> </li> </ul> <p>The <code>merged_statistics</code> enable the use of <code>expression</code> to perform assets mixing (e.g <code>\"asset1/asset2\"</code>). The main difference with the <code>statistics</code> method is that we will first use the <code>self.preview</code> method to obtain a merged array and then calculate the statistics.</p> <pre><code>```python\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.merged_statistics(assets=[\"B01\", \"B02\"], max_size=128)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(list(stats))\n&gt;&gt;&gt; [\"B01_b1\", \"B02_b1\"]\n\nassert isinstance(stats[\"B01_b1\"], BandStatistics)\n\nprint(info[\"B01_b1\"].json(exclude_none=True))\n{\n    \"min\": 283.0,\n    \"max\": 7734.0,\n    \"mean\": 1996.959687371452,\n    \"count\": 12155.0,\n    \"sum\": 24273045.0,\n    \"std\": 1218.4455268717047,\n    \"median\": 1866.0,\n    \"majority\": 322.0,\n    \"minority\": 283.0,\n    \"unique\": 4015.0,\n    \"histogram\": [\n        [3257.0, 2410.0, 2804.0, 1877.0, 1050.0, 423.0, 199.0, 93.0, 31.0, 11.0],\n        [283.0, 1028.1, 1773.2, 2518.3, 3263.4, 4008.5, 4753.6, 5498.7, 6243.8, 6988.900000000001, 7734.0]\n    ],\n    \"valid_percent\": 74.19,\n    \"masked_pixels\": 4229.0,\n    \"valid_pixels\": 12155.0,\n    \"percentile_2\": 326.08000000000004,\n    \"percentile_98\": 5026.76\n}\n\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.merged_statistics(expression=[\"B01_b1/B02_b1\"], max_size=128)\n\nprint(list(stats))\n&gt;&gt;&gt; [\"B01_b1/B02_b1\"]\n\nassert isinstance(stats[\"B01_b1/B02_b1\"], BandStatistics)\n```\n</code></pre>"},{"location":"readers/#stac-expression","title":"STAC Expression","text":"<p>When using <code>expression</code>, the user will need to explicitly pass the band number to use within the asset e.g: <code>asset1_b1 + asset2_b2</code>.</p>"},{"location":"readers/#asset-as-band","title":"Asset As Band","text":"<p>in rio-tiler <code>4.1.0</code>, we've added <code>asset_as_band: bool</code> option to the data methods (tile, feature, part, preview, point) to tell the reader to treat each asset as a dataset band. This is specifically useful for <code>expression</code></p> <pre><code># For expression, without `asset_as_band` tag, users have to pass `_b{n}` suffix to indicate the band index\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green_b1/red_b1\")\n    assert img.band_names == [\"green_b1/red_b1\"]\n\n# With `asset_as_band=True`, expression can be the asset names\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green/red\", asset_as_band=True)\n    assert img.band_names == [\"green/red\"]\n</code></pre>"},{"location":"readers/#rio_tileriorasterioimagereader","title":"rio_tiler.io.rasterio.ImageReader","text":"<p>The <code>Reader</code> is designed to work with simple raster datasets in their pixel coordinates.</p> <p>The class is derived from the <code>rio_tiler.io.rasterio.Reader</code> class. <pre><code>from rio_tiler.io import ImageReader\n\nImageReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.rasterio.ImageReader,\n rio_tiler.io.rasterio.Reader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_2","title":"Attributes","text":"<ul> <li>input (str): filepath</li> <li>dataset (rasterio dataset, optional): rasterio opened dataset</li> <li>colormap (dict, optional): dataset's colormap</li> <li>options (rio_tiler.reader.Options, optional): Options to forward to rio_tiler.reader functions (e.g nodata, vrt_options, resampling)</li> </ul>"},{"location":"readers/#properties_2","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>transform: dataset Affine transform (in pixel coordinates)</li> <li>minzoom: dataset minzoom</li> <li>maxzoom: dataset maxzoom</li> <li>transform: dataset's Affine transform</li> <li>height: dataset's height</li> <li>width: dataset's width</li> </ul> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpg\") as src:\n    print(src.dataset)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.transform)\n    print(src.bounds)\n    print(src.colormap)\n\n&gt;&gt; &lt;open DatasetReader name='image.jpeg' mode='r'&gt;\n0\n3\nAffine(1.0, 0.0, 0.0,  0.0, 1.0, 0.0)\n(0, 2000, 2000, 0)\n{}\n</code></pre>"},{"location":"readers/#methods_2","title":"Methods","text":"<ul> <li> <p>read(): Read the entire dataset</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read()\n    assert isinstance(img, ImageData)\n    assert not img.crs\n    assert img.assets == [\"image.jpeg\"]\n    assert img.width == src.dataset.width\n    assert img.height == src.dataset.height\n    assert img.count == src.dataset.count\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read(indexes=1)  # or src.read(indexes=(1,))\n    assert img.count == 1\n    assert img.band_names == [\"b1\"]\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read(expression=\"b1/b2\")\n    assert img.count == 1\n    assert img.band_names == [\"b1/b2\"]\n</code></pre> </li> <li> <p>tile(): Read tile from the image</p> </li> </ul> <p>For ImageReader we are using a custom <code>LocalTileMatrixSet</code> constructed from the dataset width and height. The origin is the Top-Left of the image.</p> <pre><code>```python\nfrom rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.tile(tile_x, tile_y, tile_z, **kwargs)\n    img = src.tile(0, 0, src.maxzoom)\n    assert isinstance(img, ImageData)\n    assert not img.crs\n    assert img.bounds == (0, 256, 256, 0)\n\n    img = src.tile(0, 0, src.minzoom)\n    assert isinstance(img, ImageData)\n    assert img.bounds[0] == 0\n    assert img.bounds[3] == 0\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, indexes=1)\n    assert img.count == 1\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, expression=\"B1/B2\")\n    assert img.count == 1\n```\n</code></pre> <ul> <li> <p>part(): Read an image for a given bounding box (<code>bbox</code>). The origin is the Top-Left of the image.</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.part((left, bottom, right, top), **kwargs)\n    img = src.part((0, 256, 256, 0))  # read the top-left 256x256 square of the image\n    assert isinstance(img, ImageData)\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (0, 256, 256, 0)\n\n# Limit output size\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), max_size=50)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), expression=\"b1/b2\")\n</code></pre> </li> <li> <p>feature(): Read an image for a geojson feature. In the pixel coordinate system.</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"coordinates\": [\n        [\n            [-100.0, -100.0],\n            [1000.0, 100.0],\n            [500.0, 1000.0],\n            [-50.0, 500.0],\n            [-100.0, -100.0],\n        ]\n    ],\n    \"type\": \"Polygon\",\n}\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.part(geojson_feature, **kwargs)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.assets == [\"image.jpeg\"]\n    assert img.bounds == (-100.0, 1000.0, 1000.0, -100.0)  # bbox of the input feature\n\n# Limit output size\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, max_size=100)\n\n# Read high resolution\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, max_size=None)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, expression=\"b1/b2\")\n</code></pre> </li> <li> <p>preview(): Read a preview of a raster</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview()\n    assert isinstance(img, ImageData)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview(indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview(expression=\"b1+2;b1*4\")\n</code></pre> </li> <li> <p>point(): Read the pixel values of a raster for a given <code>x, y</code> coordinates. The origin is the Top-Left of the image.</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import PointData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.point(x, y)\n    pt = src.point(0, 0)  # pixel at the origin\n    assert isinstance(pt, PointData)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    pt = src.point(0,0 , indexes=1)\n    print(pt.data)\n&gt;&gt;&gt; [1]\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    pt = src.point(0, 0, expression=\"b1+2;b1*4\")\n    print(pt.data)\n&gt;&gt;&gt; [3, 4]\n</code></pre> </li> <li> <p>info(): Return simple metadata about the dataset</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import Info\n\nwith ImageReader(\"image.jpeg\") as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.model_dump(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [0, 4000, 4000, 0],\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"nodata_type\": \"Nodata\",\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255],\n        ...\n    },\n    \"driver\": \"GTiff\",\n    \"count\": 1,\n    \"width\": 4000,\n    \"height\": 4000,\n    \"overviews\": [2, 4, 8],\n}\n</code></pre> </li> <li> <p>statistics(): Return image statistics (Min/Max/Stdev)</p> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpeg\") as src:\n    stats = src.statistics()\n    assert isinstance(stats, dict)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...),\n    'b2': BandStatistics(...),\n    'b3': BandStatistics(...)\n}\n\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    \"min\": 1,\n    \"max\": 7872,\n    \"mean\": 2107.524612053134,\n    \"count\": 1045504,\n    \"sum\": 2203425412,\n    \"std\": 2271.0065537857326,\n    \"median\": 2800,\n    \"majority\": 1,\n    \"minority\": 7072,\n    \"unique\": 15,\n    \"histogram\": [\n        [...],\n        [...]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 1045504,\n    \"percentile_98\": 6896,\n    \"percentile_2\": 1\n}\n</code></pre> </li> </ul>"},{"location":"readers/#rio_tilerioxarrayxarrayreader","title":"rio_tiler.io.xarray.XarrayReader","text":"<p>The <code>Reader</code> is designed to work with <code>xarray.DataReader</code> with full geo-reference metadata (CRS) and variables (X,Y)</p> <p>The class is derived from the <code>rio_tiler.io.base.BaseReader</code> class. <pre><code>from rio_tiler.io.xarray import XarrayReader\n\nXarrayReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.xarray.XarrayReader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_3","title":"Attributes","text":"<ul> <li>input (xarray.DataArray): Xarray DataArray</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> </ul>"},{"location":"readers/#properties_3","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>minzoom: dataset minzoom (in TMS)</li> <li>maxzoom: dataset maxzoom (in TMS)</li> <li>transform: dataset's Affine transform</li> <li>height: dataset's height</li> <li>width: dataset's width</li> <li>band_names: list of dataArray dims</li> </ul> <pre><code>import numpy\nimport xarray\nfrom datetime import datetime\nfrom rio_tiler.io.xarray import XarrayReader\n\narr = numpy.random.randn(1, 33, 35)\ndata = xarray.DataArray(\n    arr,\n    dims=(\"time\", \"y\", \"x\"),\n    coords={\n        \"x\": list(range(-170, 180, 10)),\n        \"y\": list(range(-80, 85, 5)),\n        \"time\": [datetime(2022, 1, 1)],\n    },\n)\ndata.attrs.update({\"valid_min\": arr.min(), \"valid_max\": arr.max()})\ndata.rio.write_crs(\"epsg:4326\", inplace=True)\n\nwith XarrayReader(data) as src:\n    print(src.input)\n    print(src.tms.identifier)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.bounds)\n    print(src.crs)\n\n&gt;&gt; &lt;xarray.DataArray (time: 1, y: 33, x: 35)&gt;\nWebMercatorQuad\n0\n0\n(-175.0, -82.5, 175.0, 82.5)\nEPSG:4326\n</code></pre>"},{"location":"readers/#methods_3","title":"Methods","text":"<ul> <li> <p>tile(): Read map tile from a raster</p> <pre><code>from rio_tiler.constants import WEB_MERCATOR_CRS\nfrom rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    # src.tile(tile_x, tile_y, tile_z, tilesize, reproject_method, auto_expand, nodata)\n    img = src.tile(1, 2, 3)\n    assert isinstance(img, ImageData)\n    assert img.crs == WEB_MERCATOR_CRS\n</code></pre> </li> <li> <p>part(): Read a DataArray for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</p> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    # src.part((minx, miny, maxx, maxy), dst_crs, bounds_crs, reproject_method, auto_expand, nodata, max_size, height, width, resampling_method)\n    img = src.part((10, 10, 20, 20))\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.bounds == (10, 10, 20, 20)\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith XarrayReader(data) as src:\n    img = src.part((10, 10, 20, 20), dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n</code></pre> </li> <li> <p>feature(): Read a DataArray for a geojson feature. By default the feature is considered to be in WGS84.</p> <pre><code>from rio_tiler.constants import WGS84_CRS\nfrom rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-54.45, 73.05],\n                [-55.05, 72.79],\n                [-55.61, 72.46],\n                [-53.83, 72.36],\n                [-54.45, 73.05],\n            ]\n        ],\n    },\n}\n\nwith XarrayReader(data) as src:\n    # src.part(geojson_feature, dst_crs, shape_crs, auto_expand, nodata, max_size, height, width, resampling_method)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.bounds == (-55.61, 72.36, -53.83, 73.05)  # bbox of the input feature\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith XarrayReader(data) as src:\n    img = src.feature(feat, dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n</code></pre> </li> <li> <p>point(): Read the pixel values of a DataArray for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</p> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import PointData\n\nwith XarrayReader(data) as src:\n    # src.point(lon, lat, coord_crs)\n    pt = src.point(-100, 25)\n    assert isinstance(pt, PointData)\n</code></pre> </li> <li> <p>info(): Return simple metadata about the DataArray</p> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import Info\n\nwith XarrayReader(data) as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [-175.0, -82.5, 175.0, 82.5],\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/4326\"\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"2022-01-01T00:00:00.000000000\"]],\n    \"dtype\": \"float64\",\n    \"nodata_type\": \"None\",\n    \"width\": 35,\n    \"attrs\": {\n        \"valid_min\": -3.148671506292848,\n        \"valid_max\": 4.214148915352746\n    },\n    \"count\": 1,\n    \"height\": 33\n}\n</code></pre> </li> <li> <p>preview(): Return low-resolution representation of the DataArray</p> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    # src.preview(dst_crs, reproject_method, nodata, max_size, height, width, resampling_method)\n    img = src.preview()\n    assert isinstance(img, ImageData)\n    assert img.crs == data.rio.crs\n    assert img.bounds == data.rio.bounds()\n\nwith XarrayReader(data) as src:\n    img = src.preview(WGS84_CRS, max_size=100)\n    assert img.crs == WGS84_CRS\n</code></pre> <p>Warnings</p> <p>This method will read the whole DataArray into memory</p> </li> <li> <p>statistics(): Return DataArray statistics (Min/Max/Stdev)</p> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    stats = src.statistics()\n    assert isinstance(stats, dict)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...),\n}\n\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    \"min\": 1,\n    \"max\": 7872,\n    \"mean\": 2107.524612053134,\n    \"count\": 1045504,\n    \"sum\": 2203425412,\n    \"std\": 2271.0065537857326,\n    \"median\": 2800,\n    \"majority\": 1,\n    \"minority\": 7072,\n    \"unique\": 15,\n    \"histogram\": [\n        [...],\n        [...]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 1045504,\n    \"percentile_98\": 6896,\n    \"percentile_2\": 1\n}\n</code></pre> <p>Warnings</p> <p>This method will read the whole DataArray into memory</p> </li> </ul>"},{"location":"release-notes/","title":"Unreleased","text":""},{"location":"release-notes/#800","title":"8.0.0","text":"<ul> <li> <p>remove python 3.9 and 3.10 support breaking change</p> </li> <li> <p>add band_descriptions in ImageData and PointData objects</p> </li> </ul> <pre><code>with Reader(\"tests/fixtures/cog_tags.tif\") as src:\n    info = src.info()\n    img = src.preview()\n\n    print(info.band_descriptions)\n    &gt;&gt; [('b1', 'Green')]\n\n    print(img.band_names)\n    &gt;&gt; ['b1']\n\n    print(img.band_descriptions)\n    &gt;&gt; [('b1', 'Green')]\n</code></pre> <ul> <li>use <code>b{idx}</code> as band names in <code>XarrayReader</code> result (instead of band descriptions) breaking change</li> </ul> <pre><code>    arr = numpy.arange(0.0, 33 * 35 * 2, dtype=\"float32\").reshape(2, 33, 35)\n    data = xarray.DataArray(\n        arr,\n        dims=(\"time\", \"y\", \"x\"),\n        coords={\n            \"x\": numpy.arange(-170, 180, 10),\n            \"y\": numpy.arange(-80, 85, 5),\n            \"time\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\n        },\n    )\n    data.attrs.update({\"valid_min\": arr.min(), \"valid_max\": arr.max()})\n    data.rio.write_crs(\"epsg:4326\", inplace=True)\n\n    # Before\n    with XarrayReader(data) as dst:\n        assert info.band_metadata == [(\"b1\", {}), (\"b2\", {})]\n        assert info.band_descriptions == [\n            (\"b1\", \"2022-01-01T00:00:00.000000000\"),\n            (\"b2\", \"2022-01-02T00:00:00.000000000\"),\n        ]\n\n        stats = dst.statistics()\n        assert list(stats) == [\n            \"2022-01-01T00:00:00.000000000\",\n            \"2022-01-02T00:00:00.000000000\",\n        ]\n\n        img = dst.tile(0, 0, 0)\n        assert img.band_names == [\n            \"2022-01-01T00:00:00.000000000\",\n            \"2022-01-02T00:00:00.000000000\",\n        ]\n\n    # Now\n    with XarrayReader(data) as dst:\n        stats = dst.statistics()\n        assert list(stats) == [\n            \"b1\",\n            \"b2\",\n        ]\n\n        img = dst.tile(0, 0, 0)\n        assert img.band_names == [\n            \"b1\",\n            \"b2\",\n        ]\n        assert img.band_descriptions == [\n            \"2022-01-01T00:00:00.000000000\",\n            \"2022-01-02T00:00:00.000000000\",\n        ]\n</code></pre> <ul> <li> <p>rename <code>XarrayReader.band_names</code> -&gt; <code>XarrayReader.band_descriptions</code> breaking change</p> </li> <li> <p>only cast data to <code>uint8</code> if colormap values are of type <code>uint8</code></p> </li> <li> <p>add <code>alpha_mask</code> attribute to <code>ImageData</code> class</p> </li> <li> <p>allow partial alpha values from alpha band</p> </li> <li> <p>better handle non-uint8 alpha band</p> </li> <li> <p>remove deprecated <code>force_binary_mask</code> option in <code>reader.read</code> function  breaking change</p> </li> <li> <p>add <code>nodata</code>, <code>scales</code> and <code>offsets</code> attributes to <code>ImageData</code> and <code>PointData</code> classes</p> </li> <li> <p>add <code>rio_tiler.experimental.zarr.ZarrReader</code> Zarr Dataset experimental reader</p> </li> <li> <p>refactor <code>XarrayReader.part</code> method to better handle reprojection and re-usability</p> </li> <li>move <code>_get_width_height</code> and <code>_missing_size</code> from <code>rio_tiler.reader</code> to <code>rio_tiler.utils</code></li> <li>add upper memory limit for Xarray dataset. Controled with <code>RIO_TILER_MAX_ARRAY_SIZE</code> env variable.</li> </ul>"},{"location":"release-notes/#792-2025-10-09","title":"7.9.2 (2025-10-09)","text":"<ul> <li>fix: bad code logic in XarrayReader</li> </ul>"},{"location":"release-notes/#791-2025-10-09","title":"7.9.1 (2025-10-09)","text":"<ul> <li>fix: better handler inverted (SouthUp) dataset in XarrayReader</li> </ul>"},{"location":"release-notes/#790-2025-10-07","title":"7.9.0 (2025-10-07)","text":"<ul> <li>refactor XarrayReader.part method to better handle reprojection and re-usability (cogeotiff/rio-tiler!828) Backported</li> <li>move <code>_get_width_height</code> and <code>_missing_size</code> from <code>rio_tiler.reader</code> to <code>rio_tiler.utils</code> Backported</li> </ul>"},{"location":"release-notes/#781-2025-06-16","title":"7.8.1 (2025-06-16)","text":"<ul> <li>apply scale/offset to dataset statistics in ImageData object (used for automatic rescaling)</li> </ul>"},{"location":"release-notes/#780-2025-06-03","title":"7.8.0 (2025-06-03)","text":"<ul> <li>add <code>to_raster()</code> method to <code>ImageData</code> class</li> </ul>"},{"location":"release-notes/#774-2025-05-29","title":"7.7.4 (2025-05-29)","text":"<ul> <li>fix band names for Xarray DataArray</li> </ul>"},{"location":"release-notes/#773post1-2025-05-22","title":"7.7.3.post1 (2025-05-22)","text":"<ul> <li>remove unwanted breaking change</li> </ul>"},{"location":"release-notes/#773-2025-05-22-yanked","title":"7.7.3 (2025-05-22) YANKED","text":"<ul> <li>fix Boundless <code>part</code> read when using GCPs dataset</li> </ul>"},{"location":"release-notes/#772-2025-05-15","title":"7.7.2 (2025-05-15)","text":"<ul> <li>add <code>repr</code> method to Mosaic Method classes</li> <li> <p>add metadata (pixel selection method, assets count, asset used count) on Image/Point object returned by <code>mosaic_reader</code></p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\n\ndef tiler(src_path: str, *args, **kwargs):\n    with Reader(src_path) as src:\n        return src.tile(*args, **kwargs)\n\nmosaic_assets = [\"tests/fixtures/mosaic_value_1.tif\", \"tests/fixtures/mosaic_value_1.tif\", \"tests/fixtures/mosaic_value_2.tif\"]\nx = 150\ny = 182\nz = 9\n\n# Use Default First value method\nimg, _ = mosaic_reader(mosaic_assets, tiler, x, y, z)\nprint(img.metadata)\n&gt;&gt; {'mosaic_method': 'FirstMethod', 'mosaic_assets_count': 3, 'mosaic_assets_used': 1}\n</code></pre> </li> </ul>"},{"location":"release-notes/#771-2025-05-13","title":"7.7.1 (2025-05-13)","text":"<ul> <li>add <code>max</code>, <code>min</code>, <code>med</code>, <code>q1</code> and <code>q3</code> resampling methods to <code>WarpResampling</code> literal</li> </ul>"},{"location":"release-notes/#770-2025-05-05","title":"7.7.0 (2025-05-05)","text":"<ul> <li>fix size estimation when using <code>window</code> an <code>reader.read</code> method</li> <li>add <code>width</code> or <code>height</code> estimation when passing only one size</li> </ul>"},{"location":"release-notes/#761-2025-04-22","title":"7.6.1 (2025-04-22)","text":"<ul> <li>fix Xarray indexes check when passing a list</li> </ul>"},{"location":"release-notes/#760-2025-03-31","title":"7.6.0 (2025-03-31)","text":"<ul> <li> <p>add <code>interpolate=True/False</code> to <code>.point()</code> methods to allow interpolation of surrounding pixels</p> <pre><code>with Reader(\"tests/fixtures/cog.tif\") as src:\n    pt = src.point(-57.566, 73.68856)\n    print(pt.data[0])\n    &gt;&gt; 2800\n\n    pt = src.point(-57.566, 73.68856, interpolate=True, resampling_method=\"bilinear\")\n    print(pt.data[0])\n    &gt;&gt; 2819\n</code></pre> </li> <li> <p>add <code>pixel_location</code> property to <code>PointData</code> model</p> <pre><code>with Reader(\"tests/fixtures/cog.tif\") as src:\n    pt = src.point(-57.566, 73.68856)\n    print(pt.pixel_location)\n    &gt;&gt; (1090, 1086)\n\nwith Reader(\"tests/fixtures/cog.tif\") as src:\n    pt = src.point(-57.566, 73.68856, interpolate=True)\n    print(pt.pixel_location)\n    &gt;&gt; (1090.5924744641266, 1086.2541429827688)\n</code></pre> </li> <li> <p>add <code>out_dtype</code> to reader's methods to allow user setting the output data type</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"tests/fixtures/cog.tif\") as src:\n    img = src.preview()\n    print(img.array.dtype)\n    &gt;&gt; uint16\n\n    img = src.preview(out_dtype=\"float32\")\n    print(img.array.dtype)\n    &gt;&gt; float32\n</code></pre> </li> <li> <p>update pystac dependency to <code>&gt;=1.9,&lt;2.0</code></p> </li> </ul>"},{"location":"release-notes/#751-2025-03-19","title":"7.5.1 (2025-03-19)","text":"<ul> <li>fix <code>utils.get_array_statistics</code> method to avoid <code>ZeroDivisionError</code> when there is no valid pixel</li> <li>use <code>GDAL_MEM_ENABLE_OPEN=TRUE</code> when opening a numpy array with rasterio</li> </ul>"},{"location":"release-notes/#750-2025-02-26","title":"7.5.0 (2025-02-26)","text":"<ul> <li>add <code>rio_tiler.experimental</code> submodule</li> <li>add <code>rio_tiler.experimental.vsifile.VSIReader</code> VSIFile based experimental reader</li> </ul>"},{"location":"release-notes/#740-2025-01-28","title":"7.4.0 (2025-01-28)","text":"<ul> <li> <p>update rasterio dependency to <code>&gt;=1.4.0</code></p> </li> <li> <p>add <code>reproject</code> method for <code>ImageData</code> objects (author @emmanuelmathot, cogeotiff/rio-tiler!782)</p> <pre><code>from rio_tiler.models import ImageData\n\nimg = ImageData(numpy.zeros((3, 256, 256), crs=CRS.from_epsg(4326), dtype=\"uint8\"))\nimg_3857 = img.reproject(\"epsg:3857\")\n</code></pre> </li> <li> <p>add <code>indexes</code> parameter for <code>XarrayReader</code> methods. As for Rasterio, the indexes values start at <code>1</code>.</p> <pre><code>data = ... # DataArray of shape (2, x, y)\n\n# before\nwith XarrayReader(data) as dst:\n    img = dst.tile(0, 0, 0)\n    assert img.count == 2\n\n# now\nwith XarrayReader(data) as dst:\n    # Select the first `band` within the data array\n    img = dst.tile(0, 0, 0, indexes=1)\n    assert img.count == 1\n</code></pre> </li> <li> <p>better define <code>band names</code> for <code>XarrayReader</code> objects</p> <ul> <li> <p>band_name for <code>2D</code> dataset is extracted form the first <code>non-geo</code> coordinates value</p> <pre><code>data = xarray.DataArray(\n    numpy.arange(0.0, 33 * 35 * 2).reshape(2, 33, 35),\n    dims=(\"time\", \"y\", \"x\"),\n    coords={\n        \"x\": numpy.arange(-170, 180, 10),\n        \"y\": numpy.arange(-80, 85, 5),\n        \"time\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\n    },\n)\nda = data[0]\n\nprint(da.coords[\"time\"].data)\n&gt;&gt; array('2022-01-01T00:00:00.000000000', dtype='datetime64[ns]'))\n\n# before\nwith XarrayReader(data) as dst:\n    img = dst.info()\n    print(img.band_descriptions)[0]\n    &gt;&gt; (\"b1\", \"value\")\n\n# now\nwith XarrayReader(data) as dst:\n    img = dst.info()\n    print(img.band_descriptions)[0]\n    &gt;&gt; (\"b1\", \"2022-01-01T00:00:00.000000000\")\n</code></pre> </li> <li> <p>default <code>band_names</code> is changed to DataArray's name or <code>array</code> (when no available coordinates value)</p> <pre><code>data = ... # DataArray of shape (x, y)\n\n# before\nwith XarrayReader(data) as dst:\n    img = dst.info()\n    print(img.band_descriptions)[0]\n    &gt;&gt; (\"b1\", \"value\")\n\n# now\nwith XarrayReader(data) as dst:\n    img = dst.info()\n    print(img.band_descriptions)[0]\n    &gt;&gt; (\"b1\", \"array\")\n</code></pre> </li> </ul> </li> </ul>"},{"location":"release-notes/#731-2025-01-23","title":"7.3.1 (2025-01-23)","text":"<ul> <li>make sure <code>STACReader.transform</code> is an Affine object</li> </ul>"},{"location":"release-notes/#730-2025-01-07","title":"7.3.0 (2025-01-07)","text":"<ul> <li>drop python 3.8 support</li> <li>add python 3.13 support</li> <li>fix: use coverage array for calculation of valid_percent (author @MarcelCode, cogeotiff/rio-tiler!775)</li> </ul>"},{"location":"release-notes/#722-2024-11-18","title":"7.2.2 (2024-11-18)","text":"<ul> <li>Catch and expand error message when GDAL cannot encode data using specified image driver (cogeotiff/rio-tiler!767)</li> </ul>"},{"location":"release-notes/#721-2024-11-14","title":"7.2.1 (2024-11-14)","text":"<ul> <li>add official support for floating point values in ColorMap</li> <li>cast data to <code>uint8</code> datatype when applying linear colormap</li> </ul>"},{"location":"release-notes/#720-2024-11-05","title":"7.2.0 (2024-11-05)","text":"<ul> <li> <p>Ensure compatibility between XarrayReader and other Readers by adding <code>**kwargs</code> on class methods (cogeotiff/rio-tiler!762)</p> </li> <li> <p>add <code>STACReader.get_asset_list()</code> method to enable easier customization of the asset listing/validation (cogeotiff/rio-tiler!762)</p> </li> </ul>"},{"location":"release-notes/#710-2024-10-29","title":"7.1.0 (2024-10-29)","text":"<ul> <li> <p>Add <code>preview()</code> and <code>statistics()</code> methods to XarrayReader (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Add output size (<code>max_size</code> | <code>width</code>, <code>height</code>) options for XarrayReader's <code>preview()</code>, <code>part()</code> and <code>feature()</code> methods (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Add half X/Y resolution on bounds before checking the geographic bounds in XarrayReader (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Check if the Y bounds are inverted and flip the image on the Y axis in XarrayReader (cogeotiff/rio-tiler!756)</p> </li> <li> <p>Add support for 2D arrays in XarrayReader (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Cast Xarray <code>attrs</code> values in XarrayReader's <code>info()</code> response to avoid JSON encoding issues (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Refactor XarrayReader's <code>feature()</code> method to use the <code>part</code> method (cogeotiff/rio-tiler!755)</p> </li> <li> <p>Allow <code>op</code> parameter for <code>create_cutline</code> and <code>_convert_to_raster_space</code> functions to better control rasterio's <code>rowcol</code> behaviour (author @Martenz, cogeotiff/rio-tiler!759)</p> </li> </ul>"},{"location":"release-notes/#701-2024-10-22","title":"7.0.1 (2024-10-22)","text":"<ul> <li>Add <code>CRS_to_urn</code> method and update internals for <code>CRS_to_uri</code> (author @AndrewAnnex, cogeotiff/rio-tiler!752)</li> </ul>"},{"location":"release-notes/#700-2024-10-21","title":"7.0.0 (2024-10-21)","text":"<ul> <li> <p>Enable dynamic definition of Asset reader in <code>MultiBaseReader</code> (cogeotiff/rio-tiler!711, cogeotiff/rio-tiler!728)</p> </li> <li> <p>Adding <code>default_assets</code> for MultiBaseReader and STACReader (author @mccarthyryanc, cogeotiff/rio-tiler!722)</p> </li> <li> <p>Adding <code>default_bands</code> for MultiBandReader (cogeotiff/rio-tiler!722)</p> </li> <li> <p>Adding support for the STAC <code>Projection</code> extension to derive the <code>bounds</code>, <code>crs</code>, <code>minzoom</code> and <code>maxzoom</code> properties  breaking change</p> </li> <li> <p>Refactor internal function and base classes for the <code>minzoom/maxzoom</code> calculation breaking change</p> </li> <li> <p>Adding <code>transform</code>, <code>height</code> and <code>width</code> attributes (outside init) for <code>SpatialMixin</code> class</p> </li> <li> <p>Moved <code>_dst_geom_in_tms_crs</code> from Reader to <code>SpatialMixin</code> class breaking change</p> </li> <li> <p>Removed use of rasterio's <code>is_tiled</code> method</p> </li> <li> <p>Enable Alternate asset's HREF for STAC by using <code>RIO_TILER_STAC_ALTERNATE_KEY</code> environment variable</p> </li> <li> <p>Adding support for GDAL VRT Connection string for STAC Assets</p> </li> <li> <p>Improve type hint definition</p> </li> <li> <p>make <code>ImageData.rescale</code> and <code>ImageData.apply_color_formula</code> to return <code>self</code></p> </li> <li> <p>add support for <code>.json</code> colormap files</p> </li> <li> <p>do no <code>lowercase</code> colormap name in <code>ColorMaps.get</code> method breaking change</p> <pre><code>from rio_tiler.colormap import cmap\n\n# before\nassert cmap.get(\"Viridis\")\n\n# now\nassert cmap.get(\"Viridis\")\n&gt;&gt; InvalidColorMapName: Invalid colormap name: Viridis\n</code></pre> </li> <li> <p>removed <code>geographic_crs</code> attribute in <code>SpatialMixin</code> class breaking change</p> </li> <li> <p>removed <code>geographic_bounds</code> property in <code>SpatialMixin</code> class breaking change</p> </li> <li> <p>add <code>get_geographic_bounds(crs: CRS)</code> method in <code>SpatialMixin</code> class</p> <pre><code>from rasterio.crs import CRS\nfrom rio_tiler.io import Reader\n\n# before\nwith Reader(\"cog.tif\", geographic_crs=CRS.from_epsg(4326)) as src:\n    bounds = src.geographic_bounds\n\n# now\nwith Reader(\"cog.tif\") as src:\n    bounds = src.get_geographic_bounds(CRS.from_epsg(4326))\n</code></pre> </li> <li> <p>replace <code>geographic bounds</code> with dataset bounds in <code>Reader.info()</code> method's response breaking change</p> <pre><code>from rio_tiler.io import Reader\n\n# before\nwith Reader(\"cog.tif\") as src:\n    assert src.geographic_bounds == src.info().bounds\n\n# now\nwith Reader(\"cog.tif\") as src:\n    assert src.bounds == src.info().bounds\n</code></pre> </li> <li> <p>add <code>crs: str</code> property in <code>Info</code> model</p> </li> <li> <p>remove <code>minzoom</code> and <code>maxzoom</code> properties in <code>Info</code> model breaking change</p> </li> <li> <p>update <code>morecantile</code> dependency to allow <code>6.x</code> version</p> </li> <li> <p>remove deprecated method and attributes</p> </li> <li> <p><code>round</code> xarray dataset's bounds to avoid precision errors when checking for valid geographic bounding box</p> </li> <li> <p>fix <code>bounds</code> type information</p> </li> </ul>"},{"location":"release-notes/#680-2024-10-23","title":"6.8.0 (2024-10-23)","text":"<ul> <li> <p>Enable Alternate asset's HREF for STAC by using <code>RIO_TILER_STAC_ALTERNATE_KEY</code> environment variable [Backported from <code>7.0</code>]</p> </li> <li> <p>Adding support for GDAL VRT Connection string for STAC Assets [Backported from <code>7.0</code>]</p> </li> </ul>"},{"location":"release-notes/#670-2024-09-05","title":"6.7.0 (2024-09-05)","text":"<ul> <li>raise <code>MissingCRS</code> or <code>InvalidGeographicBounds</code> errors when Xarray datasets have wrong geographic metadata</li> <li>better error message for <code>TileOutsideBounds</code> errors (author @abarciauskas-bgse, cogeotiff/rio-tiler!712)</li> <li>handle of inverted latitude in <code>reader.point</code> (author @georgespill, cogeotiff/rio-tiler!716)</li> </ul>"},{"location":"release-notes/#661-2024-05-17","title":"6.6.1 (2024-05-17)","text":"<ul> <li>fix/support <code>scale/offset</code> indexes selection (author @jddeal, cogeotiff/rio-tiler!709)</li> </ul>"},{"location":"release-notes/#660-2024-05-16","title":"6.6.0 (2024-05-16)","text":"<ul> <li>fix type hint for <code>ImageData.band_names</code> (author @n8sty, cogeotiff/rio-tiler!704)</li> <li>enable <code>per-band</code> scale/offset rescaling (co-author @jddeal, cogeotiff/rio-tiler!707)</li> <li> <p>replace <code>scale</code> and <code>offset</code> by <code>scales</code> and <code>offsets</code> in <code>rio_tiler.models.Info</code> model</p> <pre><code># before\nwith Reader(\"tests/fixtures/cog_scale.tif\") as src:\n    info = src.info()\n    print(info.scale, info.offset)\n&gt;&gt; 0.0001 1000.0\n\n# now\nwith Reader(\"tests/fixtures/cog_scale.tif\") as src:\n    info = src.info()\n    print(info.scales, info.offsets)\n&gt;&gt; [0.0001, 0.001] [1000.0, 2000.0]\n</code></pre> </li> </ul>"},{"location":"release-notes/#650-2024-05-03","title":"6.5.0 (2024-05-03)","text":"<ul> <li>Revert #648 and refactor <code>get_vrt_transform</code> method to better handle over-zooming a dataset</li> </ul>"},{"location":"release-notes/#647-2024-04-17","title":"6.4.7 (2024-04-17)","text":"<ul> <li>Better handle dataset with inverted origin</li> <li>make sure datatype is forwarded to the WarpedVRT</li> </ul>"},{"location":"release-notes/#646-2024-04-09","title":"6.4.6 (2024-04-09)","text":"<ul> <li>Ignore STAC statistics object when they contain invalid type (author @emmanuelmathot, cogeotiff/rio-tiler!695)</li> </ul>"},{"location":"release-notes/#645-2024-04-05","title":"6.4.5 (2024-04-05)","text":"<ul> <li>add python 3.12 official support</li> <li>change code formatter to <code>ruff-format</code></li> </ul>"},{"location":"release-notes/#644-2024-04-02","title":"6.4.4 (2024-04-02)","text":"<ul> <li>better handler <code>NaN</code> nodata values for masking (author @cerolinx, cogeotiff/rio-tiler!691)</li> </ul>"},{"location":"release-notes/#643-2024-03-22","title":"6.4.3 (2024-03-22)","text":"<ul> <li>make sure <code>scale</code> and <code>offset</code> are set in <code>Info</code> even when <code>offset=0.</code> or <code>scale=1.0</code> (cogeotiff/rio-tiler!687)</li> </ul>"},{"location":"release-notes/#642-2024-03-22","title":"6.4.2 (2024-03-22)","text":"<ul> <li>better account for coverage in statistics (cogeotiff/rio-tiler!684)</li> </ul>"},{"location":"release-notes/#641-2024-02-19","title":"6.4.1 (2024-02-19)","text":"<ul> <li>add <code>CountMethod</code> mosaic method (author @mccarthyryanc, cogeotiff/rio-tiler!676)</li> </ul>"},{"location":"release-notes/#640-2024-01-24","title":"6.4.0 (2024-01-24)","text":"<ul> <li> <p>deprecate <code>resampling_method</code> in <code>rio_tiler.io.xarray.XarrayReader</code> method and add <code>reproject_method</code> (to match the <code>rio_tiler.io.Reader</code> options)</p> <pre><code># before\nwith XarrayReader(data) as dst:\n    img = dst.tile(0, 0, 1, resampling_method=\"cubic\")\n\n# now\nwith XarrayReader(data) as dst:\n    img_cubic = dst.tile(0, 0, 1, reproject_method=\"cubic\")\n</code></pre> </li> </ul>"},{"location":"release-notes/#631-2024-01-22","title":"6.3.1 (2024-01-22)","text":"<ul> <li>When overriding nodata, do not mix mask and only use the provided nodata value</li> </ul>"},{"location":"release-notes/#630-2024-01-16","title":"6.3.0 (2024-01-16)","text":"<ul> <li> <p>do not use <code>warpedVRT</code> when overwriting the dataset nodata value</p> </li> <li> <p>add <code>align_bounds_with_dataset</code> option in <code>rio_tiler.reader.part</code> to align input bounds with the dataset resolution</p> <p></p> </li> </ul>"},{"location":"release-notes/#6210-2024-01-08","title":"6.2.10 (2024-01-08)","text":"<ul> <li>remove default Endpoint URL in AWS S3 Client for STAC Reader</li> </ul>"},{"location":"release-notes/#629-2023-12-21","title":"6.2.9 (2023-12-21)","text":"<ul> <li>fix AWS endpoint credential for STAC <code>fetch</code> function, using same defaults as GDAL vsis3 configuration</li> </ul>"},{"location":"release-notes/#628-2023-12-11","title":"6.2.8 (2023-12-11)","text":"<ul> <li>apply <code>discrete</code> colormap when the provided colormap does not have 256 values</li> </ul>"},{"location":"release-notes/#627-2023-11-29","title":"6.2.7 (2023-11-29)","text":"<ul> <li>Adjusting dataset latitude for WarpedVRT parameters calculation when EPSG:4326 dataset latitudes overflows EPSG:3857 min/max latitude (cogeotiff/rio-tiler!660)</li> </ul>"},{"location":"release-notes/#626-2023-11-10","title":"6.2.6 (2023-11-10)","text":"<ul> <li>validate <code>shape</code> in <code>ImageData.get_coverage_array</code> to avoid rasterio error when re-projecting the geometry</li> </ul>"},{"location":"release-notes/#625-2023-11-06","title":"6.2.5 (2023-11-06)","text":"<ul> <li>avoid <code>indexes</code> collision in <code>MultiBaseReader</code></li> </ul>"},{"location":"release-notes/#624-2023-10-19","title":"6.2.4 (2023-10-19)","text":"<ul> <li> <p>fix issue with <code>WarpedVRT</code> when doing re-projection (ref: cogeotiff/rio-tiler!648)</p> </li> <li> <p>move benchmark outside pytest suite</p> </li> <li> <p>add GET/HEAD request tests using tilebench (outside pytest suite) (ref: cogeotiff/rio-tiler!649)</p> </li> </ul>"},{"location":"release-notes/#623post1-2023-11-16","title":"6.2.3.post1 (2023-11-16)","text":"<ul> <li>validate <code>shape</code> in <code>ImageData.get_coverage_array</code> to avoid rasterio error when re-projecting the geometry [Backported from 6.2.6]</li> <li>avoid <code>indexes</code> collision in <code>MultiBaseReader</code> [Backported from 6.2.5]</li> </ul> <p>This release was made while we waited on a fix for cogeotiff/rio-tiler#654</p>"},{"location":"release-notes/#623-2023-10-11","title":"6.2.3 (2023-10-11)","text":"<ul> <li>in <code>STACReader</code> use <code>href</code> if <code>get_absolute_href()</code> returns <code>None</code></li> </ul>"},{"location":"release-notes/#622-2023-10-05","title":"6.2.2 (2023-10-05)","text":"<ul> <li>add list of assets in <code>InvalidAssetName</code> message in <code>STACReader</code></li> </ul>"},{"location":"release-notes/#621-2023-09-28","title":"6.2.1 (2023-09-28)","text":"<ul> <li>allow GeoJSON <code>Feature</code> in <code>ImageData.get_coverage_array</code> method</li> </ul>"},{"location":"release-notes/#620-2023-09-27","title":"6.2.0 (2023-09-27)","text":"<ul> <li> <p>allow area-weighted statistics by adding <code>coverage</code> option in <code>rio_tiler.utils.get_array_statistics</code></p> <pre><code># Data Array\n# 1, 2\n# 3, 4\ndata = numpy.ma.array((1, 2, 3, 4)).reshape((1, 2, 2))\n\n# Coverage Array\n# 0.5, 0\n# 1, 0.25\ncoverage = numpy.array((0.5, 0, 1, 0.25)).reshape((2, 2))\n\nstats = utils.get_array_statistics(data, coverage=coverage)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert stats[0][\"mean\"] == 1.125  # (1 * 0.5 + 2 * 0.0 + 3 * 1.0 + 4 * 0.25) / 4\nassert stats[0][\"count\"] == 1.75  # (0.5 + 0 + 1 + 0.25) sum of the coverage array\n\nstats = utils.get_array_statistics(data)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert stats[0][\"mean\"] == 2.5\nassert stats[0][\"count\"] == 4\n</code></pre> </li> <li> <p>add <code>rio_tiler.utils.get_coverage_array</code> method to create a <code>coverage %</code> array</p> </li> <li> <p>add <code>cmocean</code> colormaps</p> <p></p> </li> <li> <p>allow uppercase in <code>cmap.get</code> method</p> <pre><code>from rio_tiler.colormap import cmap\n\n# Before\ncm = cmap.get(\"greys\")\n\n# Now\ncm = cmap.get(\"Greys\")\n</code></pre> </li> </ul>"},{"location":"release-notes/#610-2023-09-15","title":"6.1.0 (2023-09-15)","text":"<ul> <li>add <code>width</code>, <code>height</code> and <code>count</code> properties in <code>MosaicMethodBase</code></li> <li>make sure we mosaic ImageData/PointData with same number of bands</li> <li>resize <code>ImageData.array</code> to the first asset's width/height in <code>mosaic_reader</code></li> </ul>"},{"location":"release-notes/#603-2023-09-13","title":"6.0.3 (2023-09-13)","text":"<ul> <li>return a 1x1 image when bbox is smaller than a single pixel (author @JackDunnNZ, cogeotiff/rio-tiler!637)</li> </ul>"},{"location":"release-notes/#602-2023-08-21","title":"6.0.2 (2023-08-21)","text":"<ul> <li>Update <code>data_as_image</code> to return masked values (author @JackDunnNZ, cogeotiff/rio-tiler!635)</li> </ul>"},{"location":"release-notes/#601-2023-07-25","title":"6.0.1 (2023-07-25)","text":"<ul> <li>fix <code>key</code> access for <code>Info</code> and <code>BandStatistics</code> models for <code>extra</code> attributes</li> <li>update deprecation notice to <code>7.0</code></li> </ul>"},{"location":"release-notes/#600-2023-07-25","title":"6.0.0 (2023-07-25)","text":"<ul> <li>update <code>morecantile</code> requirement to <code>&gt;=5.0,&lt;6.0</code></li> <li>delete <code>rio_tiler.models.NodataTypes</code> (replaced with Literal within the <code>Info</code> model)</li> </ul>"},{"location":"release-notes/#503-2023-07-18","title":"5.0.3 (2023-07-18)","text":"<ul> <li>Filter useless <code>NotGeoreferencedWarning</code> warnings in  <code>Reader.feature()</code> and <code>ImageData.from_bytes()</code> methods</li> <li>Ensure that dataset is still open when reading tags (author @JackDunnNZ, cogeotiff/rio-tiler!628)</li> </ul>"},{"location":"release-notes/#502-2023-07-11","title":"5.0.2 (2023-07-11)","text":"<ul> <li>fix <code>ImageData.apply_color_formula()</code> method</li> </ul>"},{"location":"release-notes/#501-2023-06-22","title":"5.0.1 (2023-06-22)","text":"<ul> <li>raise <code>InvalidExpression</code> when passing invalid <code>asset</code> or <code>band</code> in an expression</li> </ul>"},{"location":"release-notes/#500-2023-06-01","title":"5.0.0 (2023-06-01)","text":"<ul> <li> <p>Fix potential issue when getting statistics for non-valid data</p> </li> <li> <p>add <code>rio-tiler.mosaic.methods.PixelSelectionMethod</code> enums with all defaults methods</p> </li> <li> <p>Add <code>rio-tiler.utils._validate_shape_input</code> function to check geojson feature inputs</p> </li> <li> <p>Change cutline handling in the <code>rio-tiler.io.rasterio.Reader.feature</code> method. Feature   cutlines are now rasterized into numpy arrays and applied as masks instead of using   the cutline vrt_option. These masks are tracked in the <code>rio-tiler.models.ImageData.cutline_mask</code>   attribute, which are used in <code>rio-tiler.mosaic.methods.base.MosaicMethodBase</code> to stop   mosaic building as soon as all pixels in a feature are populated</p> </li> <li> <p>Fix missing <code>nodata/alpha/mask</code> forwarding for dataset with internal GCPS</p> </li> <li> <p>in <code>rio_tiler.io.XarrayReader</code>, add <code>auto_expand</code> options to avoid returning 1D array (incompatible with rio-tiler) (author @abarciauskas-bgse, cogeotiff/rio-tiler!608)</p> </li> <li> <p>handle internal and user provided <code>nodata</code> values in <code>rio_tiler.io.XarrayReader</code> to create mask</p> </li> <li> <p>add <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>, <code>AWS_PROFILE</code> and <code>AWS_REGION</code> environnement overrides for <code>rio_tiler.io.stac.aws_get_object</code> function</p> </li> </ul> <p>breaking changes</p> <ul> <li> <p>remove support for non-binary mask values (e.g non-binary alpha bands, ref: rasterio/rasterio#1721)</p> </li> <li> <p>switch from PER-DATASET to PER-BAND mask (cogeotiff/rio-tiler!580)</p> <pre><code># before\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert img.data.shape == (3, 128, 128)\n    assert img.mask.shape == (128, 128)\n\n# now\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n    assert img.array.data.shape == (3, 128, 128)\n    assert img.array.mask.shape == (3, 128, 128))\n</code></pre> </li> <li> <p>use numpy masked array in ImageData and PointData to store the data</p> <pre><code># before\narr = numpy.zeros((1, 256, 256), dtype=\"uint16\")\nimg = ImageData(arr)\nassert isintance(img.data, numpy.ndarray)  # Attribute\n\n# now\narr = numpy.zeros((1, 256, 256), dtype=\"uint16\")\nimg = ImageData(arr)\nassert isintance(img.array, numpy.ma.MaskedArray)  # Attribute\nassert isintance(img.data, numpy.ndarray)  # property\nassert isintance(img.mask, numpy.ndarray)  # property\n</code></pre> </li> <li> <p>remove <code>ImageData.from_array</code> method (because we now support MaskedArray directly)</p> </li> <li> <p><code>rio_tiler.expression.apply_expression</code> input/output type change to <code>numpy.ma.MaskedArray</code></p> </li> <li> <p>rio-tiler <code>mosaic</code> methods return <code>numpy.ma.MaskedArray</code></p> </li> <li> <p>reader's <code>post_process</code> should be a Callable with <code>numpy.ma.MaskedArray</code> input/output</p> </li> <li> <p>add <code>reproject_method</code> option in <code>rio_tiler.reader</code>'s method to select the <code>resampling</code> method used during reprojection</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"bilinear\",  # use `bilinear` for both resizing and reprojection\n    )\n\n# now\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"cubic\",  # use `cubic` for resizing\n        reproject_method=\"bilinear\",  # use `bilinear` for reprojection\n    )\n</code></pre> </li> <li> <p>refactored the <code>MosaicMethodBase</code> to use python's dataclass</p> </li> <li> <p>changed variable names in <code>MosaicMethodBase</code> (<code>tile</code> -&gt; <code>mosaic</code>)</p> </li> <li> <p><code>rio_tiler.mosaic.methods.defaults.LastBandHigh</code> renamed <code>LastBandHighMethod</code></p> </li> <li> <p><code>rio_tiler.mosaic.methods.defaults.LastBandLow</code> renamed <code>LastBandLowMethod</code></p> </li> <li> <p>move <code>aws_get_object</code> from <code>rio_tiler.utils</code> to <code>rio_tiler.io.stac</code></p> </li> <li> <p>make <code>boto3</code> an optional dependency (<code>python -m pip install rio-tiler[\"s3\"]</code>)</p> </li> <li> <p>update <code>morecantile</code> dependency to <code>&gt;=4.0</code></p> </li> <li> <p>add <code>metadata</code> in ImageData/PointData from rasterio dataset <code>tags</code></p> </li> <li> <p>forward statistics from the raster STAC extension to the ImageData object</p> <pre><code>with STACReader(STAC_RASTER_PATH) as stac:\n    info = stac._get_asset_info(\"green\")\n    assert info[\"dataset_statistics\"] == [(6883, 62785)]\n    assert info[\"metadata\"]\n    assert \"raster:bands\" in info[\"metadata\"]\n\n    img = stac.preview(assets=(\"green\", \"red\"))\n    assert img.dataset_statistics == [(6883, 62785), (6101, 65035)]\n    assert img.metadata[\"green\"]  # extra_fields from the STAC assets (e.g `\"raster:bands\"`)\n    assert img.metadata[\"red\"]\n</code></pre> </li> <li> <p>add Deprecation warning for <code>ImageData.from_array</code>, <code>ImageData.as_masked</code>, <code>PointData.as_masked</code> methods</p> </li> </ul>"},{"location":"release-notes/#4113-2023-06-22","title":"4.1.13 (2023-06-22)","text":"<ul> <li>raise InvalidExpression when passing invalid asset or band in an expression (Backported from 5.0.1)</li> </ul>"},{"location":"release-notes/#4112-2023-06-16","title":"4.1.12 (2023-06-16)","text":"<ul> <li>fix issue with <code>rio_tiler.utils.get_array_statistics</code> when passing data with no <code>valid</code> value</li> </ul>"},{"location":"release-notes/#4111-2023-05-18","title":"4.1.11 (2023-05-18)","text":"<ul> <li>in <code>rio_tiler.io.XarrayReader</code>, add <code>auto_expand</code> options to avoid returning 1D array (incompatible with rio-tiler) (author @abarciauskas-bgse, cogeotiff/rio-tiler!608)</li> </ul>"},{"location":"release-notes/#4110-2023-03-24","title":"4.1.10 (2023-03-24)","text":"<ul> <li>enable <code>boundless</code> geometry for cutline (author @yellowcap, cogeotiff/rio-tiler!586)</li> </ul>"},{"location":"release-notes/#419-2023-02-28","title":"4.1.9 (2023-02-28)","text":"<ul> <li>Automatically expand 2D numpy array to 3D when creating ImageData</li> </ul>"},{"location":"release-notes/#418-2023-02-15","title":"4.1.8 (2023-02-15)","text":"<ul> <li>Fix dtype issue when working with Mosaics Methods. Mask should always been of type <code>Uint8</code>.</li> <li>Fix <code>ImageData.from_array</code> method when working with Masked array</li> </ul>"},{"location":"release-notes/#417-2023-02-07","title":"4.1.7 (2023-02-07)","text":"<ul> <li>add <code>from_array</code> and <code>from_bytes</code> ImageData creation methods</li> <li>add <code>statistics</code> method to ImageData</li> </ul>"},{"location":"release-notes/#416-2023-01-18","title":"4.1.6 (2023-01-18)","text":"<ul> <li>add <code>apply_colormap</code> method to the ImageData class</li> <li>fix potential datatype overflow when calculating the intersection of mask and alpha band when using Colormap</li> </ul>"},{"location":"release-notes/#415-2022-12-20","title":"4.1.5 (2022-12-20)","text":"<ul> <li>Fix inverted col/row check when doing window read of a non WarpedVRT dataset</li> </ul>"},{"location":"release-notes/#414-2022-12-16","title":"4.1.4 (2022-12-16)","text":"<ul> <li>add <code>rio_tiler.mosaic.mosaic_point_reader</code> function to create Point value from multiple observation     <pre><code>def reader(asset: str, *args, **kwargs) -&gt; PointData:\n    with Reader(asset) as src:\n        return src.point(*args, **kwargs)\n\npt: PointData = mosaic_point_reader([\"cog.tif\", \"cog2.tif\"], reader, 0, 0)\n</code></pre></li> </ul>"},{"location":"release-notes/#413-2022-12-15","title":"4.1.3 (2022-12-15)","text":"<ul> <li>fix invalid definition of <code>PointData.mask</code> when mask is not provided. Makes sure it's a one element array.</li> </ul>"},{"location":"release-notes/#412-2022-12-15","title":"4.1.2 (2022-12-15)","text":"<ul> <li>raise <code>InvalidPointDataError</code> error when trying to create PointData from an empty list in <code>PointData.create_from_list</code></li> </ul>"},{"location":"release-notes/#411-2022-12-12","title":"4.1.1 (2022-12-12)","text":"<ul> <li>fix invalid coordinates slicing for <code>XArrayReader.point()</code> method (author @benjaminleighton, cogeotiff/rio-tiler!559)</li> </ul>"},{"location":"release-notes/#410-2022-11-24","title":"4.1.0 (2022-11-24)","text":"<ul> <li>add <code>asset_as_band</code> option in <code>MultiBaseReader</code> tile, part, preview, feature and point methods</li> </ul> <pre><code>with STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, assets=\"green\")\n    assert img.band_names == [\"green_b1\"]\n\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, assets=\"green\", asset_as_band=True)\n    assert img.band_names == [\"green\"]\n\n# For expression, without `asset_as_band` tag, users have to pass `_b{n}` suffix to indicate the band index\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green_b1/red_b1\")\n    assert img.band_names == [\"green_b1/red_b1\"]\n\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green/red\", asset_as_band=True)\n    assert img.band_names == [\"green/red\"]\n</code></pre>"},{"location":"release-notes/#400-2022-11-21","title":"4.0.0 (2022-11-21)","text":"<ul> <li>remove deprecated code</li> <li><code>asset_expression</code> in MultiBaseReader</li> <li><code>GCPCOGReader</code></li> </ul>"},{"location":"release-notes/#400a2-2022-11-15","title":"4.0.0a2 (2022-11-15)","text":"<ul> <li>use of <code>file:header_size</code> extension in <code>STACReader</code> to set <code>GDAL_INGESTED_BYTES_AT_OPEN</code> environment variable</li> </ul> <p>breaking changes</p> <ul> <li>renamed <code>MultiBaseReader._get_asset_url</code> to <code>MultiBaseReader._get_asset_info</code> and change the output to return a dictionary in form of <code>{\"url\": ..., \"env\": ...}</code></li> </ul>"},{"location":"release-notes/#400a1-2022-11-10","title":"4.0.0a1 (2022-11-10)","text":"<ul> <li>assign ColorInterp.alpha to rendered image when we add the mask band</li> <li>add <code>.clip(bbox: BBox)</code> and <code>.resize(height: int, width: int)</code> methods to ImageData object</li> <li>add python 3.11 support</li> <li>replace <code>rio-color</code> by <code>color-operations</code> module</li> </ul>"},{"location":"release-notes/#400a0-2022-10-20","title":"4.0.0a0 (2022-10-20)","text":"<ul> <li>add python 3.10 support</li> <li>add <code>apply_expression</code> method in <code>rio_tiler.models.ImageData</code> class</li> <li>update <code>rio-tiler.reader.read/part</code> to avoid using WarpedVRT when no reprojection or nodata override is needed</li> <li> <p>add <code>rio_tiler.io.rasterio.ImageReader</code> to work either with Non-geo or Geo images in a Non-geo manner (a.k.a: in the pixel coordinates system)     <pre><code>with ImageReader(\"image.jpg\") as src:\n    im = src.part((0, 100, 100, 0))\n\nwith ImageReader(\"image.jpg\") as src:\n    im = src.tile(0, 0, src.maxzoom)\n    print(im.bounds)\n\n&gt;&gt;&gt; BoundingBox(left=0.0, bottom=256.0, right=256.0, top=0.0)\n</code></pre></p> </li> <li> <p>add <code>rio_tiler.io.xarray.XarrayReader</code> to work with <code>xarray.DataArray</code> <pre><code>import xarray\nfrom rio_tiler.io import XarrayReader\n\nwith xarray.open_dataset(\n    \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",\n    engine=\"zarr\",\n    decode_coords=\"all\"\n) as src:\n    ds = src[\"analysed_sst\"][:1]\n    ds.rio.write_crs(\"epsg:4326\", inplace=True)\n\n    with XarrayReader(ds) as dst:\n        img = dst.tile(1, 1, 2)\n</code></pre>     note: <code>xarray</code> and <code>rioxarray</code> optional dependencies are needed for the reader</p> </li> </ul> <p>breaking changes</p> <ul> <li>remove python 3.7 support</li> <li>update rasterio requirement to <code>&gt;=1.3</code> to allow python 3.10 support</li> <li>rename <code>rio_tiler.io.cogeo</code> to <code>rio_tiler.io.rasterio</code></li> <li> <p>rename <code>COGReader</code> to <code>Reader</code>. We added <code>rio_tiler.io.COGReader</code> alias to <code>rio_tiler.io.Reader</code> backwards compatibility     <pre><code># before\nfrom rio_tiler.io import COGReader\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io import Reader\nfrom rio_tiler.io.rasterio import Reader\n</code></pre></p> </li> <li> <p><code>rio_tiler.readers.read()</code>, <code>rio_tiler.readers.part()</code>, <code>rio_tiler.readers.preview()</code> now return a ImageData object</p> </li> <li>remove <code>minzoom</code> and <code>maxzoom</code> attribute in <code>rio_tiler.io.SpatialMixin</code> base class</li> <li>remove <code>minzoom</code> and <code>maxzoom</code> attribute in <code>rio_tiler.io.Reader</code> (now defined as properties)</li> <li> <p>use <code>b</code> prefix for band names in <code>rio_tiler.models.ImageData</code> class (and in rio-tiler's readers)     <pre><code># before\nwith COGReader(\"cog.tif\") as cog:\n    img = cog.read()\n    print(cog.band_names)\n    &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n    print(cog.info().band_metadata)\n    &gt;&gt;&gt; [(\"1\", {}), (\"2\", {}), (\"3\", {})]\n\n    print(cog.info().band_descriptions)\n    &gt;&gt;&gt; [(\"1\", \"\"), (\"2\", \"\"), (\"3\", \"\")]\n\n    print(list(cog.statistics()))\n    &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n# now\nwith Reader(\"cog.tif\") as cog:\n    img = cog.read()\n    print(img.band_names)\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n    print(cog.info().band_metadata)\n    &gt;&gt;&gt; [(\"b1\", {}), (\"b2\", {}), (\"b3\", {})]\n\n    print(cog.info().band_descriptions)\n    &gt;&gt;&gt; [(\"b1\", \"\"), (\"b2\", \"\"), (\"b3\", \"\")]\n\n    print(list(cog.statistics()))\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\nwith STACReader(\"stac.json\") as stac:\n    print(stac.tile(701, 102, 8, assets=(\"green\", \"red\")).band_names)\n    &gt;&gt;&gt; [\"green_b1\", \"red_b1\"]\n</code></pre></p> </li> <li> <p>depreciate <code>asset_expression</code> in MultiBaseReader. Use of expression is now possible</p> </li> <li> <p><code>expression</code> for MultiBaseReader must be in form of <code>{asset}_b{index}</code></p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green/red\")\n\n# now\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green_b1/red_b1\")\n</code></pre> </li> <li> <p><code>rio_tiler.reader.point()</code> (and all Reader's point methods) now return a rio_tiler.models.PointData object</p> <pre><code># before\nwith rasterio.open(\"cog.tif\") as src::\n    v = rio_tiler.reader.point(10.20, -42.0)\n    print(v)\n    &gt;&gt;&gt; [0, 0, 0]\n\nwith COGReader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith rasterio.open(\"cog.tif\") as src::\n    v = rio_tiler.reader.point(src, (10.20, -42))\n    print(v)\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n\nwith Reader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre> </li> <li> <p>deleted <code>rio_tiler.reader.preview</code> function and updated <code>rio_tiler.reader.read</code> to allow width/height/max_size options</p> </li> <li>reordered keyword options in all <code>rio_tiler.reader</code> function for consistency</li> <li>removed <code>AlphaBandWarning</code> warning when automatically excluding alpha band from data</li> <li>remove <code>nodata</code>, <code>unscale</code>, <code>resampling_method</code>, <code>vrt_options</code> and <code>post_process</code> options to <code>Reader</code> init method and replaced with <code>options</code> <pre><code># before\nwith COGReader(\"cog.tif\", nodata=1, resampling_method=\"bilinear\") as cog:\n    data = cog.preview()\n\n# now\nwith Reader(COGEO, options={\"nodata\": 1, \"resampling_method\": \"bilinear\"}) as cog:\n    data = cog.preview()\n</code></pre></li> </ul>"},{"location":"release-notes/#316-2022-07-22","title":"3.1.6 (2022-07-22)","text":"<ul> <li>Hide <code>NotGeoreferencedWarning</code> warnings in <code>utils.render</code> and <code>utils.resize_array</code></li> <li>update <code>MultiBaseReader</code> and <code>MultiBandReader</code> <code>points</code> method to prepare for numpy changes.</li> </ul>"},{"location":"release-notes/#315-2022-07-06","title":"3.1.5 (2022-07-06)","text":"<ul> <li>Deprecate <code>rio_tiler.io.GCPCOGReader</code> and allow GPCS dataset to be opened by <code>rio_tiler.io.COGReader</code></li> </ul> <pre><code># before\nwith GCPCOGReader(\"my.tif\") as cog:\n    ...\n\n# now, COGReader will find the gcps and create an internal WarpedVRT using the gpcs and crs\nwith COGReader(\"my.tif\") as cog:\n    ...\n</code></pre> <ul> <li>add <code>ImageData.rescale</code> to rescale the array in place</li> <li>add <code>ImageData.apply_color_formula</code> to apply color formula in place</li> </ul>"},{"location":"release-notes/#314-2022-04-14","title":"3.1.4 (2022-04-14)","text":"<ul> <li>Fix cutline creation for MultiPolygon (author @Fernigithub, cogeotiff/rio-tiler!493)</li> </ul>"},{"location":"release-notes/#313-2022-04-08","title":"3.1.3 (2022-04-08)","text":"<ul> <li>Switch to <code>pyproject.toml</code> and <code>flit</code> for packaging (cogeotiff/rio-tiler!490)</li> <li>Catch discrete colormap with negative values (cogeotiff/rio-tiler!492)</li> </ul>"},{"location":"release-notes/#312-2022-03-25","title":"3.1.2 (2022-03-25)","text":"<ul> <li>avoid calculating statistics for non-finite values (cogeotiff/rio-tiler!489)</li> </ul>"},{"location":"release-notes/#311-2022-03-17","title":"3.1.1 (2022-03-17)","text":"<ul> <li>forward <code>band names</code> to ImageData output in <code>mosaic_reader</code> (cogeotiff/rio-tiler!486)</li> </ul>"},{"location":"release-notes/#310-2022-02-21","title":"3.1.0 (2022-02-21)","text":"<ul> <li>add support for setting the S3 endpoint url scheme via the <code>AWS_HTTPS</code> environment variables in <code>aws_get_object</code> function using boto3 (cogeotiff/rio-tiler!476)</li> <li>Add semicolon <code>;</code> support for multi-blocks expression (cogeotiff/rio-tiler!479)</li> <li>add <code>rio_tiler.expression.get_expression_blocks</code> method to split expression (cogeotiff/rio-tiler!479)</li> <li>add <code>merged_statistics</code> method for <code>MultiBaseReader</code> to get statistics using between assets expression (cogeotiff/rio-tiler!478)</li> </ul> <p>future deprecation</p> <ul> <li>using a comma <code>,</code> in an expression to define multiple blocks will be replaced by semicolon <code>;</code></li> </ul> <pre><code># before\nexpression = \"b1+b2,b2\"\n\n# new\nexpression = \"b1+b2;b2\"\n</code></pre> <p>breaking changes</p> <ul> <li>update morecantile requirement to <code>&gt;=3.1,&lt;4.0</code>. WebMercatorQuad TMS is now aligned with GDAL and Mercantile TMS definition.</li> </ul>"},{"location":"release-notes/#303-2022-01-18","title":"3.0.3 (2022-01-18)","text":"<ul> <li>make sure we raise an HTTP exception when using an invalid STAC url (cogeotiff/rio-tiler!475)</li> </ul>"},{"location":"release-notes/#302-2022-01-03","title":"3.0.2 (2022-01-03)","text":"<ul> <li>switch from <code>functools.lru_cache</code> to <code>cachetools.LRUCache</code> to allow unashable options in <code>rio_tiler.io.stac.fetch</code> function (cogeotiff/rio-tiler!471)</li> </ul>"},{"location":"release-notes/#301-2021-12-03","title":"3.0.1 (2021-12-03)","text":"<ul> <li>avoid useless call to <code>transform_bounds</code> if input/output CRS are equals (cogeotiff/rio-tiler!466)</li> <li>make sure <code>geographic_bounds</code> don't return inf or nan values (cogeotiff/rio-tiler!467)</li> </ul>"},{"location":"release-notes/#300-2021-11-29","title":"3.0.0 (2021-11-29)","text":"<ul> <li>no change since <code>3.0.0a6</code></li> </ul>"},{"location":"release-notes/#300a6-2021-11-22","title":"3.0.0a6 (2021-11-22)","text":"<ul> <li>add <code>rio_tiler.utils.resize_array</code> to resize array to a given width/height (cogeotiff/rio-tiler!463)</li> <li>use <code>resize_array</code> in <code>ImageData.create_from_list</code> to avoid trying merging array of different sizes (cogeotiff/rio-tiler!463)</li> </ul> <p>breaking changes</p> <ul> <li>update <code>MultiBaseReader</code> and <code>MultiBandReader</code> to be their own abstract classes instead of being subclass of <code>BaseReader</code>.</li> <li>put <code>reader</code> attribute outside of the <code>__init__</code> method for <code>MultiBaseReader</code> and <code>MultiBandReader</code>.</li> </ul>"},{"location":"release-notes/#300a5-2021-11-18","title":"3.0.0a5 (2021-11-18)","text":"<ul> <li>allow the definition of <code>geographic_crs</code> used in the <code>geographic_bounds</code> property (cogeotiff/rio-tiler!458)</li> <li>use <code>contextlib.ExitStack</code> to better manager opening/closing rasterio dataset (cogeotiff/rio-tiler!459)</li> <li>moves <code>BBox, ColorTuple, Indexes, NoData, NumType</code> type definitions in <code>rio_tiler.types</code> (cogeotiff/rio-tiler!460)</li> <li>better types definition for ColorMap objects (cogeotiff/rio-tiler!460)</li> <li>fix some types issues (cogeotiff/rio-tiler!460)</li> </ul>"},{"location":"release-notes/#300a4-2021-11-10","title":"3.0.0a4 (2021-11-10)","text":"<ul> <li>refactor <code>SpatialMixin.tile_exists</code> to compare the bounds in the dataset's coordinate system to avoid coordinates overflow (a TMS CRS bounds can be smaller than the dataset CRS bounds) (cogeotiff/rio-tiler!455)</li> </ul>"},{"location":"release-notes/#300a3-2021-11-03","title":"3.0.0a3 (2021-11-03)","text":"<ul> <li>Reader's <code>info</code> and <code>statistics</code> methods to default to available <code>bands</code> or <code>assets</code> if not provided (cogeotiff/rio-tiler!451)</li> </ul>"},{"location":"release-notes/#300a2-2021-10-21","title":"3.0.0a2 (2021-10-21)","text":"<ul> <li>Allow <code>rio_tiler.utils.get_array_statistics</code> to return <code>0</code> for unfound category, instead of raising an error (cogeotiff/rio-tiler!443)</li> </ul>"},{"location":"release-notes/#300a1-2021-10-20","title":"3.0.0a1 (2021-10-20)","text":"<p>breaking changes</p> <ul> <li> <p>add <code>input</code> in BaseReader class definition to avoid type mismatch (cogeotiff/rio-tiler!450)</p> <p>Note: <code>input</code> replaces <code>filepath</code> attribute in STACReader and COGReader.</p> </li> </ul> <p>removed</p> <ul> <li> <ul> <li><code>rio_tiler.models.ImageStatistics</code> model</li> </ul> </li> </ul>"},{"location":"release-notes/#300a0-2021-10-19","title":"3.0.0a0 (2021-10-19)","text":"<ul> <li>add <code>crs</code> property in <code>rio_tiler.io.base.SpatialMixin</code> (cogeotiff/rio-tiler!429)</li> <li>add <code>geographic_bounds</code> in <code>rio_tiler.io.base.SpatialMixin</code> to return bounds in WGS84 (cogeotiff/rio-tiler!429)</li> </ul> <pre><code>from rio_tiler.io import COGReader\n\nwith COGReader(\"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt; (373185.0, 8019284.949381611, 639014.9492102272, 8286015.0)\n\n    print(cog.crs)\n    &gt;&gt; \"EPSG:32621\"\n\n    print(cog.geographic_bounds)\n    &gt;&gt; (-61.28762442711404, 72.22979795551834, -52.301598718454485, 74.66298001264106)\n</code></pre> <ul> <li>Allow errors to be ignored when trying to find <code>zooms</code> for dataset in <code>rio_tiler.io.COGReader</code>. If we're not able to find the zooms in selected TMS, COGReader will defaults to the min/max zooms of the TMS (cogeotiff/rio-tiler!429)</li> </ul> <pre><code>from pyproj import CRS\nfrom morecantile import TileMatrixSet\n\nfrom rio_tiler.io import COGReader\n\n# For a non-earth dataset there is no available transformation from its own CRS and the default WebMercator TMS CRS.\nwith COGReader(\"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog_nonearth.tif\") as cog:\n    &gt;&gt; UserWarning: Cannot determine min/max zoom based on dataset information, will default to TMS min/max zoom.\n\n    print(cog.minzoom)\n    &gt;&gt; 0\n\n    print(cog.maxzoom)\n    &gt;&gt; 24\n\n# if we use a `compatible TMS` then we don't get warnings\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs,\n    extent=europa_crs.area_of_use.bounds,\n    matrix_scale=[2, 1],\n)\nwith COGReader(\n    \"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog_nonearth.tif\",\n    tms=europa_tms,\n) as cog:\n    print(cog.minzoom)\n    &gt;&gt; 4\n\n    print(cog.maxzoom)\n    &gt;&gt; 6\n</code></pre> <ul> <li>compare dataset bounds and tile bounds in TMS crs in <code>rio_tiler.io.base.SpatialMixin.tile_exists</code> method to allow dataset and TMS not compatible with WGS84 crs (cogeotiff/rio-tiler!429)</li> <li>use <code>httpx</code> package instead of requests (author @rodrigoalmeida94, cogeotiff/rio-tiler!431)</li> <li>allow half pixel <code>tile_buffer</code> around the tile (e.g 0.5 -&gt; 257x257, 1.5 -&gt; 259x259) (author @bstadlbauer, cogeotiff/rio-tiler!405)</li> <li>add support for intervals colormap (cogeotiff/rio-tiler!439))</li> </ul> <pre><code>from rio_tiler.colormap import apply_cmap, apply_intervals_cmap\n\ndata = numpy.random.randint(0, 255, size=(1, 256, 256))\ncmap = [\n    # ([min, max], [r, g, b, a])\n    ([0, 1], [0, 0, 0, 0]),\n    ([1, 10], [255, 255, 255, 255]),\n    ([10, 100], [255, 0, 0, 255]),\n    ([100, 256], [255, 255, 0, 255]),\n]\n\ndata, mask = apply_intervals_cmap(data, cmap)\n# or\ndata, mask = apply_cmap(data, cmap)\n</code></pre> <p>breaking changes</p> <ul> <li>update morecantile requirement to version &gt;=3.0 (cogeotiff/rio-tiler!418)</li> <li>remove python 3.6 support (cogeotiff/rio-tiler!418)</li> <li>remove <code>max_size</code> defaults for <code>COGReader.part</code> and <code>COGReader.feature</code>, which will now default to full resolution reading.</li> </ul> <pre><code># before\nwith COGReader(\"my.tif\") as cog:\n    img = cog.part(*cog.dataset.bounds, dst_crs=cog.dataset.crs, bounds_crs=cog.dataset.crs)\n    # by default image should be max 1024x1024\n    assert max(img.width, 1024) # by default image should be max 1024x1024\n    assert max(img.height, 1024)\n\n# now (there is no more max_size default)\nwith COGReader(\"my.tif\") as cog:\n    img = cog.part(*cog.dataset.bounds, dst_crs=cog.dataset.crs, bounds_crs=cog.dataset.crs)\n    assert img.width == cog.dataset.width\n    assert img.height == cog.dataset.height\n</code></pre> <ul> <li> <p>add <code>.statistics</code> method in base classes (cogeotiff/rio-tiler!427)</p> </li> <li> <p>remove <code>rio_tiler.io.base.SpatialMixin.spatial_info</code> and <code>rio_tiler.io.base.SpatialMixin.center</code> properties (cogeotiff/rio-tiler!429)</p> </li> <li> <p>Reader's <code>.bounds</code> property should now be in dataset's CRS, not in <code>WGS84</code> (cogeotiff/rio-tiler!429)</p> </li> </ul> <pre><code># before\nwith COGReader(\"my.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt;&gt; (-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n\n# now\nwith COGReader(\"my.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt;&gt; (683715.3266400001, 1718548.5702, 684593.2680000002, 1719064.90736)\n\n    print(cog.crs)\n    &gt;&gt;&gt; EPSG:32620\n\n    print(cog.geographic_bounds)\n    &gt;&gt;&gt; (-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n</code></pre> <ul> <li>Use <code>RIO_TILER_MAX_THREADS</code> environment variable instead of <code>MAX_THREADS</code> (author @rodrigoalmeida94, cogeotiff/rio-tiler!432)</li> <li>remove <code>band_expression</code> in <code>rio_tiler.io.base.MultiBandReader</code> (cogeotiff/rio-tiler!433)</li> <li>change <code>asset_expression</code> input type from <code>str</code> to <code>Dict[str, str]</code> in <code>rio_tiler.io.base.MultiBaseReader</code> (cogeotiff/rio-tiler!434)</li> </ul> <pre><code># before\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression=\"b1*2\",  # expression was applied to each asset\n    )\n\n# now\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression={\"data1\": \"b1*2\", \"data2\": \"b2*100\"},  # we can now pass per asset expression\n    )\n</code></pre> <ul> <li>add <code>asset_indexes</code> in <code>rio_tiler.io.base.MultiBaseReader</code>, which replaces <code>indexes</code>. (cogeotiff/rio-tiler!434)</li> </ul> <pre><code># before\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        indexes=(1,),  # indexes was applied to each asset\n    )\n\n# now\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_indexes={\"data1\": 1, \"data2\": 2},  # we can now pass per asset indexes\n    )\n</code></pre> <p>removed</p> <ul> <li><code>rio_tiler.io.BaseReader.metadata</code> and <code>rio_tiler.io.BaseReader.stats</code> base class methods (cogeotiff/rio-tiler!425)</li> <li><code>rio_tiler.reader.stats</code> function (cogeotiff/rio-tiler!440)</li> <li><code>rio_tiler.reader.metadata</code> function (cogeotiff/rio-tiler!440)</li> <li><code>rio_tiler.utils._stats</code> function (cogeotiff/rio-tiler!440)</li> </ul>"},{"location":"release-notes/#213-2021-09-14","title":"2.1.3 (2021-09-14)","text":"<ul> <li>Make sure output data is of type <code>Uint8</code> when applying a colormap (cogeotiff/rio-tiler!423)</li> <li>Do not auto-rescale data if there is a colormap (cogeotiff/rio-tiler!423)</li> </ul>"},{"location":"release-notes/#212-2021-08-10","title":"2.1.2 (2021-08-10)","text":"<ul> <li>update type information for mosaics functions (cogeotiff/rio-tiler!409)</li> </ul>"},{"location":"release-notes/#211-2021-07-29","title":"2.1.1 (2021-07-29)","text":"<ul> <li>add support for setting the S3 endpoint url via the <code>AWS_S3_ENDPOINT</code> environment variables in <code>aws_get_object</code> function using boto3 (cogeotiff/rio-tiler!394)</li> <li>make <code>ImageStatistics.valid_percent</code> a value between 0 and 100 (instead of 0 and 1) (author @param-thakker, cogeotiff/rio-tiler!400)</li> <li> <p>add <code>fetch_options</code> to <code>STACReader</code> to allow custom configuration to the fetch client (cogeotiff/rio-tiler!404)</p> <pre><code>with STACReader(\"s3://...\", fetch_options={\"request_pays\": True}):\n    pass\n</code></pre> </li> <li> <p>Fix alpha band values when storing <code>Uint16</code> data in PNG. (cogeotiff/rio-tiler!407)</p> </li> </ul>"},{"location":"release-notes/#210-2021-05-17","title":"2.1.0 (2021-05-17)","text":"<ul> <li>add auto-rescaling in <code>ImageData.render</code> method to avoid error when datatype is not supported by the output driver (cogeotiff/rio-tiler!391)</li> </ul> <pre><code># before - exit with error\nwith open(\"img.png\", \"wb\") as f:\n    f.write(ImageData(numpy.zeros((3, 256, 256), dtype=\"float32\")).render())\n&gt;&gt;&gt; (ERROR) CPLE_NotSupportedError: \"PNG driver doesn't support data type Float32. Only eight bit (Byte) and sixteen bit (UInt16) bands supported\".\n\n# now - print a warning\nwith open(\"img.png\", \"wb\") as f:\n    f.write(ImageData(numpy.zeros((3, 256, 256), dtype=\"float32\")).render())\n&gt;&gt;&gt; (WARNING) InvalidDatatypeWarning: \"Invalid type: `float32` for the `PNG` driver. Data will be rescaled using min/max type bounds\".\n</code></pre> <p>breaking changes</p> <ul> <li>change type of <code>in_range</code> option in <code>ImageData.render</code> to <code>Sequence[Tuple[NumType, NumType]]</code> (cogeotiff/rio-tiler!391)</li> </ul> <pre><code>img = ImageData(numpy.zeros((3, 256, 256), dtype=\"uint16\"))\n\n# before - Tuple[NumType, NumType]\nbuff = img.render(in_range=(0, 1000, 0, 1000, 0, 1000))\n\n# now - Sequence[Tuple[NumType, NumType]]\nbuff = img.render(in_range=((0, 1000), (0, 1000), (0, 1000)))\n</code></pre>"},{"location":"release-notes/#208-2021-04-26","title":"2.0.8 (2021-04-26)","text":"<ul> <li>add warning when dataset doesn't have overviews (cogeotiff/rio-tiler!386)</li> <li>add <code>width</code>, <code>height</code>, <code>count</code> and <code>overviews</code> infos in <code>COGReader.info()</code> (cogeotiff/rio-tiler!387)</li> <li>add <code>driver</code> in <code>COGReader.info()</code> output (cogeotiff/rio-tiler!388)</li> <li>add <code>valid_percent</code> in <code>stats</code> output (cogeotiff/rio-tiler!389)</li> </ul>"},{"location":"release-notes/#207-2021-04-01","title":"2.0.7 (2021-04-01)","text":"<ul> <li>use importlib.resources <code>.files</code> method to resolve the package directory (cogeotiff/rio-tiler!379)</li> </ul>"},{"location":"release-notes/#206-2021-03-25","title":"2.0.6 (2021-03-25)","text":"<ul> <li>add <code>read()</code> method in COGReader (cogeotiff/rio-tiler!366)</li> <li>add <code>tile_buffer</code> option to <code>COGReader.tile()</code> method to add pixels around a tile request (cogeotiff/rio-tiler#365)</li> <li>use <code>importlib.resources.path</code> to find rio-tiler <code>cmap_data</code> directory (cogeotiff/rio-tiler!370)</li> <li>re-use type definitions (cogeotiff/rio-tiler#337)</li> </ul>"},{"location":"release-notes/#205-2021-03-17","title":"2.0.5 (2021-03-17)","text":"<ul> <li>make sure <code>py.typed</code> is included in the package (cogeotiff/rio-tiler!363)</li> <li>add <code>jpg</code> alias in <code>img_profiles</code> (cogeotiff/rio-tiler!364)</li> </ul> <pre><code>from rio_tiler.profiles import img_profiles\n\njpeg = img_profiles.get(\"jpeg\")\njpg = img_profiles.get(\"jpg\")\nassert jpeg == jpg\n</code></pre>"},{"location":"release-notes/#204-2021-03-09","title":"2.0.4 (2021-03-09)","text":"<ul> <li>Added pystac.MediaType.COG in supported types by STAC reader</li> <li>fix bad type definition in <code>rio_tiler.colormap.ColorMaps</code> data (cogeotiff/rio-tiler#359)</li> <li>add <code>rio_tiler.colormap.parse_color</code> function to parse HEX color (cogeotiff/rio-tiler#361)</li> </ul>"},{"location":"release-notes/#203-2021-02-19","title":"2.0.3 (2021-02-19)","text":"<ul> <li>Reduce the number of <code>.read()</code> calls for dataset without nodata value (cogeotiff/rio-tiler!355)</li> <li>replace deprecated <code>numpy.float</code> by <code>numpy.float64</code></li> </ul>"},{"location":"release-notes/#202-2021-02-17","title":"2.0.2 (2021-02-17)","text":"<ul> <li>fix bad mask datatype returned by mosaic methods (cogeotiff/rio-tiler!353)</li> <li>align WarpedVRT with internal blocks when needed. This is to reduce the number of GET requests need for VSI files (cogeotiff/rio-tiler!345)</li> </ul>"},{"location":"release-notes/#201-2021-02-04","title":"2.0.1 (2021-02-04)","text":"<ul> <li>fix arguments names conflicts between mosaic_reader/tasks and STACReader options (cogeotiff/rio-tiler!343)</li> <li>update rio-tiler pypi description.</li> </ul>"},{"location":"release-notes/#200-2021-01-27","title":"2.0.0 (2021-01-27)","text":"<ul> <li>add MultiPolygon support in <code>rio_tiler.utils.create_cutline</code> (cogeotiff/rio-tiler#323)</li> <li>support discrete colormap by default in <code>apply_cmap</code> (cogeotiff/rio-tiler#321)</li> <li>delete deprecated <code>rio_tiler.mercator</code> submodule</li> <li>added default factory in <code>rio_tiler.colormap.ColorMaps</code>.</li> <li>fix missing <code>metadata</code> forwarding in <code>ImageData.post_process</code> method.</li> <li>refactor <code>rio_tiler.io.GCPCOGReader</code> for better inheritance from COGReader.</li> </ul> <p>breaking change</p> <ul> <li>renamed input parameter <code>tile</code> to <code>data</code> in <code>rio_tiler.utils.render</code>.</li> <li>renamed input parameter <code>arr</code> to <code>data</code> in <code>rio_tiler.utils.mapzen_elevation_rgb</code></li> <li>made <code>rio_tiler.io.stac.to_pystac_item</code> private (renamed to <code>_to_pystac_item</code>)</li> <li>renamed <code>rio_tiler.colormap.DEFAULTS_CMAPS</code> to <code>rio_tiler.colormap.DEFAULT_CMAPS_FILES</code></li> <li>made <code>rio_tiler.reader._read</code> public (renamed to rio_tiler.reader.read) (ref: cogeotiff/rio-tiler#332)</li> </ul>"},{"location":"release-notes/#200rc4-2020-12-18","title":"2.0.0rc4 (2020-12-18)","text":"<ul> <li>add <code>NPZ</code> output format (cogeotiff/rio-tiler#308)</li> <li>add pystac for STAC item reader (author @emmanuelmathot, cogeotiff/rio-tiler#212)</li> <li>delete deprecated function: <code>rio_tiler.reader.tile</code>, <code>rio_tiler.utils.tile_exits</code> and <code>rio_tiler.utils.geotiff_options</code></li> <li>deprecated <code>rio_tiler.mercator</code> submodule (cogeotiff/rio-tiler#315)</li> <li>update morecantile version to 2.1, which has better <code>tms.zoom_for_res</code> definition.</li> </ul>"},{"location":"release-notes/#200rc3-2020-11-24","title":"2.0.0rc3 (2020-11-24)","text":"<ul> <li>add <code>feature</code> method to reader classes (cogeotiff/rio-tiler#306)</li> </ul>"},{"location":"release-notes/#200rc2-2020-11-17","title":"2.0.0rc2 (2020-11-17)","text":"<ul> <li>add <code>data</code> validation in <code>rio_tiler.models.ImageData</code> model. Data MUST be a 3 dimensions array in form of (count, height, width).</li> <li><code>mask</code> is now optional for <code>rio_tiler.models.ImageData</code> model, but will be initialized to a default full valid (<code>255</code>) array.</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.rand(3, 10, 10)\n\nimg = ImageData(data)\nassert img.mask.all()\n</code></pre> <ul> <li>add <code>metadata</code> property to <code>rio_tiler.models.ImageData</code> model</li> </ul> <pre><code>img.metadata\n&gt;&gt;&gt; {}\n</code></pre> <p>breaking change</p> <ul> <li><code>rio_tiler.mosaic.reader.mosaic_reader</code> now raises <code>EmptyMosaicError</code> instead of returning an empty <code>ImageData</code></li> </ul>"},{"location":"release-notes/#200rc1post1-2020-11-12","title":"2.0.0rc1.post1 (2020-11-12)","text":"<ul> <li>Remove <code>Uint8</code> data casting before applying <code>color_formula</code> in ImageData.render (cogeotiff/rio-tiler#302)</li> </ul>"},{"location":"release-notes/#200rc1-2020-11-09","title":"2.0.0rc1 (2020-11-09)","text":"<ul> <li>added <code>ImageData</code> output class for all <code>rio_tiler.io</code> classes returning numpy array-like types (<code>tile, mask = method()</code>)</li> </ul> <p><pre><code>from rio_tiler.io import COGReader\nfrom rio_tiler.models import ImageData\n\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    r = cog.preview()\n    assert isinstance(r, ImageData)\n\n    data, mask = r\n    assert data.shape == (3, 892, 1024)\n</code></pre> Note: the class keeps the compatibility with previous notation: <code>tile, mask = ImageData</code></p> <ul> <li> <p>add pydantic models for IO outputs (Metadata, Info, ...)</p> </li> <li> <p>change output form for <code>band_metadata</code>, <code>band_descriptions</code> and do not add band description when not found. <pre><code># Before\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    i = cog.info()\n    print(i[\"band_metadata\"])\n    print(i[\"band_descriptions\"])\n\n[(1, {}), (2, {}), (2, {})]\n[(1, 'band1'), (2, 'band2'), (2, 'band3')]\n\n# Now\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    i = cog.info()\n    print(i.band_metadata)\n    print(i.band_descriptions)\n\n[('1', {}), ('2', {}), ('3', {})]\n[('1', ''), ('2', ''), ('3', '')]\n</code></pre></p> </li> <li> <p>change output form for <code>stats</code> <pre><code># Before\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats())\n{\n    1: {...},\n    2: {...},\n    3: {...}\n}\n\n# Now\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats())\n{\n    \"1\": {...},\n    \"2\": {...},\n    \"3\": {...}\n}\n</code></pre></p> </li> <li> <p>updated <code>rio_tiler.utils._stats</code> function to replace <code>pc</code> by <code>percentiles</code></p> </li> </ul> <pre><code>with COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats()[\"1\"].json())\n{\"percentiles\": [19.0, 168.0], \"min\": 0.0, \"max\": 255.0, ...}\n</code></pre> <ul> <li>make <code>rio_tiler.colormap.ColorMap</code> object immutable. Registering a new colormap will new returns a now instance of ColorMap(cogeotiff/rio-tiler#289).</li> <li>changed the <code>rio_tiler.colormap.ColorMap.register()</code> method to take a dictionary as input (instead of name + dict).</li> </ul> <pre><code>from rio_tiler.colormap import cmap # default cmap\n\n# previous\ncmap.register(\"acmap\", {0: [0, 0, 0, 0], ...})\n\n# Now\ncmap = cmap.register({\"acmap\": {0: [0, 0, 0, 0], ...}})\n</code></pre> <ul> <li> <p>added the possibility to automatically register colormaps stored as <code>.npy</code> file in a directory, if <code>COLORMAP_DIRECTORY</code> environment variable is set with the name of the directory.</p> </li> <li> <p>Update to morecantile 2.0.0</p> </li> </ul>"},{"location":"release-notes/#200b19-2020-10-26","title":"2.0.0b19 (2020-10-26)","text":"<ul> <li>surface <code>allowed_exceptions</code> options in <code>rio_tiler.mosaic.reader.mosaic_reader</code> (cogeotiff/rio-tiler#293)</li> <li>add SpatialInfoMixin base class to reduce code duplication (co-author with @geospatial-jeff, cogeotiff/rio-tiler!295)</li> <li>add <code>AsyncBaseReader</code> to support async readers (author @geospatial-jeff, cogeotiff/rio-tiler!265)</li> </ul>"},{"location":"release-notes/#200b18-2020-10-22","title":"2.0.0b18 (2020-10-22)","text":"<ul> <li>surface dataset.nodata in COGReader.nodata property (cogeotiff/rio-tiler!292)</li> <li>fix non-threaded tasks scheduler/filter (cogeotiff/rio-tiler!291)</li> </ul>"},{"location":"release-notes/#200b17-2020-10-13","title":"2.0.0b17 (2020-10-13)","text":"<ul> <li>switch to morecantile for TMS definition (ref: cogeotiff/rio-tiler#283)</li> <li>add tms options in Readers (breaking change if you create custom Reader from BaseReader)</li> <li>add tile_bounds vs bounds check in tile methods for MultiBands and MultiBase classes</li> <li>add tile_exists method in BaseReader (take tms in account)</li> <li>adapt zooms calculation in COGReader</li> <li>add <code>LastBandHigh</code> and <code>LastBandLow</code> pixel selection (ref: cogeotiff/rio-tiler!270)</li> </ul> <p>Deprecated function</p> <ul> <li>rio_tiler.reader.tile</li> <li>rio_tiler.utils.geotiff_options</li> <li>rio_tiler.utils.tile_exists</li> <li>rio_tiler.io.multi_*</li> </ul>"},{"location":"release-notes/#200b16-2020-10-07","title":"2.0.0b16 (2020-10-07)","text":"<ul> <li>remove <code>pkg_resources</code> (pypa/setuptools#510)</li> <li>refactor default colormap lookup to use pathlib instead of pkg_resources.</li> </ul> <p>Note: We changed the versioning scheme to <code>{major}.{minor}.{path}{pre}{prenum}</code></p>"},{"location":"release-notes/#20b15-2020-10-05","title":"2.0b15 (2020-10-05)","text":"<ul> <li>Fix missing Exception catching when running task outside threads (ref: developmentseed/titiler#130).</li> <li>add rio-tiler logger (cogeotiff/rio-tiler#277).</li> </ul>"},{"location":"release-notes/#20b14post2-2020-10-02","title":"2.0b14.post2 (2020-10-02)","text":"<ul> <li>Fix bug in <code>MultiBandReader</code> (ref: cogeotiff/rio-tiler#275) and add tests.</li> </ul>"},{"location":"release-notes/#20b14post1-2020-10-02","title":"2.0b14.post1 (2020-10-02)","text":"<ul> <li>add <code>MultiBandReader</code> and <code>GCPCOGReader</code> in <code>rio_tiler.io</code> init.</li> </ul>"},{"location":"release-notes/#20b14-2020-10-02","title":"2.0b14 (2020-10-02)","text":"<ul> <li>Added back the Conctext Manager methods in <code>rio_tiler.io.base.BaseReader</code> but not as <code>@abc.abstractmethod</code> (ref: github.com/cogeotiff/rio-tiler/pull/273#discussion_r498937943)</li> <li>Move <code>rio_tiler_pds.reader.MultiBandReader</code> and <code>rio_tiler_pds.reader.GCPCOGReader</code> to rio-tiler (cogeotiff/rio-tiler!273)</li> </ul>"},{"location":"release-notes/#20b13-2020-10-01","title":"2.0b13 (2020-10-01)","text":"<ul> <li>remove ContextManager requirement for <code>rio_tiler.io.base.BaseReader</code> and <code>rio_tiler.io.base.MultiBaseReader</code> base classes.</li> <li>move ContextManager properties definition to <code>__attrs_post_init__</code> method in <code>rio_tiler.io.STACReader</code> and <code>rio_tiler.io.COGReader</code> (ref: cogeotiff/rio-tiler-pds#21)</li> </ul>"},{"location":"release-notes/#20b12-2020-09-28","title":"2.0b12 (2020-09-28)","text":"<ul> <li>Make sure Alpha band isn't considered as an internal mask by <code>utils.has_mask_band</code></li> </ul>"},{"location":"release-notes/#20b11-2020-09-24","title":"2.0b11 (2020-09-24)","text":"<ul> <li>reduce verbosity in <code>rio_tiler.tasks.filter_tasks</code> exception logging (#266).</li> </ul>"},{"location":"release-notes/#20b10-2020-09-15","title":"2.0b10 (2020-09-15)","text":"<ul> <li>add <code>post_process</code> callback to <code>rio_tiler.render._read</code> and <code>rio_tiler.render.point</code> to apply specific operation ouput arrays.</li> </ul>"},{"location":"release-notes/#20b9-2020-09-09","title":"2.0b9 (2020-09-09)","text":"<ul> <li>restore Mkdocs search bar (#255)</li> <li>Allow class (not just instance) to be passed to pixel_selection (#250)</li> <li>Add Binder link/badge to README (#254)</li> <li>Add mkdocs-jupyter to show notebooks in website (#253)</li> <li>Remove deprecated functions (#247)</li> <li>Export modules from top-level package (#246)</li> <li>Allow overwriting colormap with force=True (#249)</li> <li>Pin black version (#251)</li> <li>Add contributing.md (#242)</li> <li>Add mkdocs config (#240)</li> <li>Add <code>NPY</code> support in <code>rio_tiler.utils.render</code> to save tile in numpy binary format (#256)</li> <li>Remove bare <code>Exception</code> and add more detailed errors (#248)</li> </ul>"},{"location":"release-notes/#20b8-2020-08-24","title":"2.0b8 (2020-08-24)","text":"<ul> <li>raise specific <code>PointOutsideBounds</code> in rio_tiler.reader.point (#236)</li> </ul>"},{"location":"release-notes/#20b7-2020-08-21","title":"2.0b7 (2020-08-21)","text":"<ul> <li>allow setting default kwargs in COGReader init (#227)</li> <li>allow <code>vrt_options</code> in COGReader.point</li> <li>add <code>rio_tiler.io.base.MultiBaseReader</code> class (#225)</li> <li>refactor <code>rio_tiler.io.stac.STACReader</code> to use MultiBaseReader (#225)</li> <li>add <code>rio_tiler.task</code> submodule to share tools for handling rio-tiler's future tasks.</li> <li>fix regex parsing for rio-tiler expression</li> <li>add warnings when assets/indexes is passed with expression option (#233)</li> </ul> <p>Breaking Changes: - replace dataclass wiht attr to support more flexible class definition (see #225)</p>"},{"location":"release-notes/#20b6-2020-08-04","title":"2.0b6 (2020-08-04)","text":"<ul> <li>add <code>utils.create_cutline</code> helper (#218)</li> <li>remove any mutable default argument</li> </ul> <p>depreciation - <code>warp_vrt_option</code> is replaced by <code>vrt_options</code> in rio_tiler.reader.part (#221)</p>"},{"location":"release-notes/#20b5-2020-07-31","title":"2.0b5 (2020-07-31)","text":"<ul> <li>add more verbosity to mosaic error (#214)</li> </ul> <p>Breaking Changes: - <code>rio_tiler.mosaic.reader.mosaic_reader</code> return <code>((tile, mask), assets_used)</code> - <code>COGReader.info</code> is now a method instead of a property to align with other reader (#211)</p>"},{"location":"release-notes/#20b4-2020-07-30","title":"2.0b4 (2020-07-30)","text":"<ul> <li>add rio_tiler.io.base.BaseReader abstract class for COGReader and STACReader to inherit from</li> <li>STACReader raises <code>InvalidAssetName</code> for invalid asset name or <code>MissingAssets</code> when no assets is passed (#208)</li> <li>update rio_tiler.mosaic.reader.mosaic_reader to not use threadPool if threads &lt;= 1 (#207)</li> </ul> <p>Breaking Changes: - Reader.spatial_info is a property (#203) - assets is a keyword argument in STACReader stats/info/metadata</p>"},{"location":"release-notes/#20b3-2020-07-27","title":"2.0b3 (2020-07-27)","text":"<ul> <li>add <code>rio_tiler.mosaic</code> submodule (ref: cogeotiff/rio-tiler-mosaic#16)</li> </ul>"},{"location":"release-notes/#20b2-2020-07-23","title":"2.0b2 (2020-07-23)","text":"<ul> <li>add boto3 in the dependency (#201)</li> </ul>"},{"location":"release-notes/#20b1-2020-07-22","title":"2.0b1 (2020-07-22)","text":"<ul> <li>switch to ContextManager for COG and STAC (rio_cogeo.io.COGReader, rio_cogeo.io.STACReader).</li> <li>COGReader.part and STACReader.part return data in BBOX CRS by default.</li> <li>STACReader now accept URL (https, s3).</li> <li>add more method for STAC (prewiew/point/part/info/stats).</li> <li>add expression for COG/STAC preview/point/part.</li> <li>add <code>masked</code> option in <code>rio_tiler.reader.point</code> to control weither or not it should return None or a value.</li> <li>remove mission specific tilers (#195).</li> <li>remove <code>rio_tiler.reader.multi_*</code> functions (replaced by rio_tiler.io.cogeo.multi_*).</li> <li>remove <code>rio_tiler.utils.expression</code> (replaced by expression options in tilers).</li> </ul>"},{"location":"release-notes/#20a11-2020-05-29","title":"2.0a11 (2020-05-29)","text":"<ul> <li>refactor <code>rio_tiler.utils.tile_exists</code> to allow raster bounds latitude == -90,90</li> </ul>"},{"location":"release-notes/#20a10-2020-05-29","title":"2.0a10 (2020-05-29)","text":"<ul> <li>Change default resampling to nearest for <code>_read</code> (#187)</li> <li>add <code>rio_tiler.reader.stats</code> (return only array statistics)</li> <li>remove default <code>dst_crs</code> in <code>rio_tiler.reader.part</code> to to fallback to dataset CRS.</li> </ul>"},{"location":"release-notes/#20a9-2020-05-27","title":"2.0a9 (2020-05-27)","text":"<ul> <li>Refactor colormap and add method to register custom colormap</li> </ul>"},{"location":"release-notes/#20a8-2020-05-25","title":"2.0a8 (2020-05-25)","text":"<ul> <li>add <code>preview</code> method to <code>rio_tiler.io.cogeo</code></li> </ul>"},{"location":"release-notes/#20a7-2020-05-17","title":"2.0a7 (2020-05-17)","text":"<ul> <li>allow reading high resolution part of a raster (by making height, width args optional)</li> <li>add <code>max_size</code> option in <code>rio_tiler.reader.part</code> to set a maximum output size when height and width are not set</li> <li>add point and area function in rio_tiler.io.cogeo</li> <li>fix width-height height-widht bug in <code>rio_tiler.reader.part</code></li> </ul> <p>depreciation - deprecated <code>out_window</code> option in favor of <code>window</code> in rio_tiler.reader._read</p>"},{"location":"release-notes/#20a6-2020-05-06","title":"2.0a6 (2020-05-06)","text":"<ul> <li>fix unwanted breacking change with <code>img_profiles.get</code> not allowing default values</li> </ul>"},{"location":"release-notes/#20a5-2020-05-06","title":"2.0a5 (2020-05-06)","text":"<ul> <li>make <code>rio_tiler.io.landsat8.tile</code> return Uint16 data and not float32 (#173)</li> <li><code>rio_tiler.profiles.img_profiles</code> item access return <code>copy</code> of the items (#177)</li> <li>better colormap docs (#176, author @kylebarron)</li> </ul>"},{"location":"release-notes/#20a4-2020-04-08","title":"2.0a4 (2020-04-08)","text":"<ul> <li>add <code>rio_tiler.io.cogeo.info</code> to retrieve simple file metadata (no image statistics)</li> <li>add band metadata tag info in <code>rio_tiler.render.metadata</code> output</li> <li>add <code>rio_tiler.io.stac</code> STAC compliant rio_tiler.colormap.apply_discrete_cmap</li> </ul>"},{"location":"release-notes/#20a3-2020-03-25","title":"2.0a3 (2020-03-25)","text":"<ul> <li>only use <code>transform_bounds</code> when needed in rio_tiler.reader.part</li> </ul> <p>Breaking Changes: - switch back to gdal/rasterio calculate_default_transform (#164). Thanks to Terracotta core developper @dionhaefner. - refactor <code>rio_tiler.utils.get_vrt_transform</code> to get width and height input.</p>"},{"location":"release-notes/#20a2-2020-03-20","title":"2.0a2 (2020-03-20)","text":"<ul> <li>Fall back to gdal/rasterio calculate_default_transform for dateline separation crossing dataset (ref #164)</li> </ul>"},{"location":"release-notes/#20a1-2020-03-19","title":"2.0a1 (2020-03-19)","text":"<ul> <li>added <code>reader.preview</code>, <code>reader.point</code> methods</li> <li>added multi_* functions to rio_tiler.reader to support multiple assets addresses</li> <li>added <code>rio_tiler.utils.has_mask_band</code> function</li> <li>added <code>rio_tiler.utils.get_overview_level</code> to calculate the overview level needed for partial reading.</li> <li>added type hints</li> <li>added scale, offsets, colormap, datatype and colorinterp in reader.metadata output (#158)</li> <li>new <code>rio_tiler.colormap</code> submodule</li> <li>added <code>unscale</code> options to rio_tiler.reader._read function apply internal scale/offset (#157)</li> </ul> <p>Breaking Changes: - removed python 2 support - new package architecture (.io submodule) - introduced new rio_tiler.reader functions (part, preview, metadata...) - renamed rio_tiler.main to rio_tiler.io.cogeo - bucket and prefixes are defined in rio_tiler.io.dataset.<code>{dataset}_parse</code> function from   AWS supported Public Dataset - renamed <code>minimum_tile_cover</code> to <code>minimum_overlap</code> - renamed <code>tile_edge_padding</code> to <code>padding</code> - padding is set to 0 by default. - use terracotta calculate_default_transform (see github.com/cogeotiff/rio-tiler/issues/56#issuecomment-442484999) - colormaps are now have an alpha value - <code>rio_tiler.utils.get_colormap</code> replaced by <code>rio_tiler.colormap.get_colormap</code> - new <code>rio_tiler.colormap.get_colormap</code> supports only GDAL like colormap - replaced <code>rio_tiler.utils.array_to_image</code> by <code>rio_tiler.utils.render</code> - replaced <code>rio_tiler.utils.apply_cmap</code> by <code>rio_tiler.colormap.apply_cmap</code> - replaced <code>rio_tiler.utils._apply_discrete_colormap</code> by <code>rio_tiler.colormap.apply_discrete_cmap</code> - removed <code>histogram_bins</code> and <code>histogram_range</code> in options in metadata reader.   Should now be passed in <code>hist_options</code> (e.g: hist_options={bins=10, range=(0, 10)}) - remove alpha band value from output data array in tile/preview/metadata #127</p>"},{"location":"release-notes/#140-2020-02-19","title":"1.4.0 (2020-02-19)","text":"<ul> <li>Add Sentinel2-L2A support (#137)</li> <li>Update Sentinel-2 sceneid schema (S2A_tile_20170323_07SNC_0 -&gt; S2A_L1C_20170323_07SNC_0)</li> </ul>"},{"location":"release-notes/#131-2019-11-06","title":"1.3.1 (2019-11-06)","text":"<ul> <li>Add <code>warp_vrt_option</code> option for <code>utils.raster_get_stats</code> and <code>utils.tile_read</code> to allow more custom VRT Warping. (ref: github.com/OSGeo/gdal/issues/1989#issue-518526399)</li> <li>Add <code>rio_tiler.utils.non_alpha_indexes</code> to find non-alpha band indexes (ref #127)</li> </ul>"},{"location":"release-notes/#130-2019-10-07","title":"1.3.0 (2019-10-07)","text":"<ul> <li>Allow <code>DatasetReader</code>, <code>DatasetWriter</code>, <code>WarpedVRT</code> input for <code>utils.raster_get_stats</code> and <code>utils.tile_read</code></li> <li>add <code>minimum_tile_cover</code> option to filter dataset not covering a certain amount of the tile.</li> <li>add Sentinel-1 submodule</li> </ul> <p>Breaking Changes: - need rasterio&gt;=1.1</p>"},{"location":"release-notes/#1211-2019-09-18","title":"1.2.11 (2019-09-18)","text":"<ul> <li>reduce memory footprint of expression tiler</li> <li>fix wrong calculation for overview size in <code>raster_get_stats</code> (#116)</li> <li>Add Landsat 8 QA Band (#117).</li> </ul>"},{"location":"release-notes/#1210-2019-07-18","title":"1.2.10 (2019-07-18)","text":"<ul> <li>add more colormap options (from matplotlib) and switch from txt files to numpy binaries (#115)</li> </ul>"},{"location":"release-notes/#129-2019-07-11","title":"1.2.9 (2019-07-11)","text":"<ul> <li>fix issue #113, adds depreciation warning for <code>bounds_crs</code> in favor of <code>dst_crs</code> in <code>rio_tiler.utils.get_vrt_transform</code></li> </ul>"},{"location":"release-notes/#128-2019-07-08","title":"1.2.8 (2019-07-08)","text":"<ul> <li>Add kwargs options in landsat8.tile, sentinel2.tile and cbers.tile functions to allow <code>resampling_method</code> and <code>tile_edge_padding</code> options forwarding to utils._tile_read.</li> <li>Add Input (bounds_crs) and Output (dst_crs) option to <code>utils._tile_read</code> function (#108)</li> </ul>"},{"location":"release-notes/#127-2019-05-14","title":"1.2.7 (2019-05-14)","text":"<ul> <li>Revert changes introduced in #106 (see #105)</li> <li>Refactor tests</li> </ul>"},{"location":"release-notes/#126-2019-05-10-deleted","title":"1.2.6 (2019-05-10) - DELETED","text":"<ul> <li>Use same resampling method for mask and for data (#105)</li> </ul>"},{"location":"release-notes/#125-2019-05-08","title":"1.2.5 (2019-05-08)","text":"<ul> <li>add tile_edge_padding option to be passed to rio_tiler.utils._tile_read to reduce sharp edges that occur due to resampling (#104)</li> </ul>"},{"location":"release-notes/#124-2019-04-16","title":"1.2.4 (2019-04-16)","text":"<ul> <li>add histogram_range options to be passed to rio_tiler.{module}.metadata function (#102)</li> </ul>"},{"location":"release-notes/#123-2019-04-04","title":"1.2.3 (2019-04-04)","text":"<ul> <li>add histogram_bins options to be passed to rio_tiler.{module}.metadata function (#98)</li> </ul> <p>Bug fixes: - return index number with band descriptions (#99)</p>"},{"location":"release-notes/#122-2019-04-03","title":"1.2.2 (2019-04-03)","text":"<ul> <li>add mercator min/max zoom info in metadata output from rio_tiler.utils.raster_get_stats (#96)</li> <li>add band description (band name) in metadata output from rio_tiler.utils.raster_get_stats (#96)</li> </ul>"},{"location":"release-notes/#121-2019-03-26","title":"1.2.1 (2019-03-26)","text":"<ul> <li>Replace rio-pansharpen dependency with a fork of the brovey function directly into <code>rio_tiler.utils</code> (rio-pansharpen is unmaintened and not compatible with rasterio&gt;=1) (#94).</li> </ul>"},{"location":"release-notes/#120-2019-03-26","title":"1.2.0 (2019-03-26)","text":"<ul> <li><code>rio_tiler.utils.array_to_image</code>'s color_map arg can be a dictionary of discrete values (#91)</li> </ul> <p>Breaking Changes: - <code>expr</code> argument is now a required option in <code>rio_tiler.utils.expression</code>. (#88)</p>"},{"location":"release-notes/#114-2019-03-11","title":"1.1.4 (2019-03-11)","text":"<ul> <li>Add 'rplumbo' colormap (#90 by @DanSchoppe)</li> </ul>"},{"location":"release-notes/#113-2019-03-06","title":"1.1.3 (2019-03-06)","text":"<p>Bug fixes: - Fix casting to integer for MAX_THREADS environment variable.</p>"},{"location":"release-notes/#111-2019-02-21","title":"1.1.1 (2019-02-21)","text":"<ul> <li>Minor typo correction and harmonization of the use of src/src_dst/src_path in <code>rio_tiler.utils</code></li> </ul> <p>Bug fixes: - Fix nodata handling in <code>utils.raster_get_stats</code></p>"},{"location":"release-notes/#110-2019-02-15","title":"1.1.0 (2019-02-15)","text":"<ul> <li>Allow options forwarding to <code>tile_read</code> from <code>main.tile</code> function (#86)</li> <li>Add <code>resampling_method</code> options in <code>rio_tiler.utils.tile_read</code> to allow user set resampling. Default is now bilinear (#85)</li> </ul> <p>Bug fixes: - Fix nodata option forwarding to tile_read when source is a path (#83)</p> <p>Refactoring: - Refactor <code>rio_tiler.utils.tile_read</code> to reduce code complexity (#84)</p> <p>Breaking Changes: - <code>indexes</code> options is now set to None in <code>rio_tiler.utils.tile_read</code>. Default will now be the dataset indexes.</p>"},{"location":"release-notes/#101-2019-02-14","title":"1.0.1 (2019-02-14)","text":"<ul> <li>Fix mask datatype bug in <code>rio_tiler.utils.array_to_image</code>(#79)</li> <li>Fix nodata handling and better test for the nodata/mask main module (#81)</li> </ul>"},{"location":"release-notes/#100-2019-02-11","title":"1.0.0 (2019-02-11)","text":"<ul> <li>add missing Landsat panchromatic band (08) min/max fetch in <code>rio_tiler.landsat8.metadata</code> (#58)</li> <li>add pre-commit for commit validation (#64)</li> <li>code formatting using Black (the uncompromising Python code formatter) (#64)</li> <li>update documentation (Sentinel-2 cost) (#68)</li> <li>add <code>utils.raster_get_stats</code> and <code>utils._get_stats</code> to replace <code>min_max*</code> function and to return more statistics (#66)</li> <li>add overview level selection to statistical functions to reduce the data download (#59)</li> <li>add pure GDAL <code>array_to_image</code> function to replace PIL tools (#29)</li> <li>add GDAL format output from <code>utils.get_colormap</code> to be used in <code>array_to_image</code> (#29)</li> <li>add GDAL compatible Image creation profile (#29)</li> <li>add max threads number settings via \"MAX_THREADS\" environment variable (#71)</li> </ul> <p>Breaking Changes: - update <code>metadata</code> structure returned by <code>landsat8.metadata</code>, <code>sentinel2.metadata</code>, <code>cbers.metadata</code> - force sentinel, landsat and cbers band names to be string and add validation (#65) - moved landsat utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.landsat8</code>   - rio_tiler.utils.landsat_get_mtl -&gt; rio_tiler.landsat8._landsat_get_mtl   - rio_tiler.utils.landsat_parse_scene_id -&gt; rio_tiler.landsat8._landsat_parse_scene_id   - rio_tiler.utils.landsat_get_stats -&gt; rio_tiler.landsat8._landsat_stats - moved cbers utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.cbers</code>   - rio_tiler.utils.cbers_parse_scene_id -&gt; rio_tiler.cbers._cbers_parse_scene_id - moved sentinel-2 utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.sentinel2</code>   - rio_tiler.utils.sentinel_parse_scene_id -&gt; rio_tiler.sentinel2._sentinel_parse_scene_id - removed deprecated PIL support as well as base64 encoding function in rio_tiler.utils   - rio_tiler.utils.img_to_buffer   - rio_tiler.utils.array_to_img   - rio_tiler.utils.b64_encode_img - removed deprecated min_max* functions (landsat_min_max_worker and band_min_max_worker)</p>"},{"location":"release-notes/#10rc2-2018-08-22","title":"1.0rc2 (2018-08-22)","text":"<ul> <li>add test case for pix4d nodata+alpha band data</li> </ul>"},{"location":"release-notes/#10rc1-2018-07-16","title":"1.0rc1 (2018-07-16)","text":"<ul> <li>rasterio 1.0.0</li> </ul>"},{"location":"release-notes/#10b3-2018-07-02","title":"1.0b3 (2018-07-02)","text":"<ul> <li>add schwarzwald color palette</li> </ul>"},{"location":"release-notes/#10b2-2018-06-26","title":"1.0b2 (2018-06-26)","text":"<ul> <li>fix nodata (#48)</li> </ul>"},{"location":"release-notes/#10b1-2018-06-23","title":"1.0b1 (2018-06-23)","text":"<ul> <li>adapt to rasterio 1.0b4</li> <li>fix mask (internal/external) fetching \ud83d\ude4f</li> <li>fix boundless read with new rasterio 1.0b2</li> <li>fix custom nodata handling</li> <li>fix performances issue</li> </ul> <p>Breaking Changes: - removed alpha band options to select a custom alpha band number</p>"},{"location":"release-notes/#10a8-2018-06-20","title":"1.0a8 (2018-06-20)","text":"<ul> <li>Fix rasterio version to 1.0b1 (#46 and #44)</li> </ul>"},{"location":"release-notes/#10a7-2018-05-14","title":"1.0a7 (2018-05-14)","text":"<ul> <li>Support for additional CBERS instruments (fredliporace)</li> </ul>"},{"location":"release-notes/#10a6-2018-03-29","title":"1.0a6 (2018-03-29)","text":"<ul> <li>Fixes sentinel-2 band 8A regex bug in <code>rio_tiler.utils.expression</code></li> </ul>"},{"location":"release-notes/#10a5-2018-03-26","title":"1.0a5 (2018-03-26)","text":"<ul> <li>adds DatasetReader input option for utils.tile_read (do not close the dataset on each read)</li> </ul> <p>Breaking Changes: - <code>utils.tile_band_worker</code> renamed to <code>utils.tile_read</code> - <code>main.tile</code> rgb option renamed indexes - <code>sentinel2.tile</code>, <code>landsat8.tile</code>,  <code>cbers.tile</code> rgb option renamed bands - <code>main.tile</code> default nodata mask is handled by rasterio</p>"},{"location":"release-notes/#10a4-2018-03-07","title":"1.0a4 (2018-03-07)","text":"<ul> <li>adds utils.b64_encode_img function to encode an image object into a base64 string</li> <li>add tiles profiles (jpeg, png, webp) based on github.com/mapnik/mapnik/wiki/Image-IO#default-output-details</li> </ul> <p>Breaking Changes: - Refactor <code>rio_tiler.utils.array_to_img</code> to return PIL image object</p>"},{"location":"release-notes/#10a3-2018-02-05","title":"1.0a3 (2018-02-05)","text":"<ul> <li>only using <code>read_masks</code> for mask creation when it's needed.</li> </ul>"},{"location":"release-notes/#10a2-2018-02-05","title":"1.0a2 (2018-02-05)","text":"<ul> <li>add \"expression\" utility function</li> <li>better nodata/mask/alpha band definition and support</li> </ul> <p>Breaking Changes: - tile functions now return an associated mask (Landsat, Sentinel, CBERS, main) - remove nodata support in utils.image_to_array function - add mask support in utils.image_to_array function - utils.tile_band_worker will always return a (Band, Width, Height) array (e.g 1x256x256 or 3x256x256)</p>"},{"location":"release-notes/#10a1-2018-01-04","title":"1.0a1 (2018-01-04)","text":"<ul> <li>remove aws.py sub-module (replaced by main.py)</li> <li>no default bands value for main.py tiles.</li> </ul>"},{"location":"release-notes/#10a0-2018-01-03","title":"1.0a.0 (2018-01-03)","text":"<ul> <li>add colormap option in <code>utils.array_to_img</code></li> <li>add TIR (brightness temps) support</li> <li>add CBERS support</li> <li>add global file support</li> <li>add elevation encoding for mapzen</li> <li>removing internal caching</li> <li>update to rasterio 1.0a12</li> </ul> <p>Breaking Changes: - remove data value rescaling in <code>landsat8.tile</code> and <code>sentinel2.tile</code> - fix wrong lat/grid_square value in <code>utils.sentinel_parse_scene_id</code> - rename <code>utils.sentinel_min_max_worker</code> to <code>utils.band_min_max_worker</code></p>"},{"location":"release-notes/#003-2017-11-14","title":"0.0.3 (2017-11-14)","text":"<ul> <li>Fix Sentinel-2 bad AWS url</li> </ul>"},{"location":"release-notes/#002-2017-10-17","title":"0.0.2 (2017-10-17)","text":"<ul> <li>Fix python \u2154 compatibilities in rio_tiler.utils.landsat_get_mtl</li> </ul>"},{"location":"release-notes/#001-2017-10-05","title":"0.0.1 (2017-10-05)","text":"<ul> <li>Initial release. Requires Rasterio &gt;= 1.0a10.</li> </ul>"},{"location":"supported_format/","title":"Supported file formats","text":"<p><code>rio-tiler</code> can work with all raster formats supported by GDAL. That's being said, <code>rio-tiler</code> works better with data format that supports partial reading, like Cloud Optimized GeoTIFF.</p> <p>On interesting feature of Cloud Optimized GeoTIFF is the internal overviews which enable fast preview of the data. For example, when using the <code>Reader.preview</code> method, rio-tiler will only fetch the internal overviews instead of the whole data, to be able to construct the output array. Doing this reduce the amount of data transfer and thus increase the process speed.</p>"},{"location":"supported_format/#vrt","title":"VRT","text":"<p>GDAL's Virtual format is also supported by rio-tiler.</p> <p>Warnings</p> <p>Map Tile reading from VRT might not be efficient if overviews are not present, because GDAL will try to open a lot of files.</p> <p></p>"},{"location":"supported_format/#xarray","title":"Xarray","text":"<p>New in version 4.0</p> <p>When <code>xarray</code> and <code>rioxarray</code> are installed in your environment, you can use <code>rio_tiler.io.XarrayReader</code> to read <code>xarray.DataArray</code> using the usual rio-tiler's Readers methods (<code>part()</code>, <code>tile()</code>, <code>feature()</code>).</p> <p>Warnings</p> <ul> <li>Datarray must be fully geo-referenced with a CRS and X,Y variables (longitude, latitude)</li> <li>Performance is largely dependant on the chunking of the array</li> </ul>"},{"location":"advanced/custom_readers/","title":"Base classes and custom readers","text":"<p><code>rio-tiler</code> provides multiple abstract base classes from which it derives its main readers: <code>Reader</code> and <code>STACReader</code>. You can also use these classes to build custom readers.</p>"},{"location":"advanced/custom_readers/#abstract-base-classes","title":"Abstract Base Classes","text":""},{"location":"advanced/custom_readers/#basereader","title":"BaseReader","text":"<p>Main <code>rio_tiler.io</code> Abstract Base Class.</p>"},{"location":"advanced/custom_readers/#minimal-arguments","title":"Minimal Arguments","text":"<ul> <li>input: Input</li> <li> <p>tms: The TileMatrixSet define which default projection and map grid the reader uses. Defaults to WebMercatorQuad.</p> </li> <li> <p>bounds: Dataset's bounding box. Not in the <code>__init__</code> method.</p> </li> <li>crs: dataset's crs. Not in the <code>__init__</code> method.</li> <li>transform: dataset's Affine transform. Not in the <code>__init__</code> method.</li> <li>height: dataset's height. Not in the <code>__init__</code> method.</li> <li>width: dataset's width. Not in the <code>__init__</code> method.</li> </ul> <p>Important</p> <p>BaseClass Arguments outside the <code>__init__</code> method and without default value HAVE TO be set in the <code>__attrs_post_init__</code> step.</p>"},{"location":"advanced/custom_readers/#methods","title":"Methods","text":"<ul> <li>tile_exists(tile_x: int, tile_y: int, tile_z: int): Check if a given tile (for the input TMS) intersect the dataset bounds.</li> <li>get_geographic_bounds(crs: rasterio.crs.CRS): dataset's bounds in Geographic CRS (calculated from <code>self.bounds</code> and <code>self.crs</code>).</li> </ul>"},{"location":"advanced/custom_readers/#abstract-methods","title":"Abstract Methods","text":"<p>Abstract methods, are method that HAVE TO be implemented in the child class.</p> <ul> <li>info: returns dataset info (<code>rio_tiler.models.Info</code>)</li> <li>statistics: returns dataset band statistics (<code>Dict[str, rio_tiler.models.BandStatistics]</code>)</li> <li>tile: reads data for a specific XYZ slippy map indexes (<code>rio_tiler.models.ImageData</code>)</li> <li>part: reads specific part of a dataset (<code>rio_tiler.models.ImageData</code>)</li> <li>preview: creates an overview of a dataset (<code>rio_tiler.models.ImageData</code>)</li> <li>point: reads pixel value for a specific point (<code>List</code>)</li> <li>feature: reads data for a geojson feature (<code>rio_tiler.models.ImageData</code>)</li> </ul> <p>Example: <code>Reader</code></p>"},{"location":"advanced/custom_readers/#multibasereader","title":"MultiBaseReader","text":"<p>The goal of the <code>MultiBaseReader</code> is to enable joining results from multiple files (e.g STAC).</p> <p>The <code>MultiBaseReader</code> has the same attributes/properties/methods as the <code>BaseReader</code>.</p> <p>Example: <code>STACReader</code></p> <pre><code>import os\nimport pathlib\nfrom typing import Dict, Type\n\nimport attr\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io.base import MultiBaseReader\nfrom rio_tiler.io import Reader, BaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\nfrom rio_tiler.models import Info\nfrom rio_tiler.types import AssetInfo\nfrom rio_tiler.errors import InvalidAssetName\n\n@attr.s\nclass AssetFileReader(MultiBaseReader):\n\n    input: str = attr.ib()\n    prefix: str = attr.ib() # we add a custom attribute\n\n    # because we add another attribute (prefix) we need to\n    # re-specify the other attribute for the class\n    reader: Type[BaseReader] = attr.ib(default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    # we place min/max zoom in __init__\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    def __attrs_post_init__(self):\n        \"\"\"Parse Sceneid and get grid bounds.\"\"\"\n        self.assets = sorted(\n            [p.stem.split(\"_\")[1] for p in pathlib.Path(self.input).glob(f\"*{self.prefix}*.tif\")]\n        )\n        with self.reader(self._get_asset_info(self.assets[0])[\"url\"]) as cog:\n            self.bounds = cog.bounds\n            self.crs = cog.crs\n            self.transform = cog.transform\n            self.height = cog.height\n            self.width = cog.width\n            if self.minzoom is None:\n                self.minzoom = cog.minzoom\n\n            if self.maxzoom is None:\n                self.maxzoom = cog.maxzoom\n\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        \"\"\"Validate band's name and return band's url.\"\"\"\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        return AssetInfo(url=os.path.join(self.input, f\"{self.prefix}{asset}.tif\"))\n\n# we have a directoty with \"scene_b1.tif\", \"scene_b2.tif\"\nwith AssetFileReader(input=\"my_dir/\", prefix=\"scene_\") as cr:\n    print(cr.assets)\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    info = cr.info(assets=(\"band1\", \"band2\"))\n    # MultiBaseReader returns a Dict\n    assert isinstance(info, dict)\n    print(list(info))\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    assert isinstance(info[\"band1\"], Info)\n    print(info[\"band1\"].model_dump_json(exclude_none=True))\n    &gt;&gt;&gt; {\n        \"bounds\": [\n            199980,\n            2690220,\n            309780,\n            2800020\n        ],\n        \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/32629\",\n        \"band_metadata\": [\n            [\n                \"b1\",\n                {}\n            ]\n        ],\n        \"band_descriptions\": [\n            [\n                \"b1\",\n                \"\"\n            ]\n        ],\n        \"dtype\": \"uint16\",\n        \"nodata_type\": \"Nodata\",\n        \"colorinterp\": [\n            \"gray\"\n        ],\n        \"scales\": [\n            1\n        ],\n        \"offsets\": [\n            0\n        ],\n        \"driver\": \"GTiff\",\n        \"count\": 1,\n        \"width\": 549,\n        \"height\": 549,\n        \"overviews\": [\n            2\n        ],\n        \"nodata_value\": 0\n    }\n    img = cr.tile(238, 218, 9, assets=(\"band1\", \"band2\"))\n\n    print(img.assets)\n    &gt;&gt;&gt; ['my_dir/scene_band1.tif', 'my_dir/scene_band2.tif']\n\n    # Each assets have 1 bands, so when combining each img we get a (2, 256, 256) array.\n    print(img.data.shape)\n    &gt;&gt;&gt; (2, 256, 256)\n</code></pre>"},{"location":"advanced/custom_readers/#multibandsreader","title":"MultiBandsReader","text":"<p>Almost as the previous <code>MultiBaseReader</code>, the <code>MultiBandsReader</code> children will merge results extracted from different file but taking each file as individual bands.</p> <p>The <code>MultiBaseReader</code> has the same attributes/properties/methods as the <code>BaseReader</code>.</p> <p>Example</p> <pre><code>import os\nimport pathlib\nfrom typing import Dict, Type\n\nimport attr\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io.base import MultiBandReader\nfrom rio_tiler.io import COGReader, BaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\n\n@attr.s\nclass BandFileReader(MultiBandReader):\n\n    input: str = attr.ib()\n    prefix: str = attr.ib() # we add a custom attribute\n\n    # because we add another attribute (prefix) we need to\n    # re-specify the other attribute for the class\n    reader: Type[BaseReader] = attr.ib(default=COGReader)\n    reader_options: Dict = attr.ib(factory=dict)\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    # we place min/max zoom in __init__\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    def __attrs_post_init__(self):\n        \"\"\"Parse Sceneid and get grid bounds.\"\"\"\n        self.bands = sorted(\n            [p.stem.split(\"_\")[1] for p in pathlib.Path(self.input).glob(f\"*{self.prefix}*.tif\")]\n        )\n        with self.reader(self._get_band_url(self.bands[0])) as cog:\n            self.bounds = cog.bounds\n            self.crs = cog.crs\n            self.transform = cog.transform\n            self.height = cog.height\n            self.width = cog.width\n            if self.minzoom is None:\n                self.minzoom = cog.minzoom\n\n            if self.maxzoom is None:\n                self.maxzoom = cog.maxzoom\n\n    def _get_band_url(self, band: str) -&gt; str:\n        \"\"\"Validate band's name and return band's url.\"\"\"\n        return os.path.join(self.input, f\"{self.prefix}{band}.tif\")\n\n\n# we have a directoty with \"scene_b1.tif\", \"scene_b2.tif\"\nwith BandFileReader(input=\"my_dir/\", prefix=\"scene_\") as cr:\n    print(cr.bands)\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    print(cr.info(bands=(\"band1\", \"band2\")).model_dump_json(exclude_none=True))\n    &gt;&gt;&gt; {\n        \"bounds\": [\n            199980,\n            2690220,\n            309780,\n            2800020\n        ],\n        \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/32629\",\n        \"band_metadata\": [\n            [\n                \"band1\",\n                {}\n            ],\n            [\n                \"band2\",\n                {}\n            ]\n        ],\n        \"band_descriptions\": [\n            [\n                \"band1\",\n                \"\"\n            ],\n            [\n                \"band2\",\n                \"\"\n            ]\n        ],\n        \"dtype\": \"uint16\",\n        \"nodata_type\": \"Nodata\",\n        \"colorinterp\": [\n            \"gray\",\n            \"gray\"\n        ]\n    }\n\n    img = cr.tile(238, 218, 9, bands=(\"band1\", \"band2\"))\n\n    print(img.assets)\n    &gt;&gt;&gt; ['my_dir/scene_band1.tif', 'my_dir/scene_band2.tif']\n\n    print(img.data.shape)\n    &gt;&gt;&gt; (2, 256, 256)\n</code></pre> <p>Note: <code>rio-tiler-pds</code> readers are built using the <code>MultiBandReader</code> base class.</p>"},{"location":"advanced/custom_readers/#custom-reader-subclass","title":"Custom Reader subclass","text":"<p>The example  was created as a response to developmentseed/titiler?235. In short, the user needed a way to keep metadata information from an asset within a STAC item.</p> <p>Sadly when we are using the STAC Reader we only keep the metadata about the item but not the assets metadata (because we built the STAC Reader with the idea that user might first want to merge assets together).</p> <p>But rio-tiler has been designed to be easily customizable.</p> <pre><code>import attr\nfrom rasterio.io import DatasetReader\nfrom rio_tiler.io.stac import fetch, _to_pystac_item\nfrom rio_tiler.io import Reader\nimport pystac\n\n@attr.s\nclass CustomSTACReader(Reader):\n    \"\"\"Custom Reader support.\"\"\"\n\n    # This will keep the STAC item info within the instance\n    item: pystac.Item = attr.ib(default=None, init=False)\n\n    def __attrs_post_init__(self):\n        \"\"\"Define _kwargs, open dataset and get info.\"\"\"\n        # get STAC item URL and asset name\n        asset = self.input.split(\":\")[-1]\n        stac_url = self.input.replace(f\":{asset}\", \"\")\n\n        # Fetch the STAC item\n        self.item = pystac.Item.from_dict(fetch(stac_url), stac_url)\n\n        # Get asset url from the STAC Item\n        self.input = self.item.assets[asset].get_absolute_href()\n        super().__attrs_post_init__()\n\nwith CustomSTACReader(\"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json:pan\") as cog:\n    print(type(cog.dataset))\n    print(cog.input)\n    print(cog.nodata)\n    print(cog.bounds)\n\n&gt;&gt;&gt; rasterio.io.DatasetReader\n&gt;&gt;&gt; \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/s5_11055_6057_20070622_p10_1_lcc00_cog.tif\"\n&gt;&gt;&gt; 0\n&gt;&gt;&gt; (-869900.0, 1370200.0, -786360.0, 1453180.0)\n</code></pre> <p>In this <code>CustomSTACReader</code>, we are using a custom path <code>schema</code> in form of <code>{item-url}:{asset-name}</code>. When creating an instance of <code>CustomSTACReader</code>, we will do the following:</p> <ol> <li>Parse the input path to get the STAC url and asset name</li> <li>Fetch and parse the STAC item</li> <li>Construct a new <code>input</code> using the asset full url.</li> <li>Fall back to the regular <code>Reader</code> initialization (using <code>super().__attrs_post_init__()</code>)</li> </ol>"},{"location":"advanced/custom_readers/#simple-reader","title":"Simple Reader","text":"<pre><code>from typing import Any, Dict, List\n\nimport attr\nimport rasterio\nfrom rasterio.io import DatasetReader\nfrom rio_tiler.io import BaseReader\nfrom rio_tiler.models import BandStatistics, Info, ImageData\nfrom morecantile import TileMatrixSet\n\nfrom rio_tiler.constants import BBox, WEB_MERCATOR_TMS\n\n@attr.s\nclass SimpleReader(BaseReader):\n\n    input: DatasetReader = attr.ib()\n\n    # We force tms to be outside the class __init__\n    tms: TileMatrixSet = attr.ib(init=False, default=WEB_MERCATOR_TMS)\n\n    def __attrs_post_init__(self):\n        # Set bounds and crs variable\n        self.bounds = self.input.bounds\n        self.crs = self.input.crs\n        self.transform = self.input.transform\n        self.height = self.input.height\n        self.width = self.input.width\n\n    @property\n    def minzoom(self):\n        \"\"\"Return dataset minzoom.\"\"\"\n        return self._minzoom\n\n    @property\n    def maxzoom(self):\n        \"\"\"Return dataset maxzoom.\"\"\"\n        return self._maxzoom\n\n    # implement all mandatory methods\n    def info(self) -&gt; Info:\n        raise NotImplemented\n\n    def statistics(self, **kwargs: Any) -&gt; Dict[str, BandStatistics]:\n        raise NotImplemented\n\n    def part(self, bbox: BBox, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def preview(self, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def point(self, lon: float, lat: float, **kwargs: Any) -&gt; List:\n        raise NotImplemented\n\n    def feature(self, shape: Dict, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def tile(self, tile_x: int, tile_y: int, tile_z: int, **kwargs: Any) -&gt; ImageData:\n        if not self.tile_exists(tile_x, tile_y, tile_z):\n            raise TileOutsideBounds(\n                f\"Tile {tile_z}/{tile_x}/{tile_y} is outside bounds\"\n            )\n\n        tile_bounds = self.tms.xy_bounds(Tile(x=tile_x, y=tile_y, z=tile_z))\n\n        return reader.part(\n            self.input,\n            tile_bounds,\n            width=256,\n            height=256,\n            bounds_crs=tms.rasterio_crs,\n            dst_crs=tms.rasterio_crs,\n            **kwargs,\n        )\n\n\nwith rasterio.open(\"file.tif\") as src:\n    with SimpleReader(src) as cog:\n        img = cog.tile(1, 1, 1)\n</code></pre>"},{"location":"advanced/dynamic_tiler/","title":"Create a Dynamic Tiler","text":"<p><code>rio-tiler</code> aims to be a lightweight plugin for <code>rasterio</code> to read slippy map tiles from a raster sources.</p> <p>Given that <code>rio-tiler</code> allows for simple, efficient reading of tiles, you can then leverage <code>rio-tiler</code> to create a dynamic tile server to display raster tiles on a web map.</p> <p>There are couple tile servers built on top of rio-tiler:</p> <ul> <li><code>titiler</code></li> <li><code>rio-viz</code></li> </ul>"},{"location":"advanced/dynamic_tiler/#example-application","title":"Example Application","text":"<p>To build a simple dynamic tiling application, we can use FastAPI. Note that <code>titiler</code> uses <code>FastAPI</code> internally, so you might consider using <code>titiler</code> instead of making your own API.</p>"},{"location":"advanced/dynamic_tiler/#requirements","title":"Requirements","text":"<ul> <li><code>rio-tiler ~= 4.0</code></li> <li><code>fastapi</code></li> <li><code>uvicorn</code></li> </ul> <p>Install with</p> <pre><code>pip install fastapi uvicorn rio-tiler\n</code></pre>"},{"location":"advanced/dynamic_tiler/#apppy","title":"<code>app.py</code>","text":"<pre><code>\"\"\"rio-tiler tile server.\"\"\"\n\nimport os\n\nfrom fastapi import FastAPI, Query\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom rio_tiler.profiles import img_profiles\nfrom rio_tiler.io import Reader\n\n\napp = FastAPI(\n    title=\"rio-tiler\",\n    description=\"A lightweight Cloud Optimized GeoTIFF tile server\",\n)\n\n\n@app.get(\n    r\"/{z}/{x}/{y}.png\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}}, \"description\": \"Return an image.\",\n        }\n    },\n    response_class=Response,\n    description=\"Read COG and return a tile\",\n)\ndef tile(\n    z: int,\n    x: int,\n    y: int,\n    url: str = Query(..., description=\"Cloud Optimized GeoTIFF URL.\"),\n):\n    \"\"\"Handle tile requests.\"\"\"\n    with Reader(url) as cog:\n        img = cog.tile(x, y, z)\n\n    content = img.render(img_format=\"PNG\", **img_profiles.get(\"png\"))\n    return Response(content, media_type=\"image/png\")\n\n\n@app.get(\"/tilejson.json\", responses={200: {\"description\": \"Return a tilejson\"}})\ndef tilejson(\n    request: Request,\n    url: str = Query(..., description=\"Cloud Optimized GeoTIFF URL.\"),\n):\n    \"\"\"Return TileJSON document for a COG.\"\"\"\n    tile_url = str(request.url_for(\"tile\", z=\"{z}\", x=\"{x}\", y=\"{y}\"))\n    tile_url = f\"{tile_url}?url={url}\"\n\n    with Reader(url) as cog:\n        return {\n            \"bounds\": cog.get_geographic_bounds(cog.tms.rasterio_geographic_crs),\n            \"minzoom\": cog.minzoom,\n            \"maxzoom\": cog.maxzoom,\n            \"name\": os.path.basename(url),\n            \"tiles\": [tile_url],\n        }\n</code></pre>"},{"location":"advanced/dynamic_tiler/#launch-example","title":"Launch Example","text":"<p>Use <code>uvicorn</code> to launch the application. Note that <code>app:app</code> tells <code>uvicorn</code> to call the <code>app</code> function within <code>app.py</code>, so you must be in the same directory as <code>app.py</code>.</p> <pre><code>uvicorn app:app --reload\n</code></pre>"},{"location":"advanced/feature/","title":"Read Polygon-shaped regions","text":"<p>Starting with <code>rio-tiler</code> v2, a <code>.feature()</code> method exists on <code>rio-tiler</code>'s readers (e.g <code>Reader</code>) which enables data reading for GeoJSON defined (polygon or multipolygon) shapes.</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"my-tif.tif\") as cog:\n    # Read data for a given geojson polygon\n    img: ImageData = cog.feature(geojson_feature, max_size=1024)  # we limit the max_size to 1024\n</code></pre> <p>Under the hood, the <code>.feature</code> method uses rasterio's <code>rasterize</code> function and the <code>.part()</code> method. The below process is roughly what <code>.feature</code> does for you.</p> <pre><code>from rasterio.features import rasterize, bounds as featureBounds\n\nfrom rio_tiler.io import Reader\n\n# Use Reader to open and read the dataset\nwith Reader(\"my_tif.tif\") as cog:\n\n    # Get BBOX of the polygon\n    bbox = featureBounds(feat)\n\n    # Read part of the data overlapping with the geometry bbox\n    # assuming that the geometry coordinates are in web mercator\n    img = cog.part(bbox, bounds_crs=f\"EPSG:3857\", max_size=1024)\n\n    # Rasterize geometry using the same geotransform parameters\n    cutline = rasterize(\n        [feat],\n        out_shape=(img.height, img.width),\n        transform=img.transform,\n        ...\n    )\n\n    # Apply geometry mask to imagery\n    img.array.mask = numpy.where(~cutline, img.array.mask, True)\n</code></pre> <p>Another interesting way to cut features is to use the GDALWarpVRT's <code>cutline</code> option with the .part(), .preview(), or .tile() methods:</p> <pre><code>from rio_tiler.utils import create_cutline\n\nbbox = featureBounds(feat)\n\n# Use Reader to open and read the dataset\nwith Reader(\"my_tif.tif\") as cog:\n    # Create WTT Cutline\n    cutline = create_cutline(cog.dataset, feat, geometry_crs=\"epsg:4326\")\n\n    # Get a part of the geotiff but use the cutline to mask the data\n    bbox = featureBounds(feat)\n    img = cog.part(bbox, vrt_options={'cutline': cutline})\n\n    # Get a preview of the whole geotiff but use the cutline to mask the data\n    img = cog.preview(vrt_options={'cutline': cutline})\n\n    # Read a mercator tile and use the cutline to mask the data\n    img = cog.tile(1, 1, 1, vrt_options={'cutline': cutline})\n</code></pre>"},{"location":"advanced/statistics/","title":"Statistics","text":""},{"location":"advanced/statistics/#form-readers","title":"Form <code>Readers</code>","text":"<p><code>rio-tiler</code>'s Readers provide simple <code>.statistics</code> method to retrieve dataset global statistics</p> <pre><code>with Reader(\"my.tif\") as src:\n    stats = src.statistics()\n\n# Statistics result is in form of Dict[str, rio_tiler.models.BandStatistics]\nprint(stats.keys())\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n# rio_tiler.models.BandStatistics is a pydantic model\nprint(stats[\"1\"].model_dump().keys())\n[\n    \"min\",\n    \"max\",\n    \"mean\",\n    \"count\",\n    \"sum\",\n    \"std\",\n    \"median\",\n    \"majority\",\n    \"minority\",\n    \"unique\",\n    \"histogram\",\n    \"valid_percent\",\n    \"masked_pixels\",\n    \"valid_pixels\",\n    # Percentile entries depend on user inputs\n    \"percentile_2\",\n    \"percentile_98\",\n]\n</code></pre>"},{"location":"advanced/statistics/#imagedata","title":"ImageData","text":"<p>You can get statistics from <code>ImageData</code> objects which are returned by all rio-tiler reader methods (e.g. <code>.tile()</code>, <code>.preview()</code>, <code>.part()</code>, ...)</p> <pre><code>with Reader(\"cog.tif\") as src:\n    image = src.preview()\n    stats = image.statistics()\n</code></pre>"},{"location":"advanced/statistics/#area-weighted-statistics","title":"Area Weighted Statistics","text":"<p>When getting statistics from a <code>feature</code>, you may want to calculate values from the pixels which intersect with the geometry but also take the pixel intersection percentage into account. Starting with rio-tiler <code>6.2.0</code>, we've added a <code>coverage</code> option to the <code>statistics</code> utility which enable the user to pass an array representing the coverage percentage such as:</p> <pre><code>import numpy as np\nfrom rio_tiler.utils import get_array_statistics\n\n# Data Array\n# 1, 2\n# 3, 4\ndata = np.ma.array((1, 2, 3, 4)).reshape((1, 2, 2))\n\n# Coverage Array\n# 0.5, 0\n# 1, 0.25\ncoverage = np.array((0.5, 0, 1, 0.25)).reshape((2, 2))\n\nstats = get_array_statistics(data, coverage=coverage)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert (\n    round(stats[0][\"mean\"], 4) == 2.5714\n)  # sum of weighted array / sum of weights | 4.5 / 1.75 = 2.57\nassert stats[0][\"count\"] == 1.75\n</code></pre>"},{"location":"advanced/statistics/#adjusting-geometry-align_bounds_with_datasettrue","title":"Adjusting geometry <code>align_bounds_with_dataset=True</code>","text":"<p>In rio-tiler <code>6.3,0</code> a new option has been introduced to reduce artifacts and produce more precise zonal statistics. This option is available in the low-level <code>reader.part()</code> method used in rio-tiler reader's <code>.feature()</code> and <code>.part()</code> methods.</p> <pre><code>with Reader(\"cog.tif\") as src:\n    data = src.feature(\n        shape,\n        shape_crs=WGS84_CRS,\n        align_bounds_with_dataset=True,\n    )\n\n    coverage_array = data.get_coverage_array(\n        shape,\n        shape_crs=WGS84_CRS,\n    )\n\n    stats = data.statistics(coverage=coverage_array)\n</code></pre> <p>When passing <code>align_bounds_with_dataset=True</code> to the <code>reader.part()</code> method (forwarded from <code>.feature</code> or <code>.part</code> reader methods), rio-tiler will adjust the input geometry bounds to match the input dataset resolution/transform and avoid unnecessary resampling.</p> <p></p>"},{"location":"advanced/statistics/#zonal-statistics-method","title":"Zonal Statistics method","text":"<p>You can easily extend the rio-tiler's reader to add a <code>.zonal_statistics()</code> method as:</p> <pre><code>import attr\nfrom typing import Any, Union, Optional, List, Dict\n\nfrom rio_tiler import io\nfrom rio_tiler.models import BandStatistics\nfrom rio_tiler.constants import WGS84_CRS\n\nfrom geojson_pydantic.features import Feature, FeatureCollection\nfrom geojson_pydantic.geometries import Polygon\n\nclass Reader(io.Reader):\n    \"\"\"Custom Reader with zonal_statistics method.\"\"\"\n\n    def zonal_statistics(\n        self,\n        geojson: Union[FeatureCollection, Feature],\n        categorical: bool = False,\n        categories: Optional[List[float]] = None,\n        percentiles: Optional[List[int]] = None,\n        hist_options: Optional[Dict] = None,\n        max_size: int = None,\n        **kwargs: Any,\n    ) -&gt; Union[FeatureCollection, Feature]:\n        \"\"\"Return statistics from GeoJSON features.\n\n        Args:\n            geojson (Feature or FeatureCollection): a GeoJSON Feature or FeatureCollection.\n            categorical (bool): treat input data as categorical data. Defaults to False.\n            categories (list of numbers, optional): list of categories to return value for.\n            percentiles (list of numbers, optional): list of percentile values to calculate. Defaults to `[2, 98]`.\n            hist_options (dict, optional): Options to forward to numpy.histogram function.\n            max_size (int, optional): Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to None.\n            kwargs (optional): Options to forward to `self.preview`.\n\n        Returns:\n            Feature or FeatureCollection\n\n        \"\"\"\n        kwargs = {**self.options, **kwargs}\n\n        hist_options = hist_options or {}\n\n        fc = geojson\n        # We transform the input Feature to a FeatureCollection\n        if isinstance(fc, Feature):\n            fc = FeatureCollection(type=\"FeatureCollection\", features=[geojson])\n\n        for feature in fc:\n            geom = feature.model_dump(exclude_none=True)\n\n            # Get data overlapping with the feature (using Reader.feature method)\n            data = self.feature(\n                geom,\n                shape_crs=WGS84_CRS,\n                align_bounds_with_dataset=True,\n                max_size=max_size,\n                **kwargs,\n            )\n            coverage_array = data.get_coverage_array(\n                geom,\n                shape_crs=WGS84_CRS,\n            )\n\n            stats = data.statistics(\n                categorical=categorical,\n                categories=categories,\n                percentiles=percentiles,\n                hist_options=hist_options,\n                coverage=coverage_array,\n            )\n\n            # Update input feature properties and add the statistics\n            feature.properties = feature.properties or {}\n            feature.properties.update({\"statistics\": stats})\n\n        return fc.features[0] if isinstance(geojson, Feature) else fc\n</code></pre>"},{"location":"advanced/tms/","title":"TileMatrixSet","text":"<p>Starting with rio-tiler 2.0, we replaced <code>mercantile</code> with <code>morecantile</code>, enabling support for other TileMatrixSets than the default WebMercator grid.</p> <pre><code>import morecantile\nfrom rio_tiler.io import Reader\nfrom rasterio.crs import CRS\nfrom pyproj import CRS as projCRS\n\n# By default we use WebMercator TMS\nwith Reader(\"my.tif\") as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(3857)  # default image output is the TMS crs (WebMercator)\n\n# Print default grids\nfor name in morecantile.tms.list():\n    print(name, \"-\", morecantile.tms.get(name).rasterio_crs)\n\n&gt;&gt;&gt; CanadianNAD83_LCC - EPSG:3978\n    EuropeanETRS89_LAEAQuad - EPSG:3035\n    LINZAntarticaMapTilegrid - EPSG:5482\n    NZTM2000Quad - EPSG:2193\n    UPSAntarcticWGS84Quad - EPSG:5042\n    UPSArcticWGS84Quad - EPSG:5041\n    UTM31WGS84Quad - EPSG:32631\n    WGS1984Quad - EPSG:4326\n    WebMercatorQuad - EPSG:3857\n    WorldCRS84Quad - OGC:CRS84\n    WorldMercatorWGS84Quad - EPSG:3395\n\n\n# Use EPSG:4326 (WGS84) grid\nwgs84_grid = morecantile.tms.get(\"WorldCRS84Quad\")\nwith Reader(\"my.tif\", tms=wgs84_grid) as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(4326)\n\n# Create Custom grid\nextent = [-948.75, -543592.47, 5817.41, -3333128.95]  # From https:///epsg.io/3031\nepsg3031TMS = morecantile.TileMatrixSet.custom(\n    extent, projCRS.from_epsg(3031), identifier=\"MyCustomTmsEPSG3031\"\n)\nwith Reader(\"my.tif\", tms=epsg3031TMS) as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(3031)\n</code></pre>"},{"location":"api/rio_tiler/colormap/","title":"rio_tiler.colormap","text":""},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap","title":"rio_tiler.colormap","text":"<p>rio-tiler colormap functions and classes.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.ColorMaps","title":"ColorMaps","text":"<p>Default Colormaps holder.</p> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>colormaps. Defaults to <code>rio_tiler.colormap.DEFAULTS_CMAPS</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.ColorMaps.get","title":"get","text":"<pre><code>get(name: str) -&gt; ColorMapType\n</code></pre> <p>Fetch a colormap.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>colormap name.</p> </li> </ul> <p>Returns     dict: colormap dictionary.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.ColorMaps.list","title":"list","text":"<pre><code>list() -&gt; List[str]\n</code></pre> <p>List registered Colormaps.</p> <p>Returns     list: list of colormap names.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.ColorMaps.register","title":"register","text":"<pre><code>register(custom_cmap: Dict[str, Union[str, Path, ColorMapType]], overwrite: bool = False) -&gt; ColorMaps\n</code></pre> <p>Register a custom colormap.</p> <p>Parameters:</p> <ul> <li> <code>custom_cmap</code>               (<code>dict</code>)           \u2013            <p>custom colormap(s) to register.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Overwrite existing colormap with same key. Defaults to False.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cmap = cmap.register({\"acmap\": {0: (0, 0, 0, 0), ...}})\n</code></pre> <pre><code>&gt;&gt;&gt; cmap = cmap.register({\"acmap\": \"acmap.npy\"})\n</code></pre>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap._remove_value","title":"_remove_value","text":"<pre><code>_remove_value(cmap: GDALColorMapType, idx: Sequence[int]) -&gt; None\n</code></pre> <p>Remove value from a colormap dict.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap._update_alpha","title":"_update_alpha","text":"<pre><code>_update_alpha(cmap: GDALColorMapType, idx: Sequence[int], alpha: int = 0) -&gt; None\n</code></pre> <p>Update the alpha value of a colormap index.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap._update_cmap","title":"_update_cmap","text":"<pre><code>_update_cmap(cmap: GDALColorMapType, values: GDALColorMapType) -&gt; None\n</code></pre> <p>Update a colormap dict.</p>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.apply_cmap","title":"apply_cmap","text":"<pre><code>apply_cmap(data: ndarray, colormap: ColorMapType) -&gt; DataMaskType\n</code></pre> <p>Apply colormap on data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>1D image array to translate to RGB.</p> </li> <li> <code>colormap</code>               (<code>dict or sequence</code>)           \u2013            <p>GDAL RGBA Color Table dictionary or sequence (for intervals).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>DataMaskType</code> )          \u2013            <p>Data (numpy.ndarray) and Mask (numpy.ndarray) values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>InvalidFormat</code>             \u2013            <p>If data is not a 1 band dataset (1, col, row).</p> </li> </ul>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.apply_discrete_cmap","title":"apply_discrete_cmap","text":"<pre><code>apply_discrete_cmap(data: ndarray, colormap: Union[GDALColorMapType, DiscreteColorMapType]) -&gt; DataMaskType\n</code></pre> <p>Apply discrete colormap.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>1D image array to translate to RGB.</p> </li> <li> <code>colormap</code>               (<code>GDALColorMapType or DiscreteColorMapType</code>)           \u2013            <p>Discrete ColorMap dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>DataMaskType</code> )          \u2013            <p>Data (numpy.ndarray) and Alpha band (numpy.ndarray).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = numpy.random.randint(0, 3, size=(1, 256, 256))\n    cmap = {\n        0: (0, 0, 0, 0),\n        1: (255, 255, 255, 255),\n        2: (255, 0, 0, 255),\n        3: (255, 255, 0, 255),\n    }\n    data, mask = apply_discrete_cmap(data, cmap)\n    assert data.shape == (3, 256, 256)\n</code></pre>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.apply_intervals_cmap","title":"apply_intervals_cmap","text":"<pre><code>apply_intervals_cmap(data: ndarray, colormap: IntervalColorMapType) -&gt; DataMaskType\n</code></pre> <p>Apply intervals colormap.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>1D image array to translate to RGB.</p> </li> <li> <code>colormap</code>               (<code>IntervalColorMapType</code>)           \u2013            <p>Sequence of intervals and color in form of [([min, max], [r, g, b, a]), ...].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>DataMaskType</code> )          \u2013            <p>Data (numpy.ndarray) and Alpha band (numpy.ndarray).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = numpy.random.randint(0, 3, size=(1, 256, 256))\n    cmap = [\n        ((0, 1), (0, 0, 0, 0)),\n        ((1, 2), (255, 255, 255, 255)),\n        ((2, 3), (255, 0, 0, 255)),\n        ((3, 4), (255, 255, 0, 255)),\n    ]\n</code></pre> <pre><code>data, mask = apply_intervals_cmap(data, cmap)\nassert data.shape == (3, 256, 256)\n</code></pre>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.make_lut","title":"make_lut","text":"<pre><code>make_lut(colormap: GDALColorMapType) -&gt; ndarray\n</code></pre> <p>Create a lookup table numpy.ndarray from a GDAL RGBA Color Table dictionary.</p> <p>Parameters:</p> <ul> <li> <code>colormap</code>               (<code>dict</code>)           \u2013            <p>GDAL RGBA Color Table dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>numpy.ndarray: colormap lookup table.</p> </li> </ul>"},{"location":"api/rio_tiler/colormap/#rio_tiler.colormap.parse_color","title":"parse_color","text":"<pre><code>parse_color(rgba: Union[Sequence[int], str]) -&gt; Tuple[int, int, int, int]\n</code></pre> <p>Parse RGB/RGBA color and return valid rio-tiler compatible RGBA colormap entry.</p> <p>Parameters:</p> <ul> <li> <code>rgba</code>               (<code>str or list of int</code>)           \u2013            <p>HEX encoded or list RGB or RGBA colors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[int, int, int, int]</code> )          \u2013            <p>RGBA values.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_color(\"#FFF\")\n(255, 255, 255, 255)\n</code></pre> <pre><code>&gt;&gt;&gt; parse_color(\"#FF0000FF\")\n(255, 0, 0, 255)\n</code></pre> <pre><code>&gt;&gt;&gt; parse_color(\"#FF0000\")\n(255, 0, 0, 255)\n</code></pre> <pre><code>&gt;&gt;&gt; parse_color([255, 255, 255])\n(255, 255, 255, 255)\n</code></pre>"},{"location":"api/rio_tiler/constants/","title":"rio_tiler.constants","text":""},{"location":"api/rio_tiler/constants/#rio_tiler.constants","title":"rio_tiler.constants","text":"<p>rio-tiler constant values.</p>"},{"location":"api/rio_tiler/errors/","title":"rio_tiler.errors","text":""},{"location":"api/rio_tiler/errors/#rio_tiler.errors","title":"rio_tiler.errors","text":"<p>Errors and warnings.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.AlphaBandWarning","title":"AlphaBandWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Automatically removed Alpha band from output array.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.AssetAsBandError","title":"AssetAsBandError","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Can't use asset_as_band with multiple bands.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.ColorMapAlreadyRegistered","title":"ColorMapAlreadyRegistered","text":"<p>               Bases: <code>RioTilerError</code></p> <p>ColorMap is already registered.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.EmptyMosaicError","title":"EmptyMosaicError","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Mosaic method returned empty array.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.ExpressionMixingWarning","title":"ExpressionMixingWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Expression and assets/indexes mixing.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidAssetName","title":"InvalidAssetName","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid Asset name.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidBandName","title":"InvalidBandName","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid band name.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidBufferSize","title":"InvalidBufferSize","text":"<p>               Bases: <code>RioTilerError</code></p> <p><code>buffer</code> must be a multiple of <code>0.5</code> (e.g: 0.5, 1, 1.5, ...).</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidColorFormat","title":"InvalidColorFormat","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid color format.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidColorMapName","title":"InvalidColorMapName","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid colormap name.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidDatatypeWarning","title":"InvalidDatatypeWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Invalid Output Datatype.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidExpression","title":"InvalidExpression","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid Expression.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidFormat","title":"InvalidFormat","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid image format.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidGeographicBounds","title":"InvalidGeographicBounds","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid Geographic bounds.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidMosaicMethod","title":"InvalidMosaicMethod","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid Pixel Selection method for mosaic.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.InvalidPointDataError","title":"InvalidPointDataError","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Invalid PointData.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.MaxArraySizeError","title":"MaxArraySizeError","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Trying to load to many pixels in memory.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.MissingAssets","title":"MissingAssets","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Missing Assets.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.MissingBands","title":"MissingBands","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Missing bands.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.MissingCRS","title":"MissingCRS","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Dataset doesn't have CRS information.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.NoOverviewWarning","title":"NoOverviewWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Dataset has no overviews.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.PointOutsideBounds","title":"PointOutsideBounds","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Point is outside image bounds.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.RioTilerError","title":"RioTilerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.RioTilerExperimentalWarning","title":"RioTilerExperimentalWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>A rio-tiler specific experimental functionality warning.</p>"},{"location":"api/rio_tiler/errors/#rio_tiler.errors.TileOutsideBounds","title":"TileOutsideBounds","text":"<p>               Bases: <code>RioTilerError</code></p> <p>Z-X-Y Tile is outside image bounds.</p>"},{"location":"api/rio_tiler/expression/","title":"rio_tiler.expression","text":""},{"location":"api/rio_tiler/expression/#rio_tiler.expression","title":"rio_tiler.expression","text":"<p>rio-tiler.expression: Parse and Apply expression.</p>"},{"location":"api/rio_tiler/expression/#rio_tiler.expression.apply_expression","title":"apply_expression","text":"<pre><code>apply_expression(blocks: Sequence[str], bands: Sequence[str], data: ndarray) -&gt; MaskedArray\n</code></pre> <p>Apply rio-tiler expression.</p> <p>Args:</p> <pre><code>blocks (sequence): expression for a specific layer.\nbands (sequence): bands names.\ndata (numpy.array):  array of bands.\n</code></pre> <p>Returns:</p> <ul> <li> <code>MaskedArray</code>           \u2013            <p>numpy.array: output data.</p> </li> </ul>"},{"location":"api/rio_tiler/expression/#rio_tiler.expression.get_expression_blocks","title":"get_expression_blocks","text":"<pre><code>get_expression_blocks(expression: str) -&gt; List[str]\n</code></pre> <p>Split expression in blocks.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>str</code>)           \u2013            <p>band math/combination expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>List[str]</code> )          \u2013            <p>expression blocks (str).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_expression_blocks(\"b1/b2;b2+b1\")\n    ['b1/b2', 'b2+b1']\n</code></pre>"},{"location":"api/rio_tiler/expression/#rio_tiler.expression.parse_expression","title":"parse_expression","text":"<pre><code>parse_expression(expression: str, cast: bool = True) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression and extract bands.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>str</code>)           \u2013            <p>band math/combination expression.</p> </li> <li> <code>cast</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>cast band names to integers (convert to index values). Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple</code> )          \u2013            <p>band names/indexes.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_expression(\"b1+b2\")\n    (1, 2)\n</code></pre> <pre><code>&gt;&gt;&gt; parse_expression(\"B1/B2\", cast=False)\n    ('1', '2')\n</code></pre>"},{"location":"api/rio_tiler/models/","title":"rio_tiler.models","text":""},{"location":"api/rio_tiler/models/#rio_tiler.models","title":"rio_tiler.models","text":"<p>rio-tiler models.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.BandStatistics","title":"BandStatistics","text":"<p>               Bases: <code>BaseModel</code></p> <p>Band statistics</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.Bounds","title":"Bounds","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataset Bounding box</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData","title":"ImageData","text":"<p>Image Data class.</p> <p>Attributes:</p> <ul> <li> <code>array</code>               (<code>MaskedArray</code>)           \u2013            <p>image values.</p> </li> <li> <code>assets</code>               (<code>list</code>)           \u2013            <p>list of assets used to construct the data values.</p> </li> <li> <code>bounds</code>               (<code>BoundingBox</code>)           \u2013            <p>bounding box of the data.</p> </li> <li> <code>crs</code>               (<code>CRS</code>)           \u2013            <p>Coordinates Reference System of the bounds.</p> </li> <li> <code>metadata</code>               (<code>dict</code>)           \u2013            <p>Additional metadata. Defaults to <code>{}</code>.</p> </li> <li> <code>band_names</code>               (<code>list</code>)           \u2013            <p>name of each band. Defaults to <code>[\"b1\", \"b2\", \"b3\"]</code> for 3 bands image.</p> </li> <li> <code>dataset_statistics</code>               (<code>list</code>)           \u2013            <p>dataset statistics <code>[(min, max), (min, max)]</code></p> </li> </ul> <p>Note: <code>mask</code> should be considered as <code>PER_BAND</code> so shape should be similar as the data</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData._mask","title":"_mask  <code>property</code>","text":"<pre><code>_mask\n</code></pre> <p>Return <code>inverted/merged</code> mask from data array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>Number of band.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Return data part of the masked array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Height of the data array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.mask","title":"mask  <code>property</code>","text":"<pre><code>mask: ndarray\n</code></pre> <p>Return Mask in form of rasterio dataset mask.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>Returns the affine transform.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>Width of the data array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow for variable expansion (<code>arr, mask = ImageData</code>)</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData._check_alpha_mask","title":"_check_alpha_mask","text":"<pre><code>_check_alpha_mask(attribute, value)\n</code></pre> <p>Make sure alpha mask has valid shame and datatype.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.apply_color_formula","title":"apply_color_formula","text":"<pre><code>apply_color_formula(color_formula: Optional[str]) -&gt; Self\n</code></pre> <p>Apply color-operations formula in place.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.apply_colormap","title":"apply_colormap","text":"<pre><code>apply_colormap(colormap: ColorMapType) -&gt; ImageData\n</code></pre> <p>Apply colormap to the image data.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.apply_expression","title":"apply_expression","text":"<pre><code>apply_expression(expression: str) -&gt; ImageData\n</code></pre> <p>Apply expression to the image data.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.clip","title":"clip","text":"<pre><code>clip(bbox: BBox) -&gt; ImageData\n</code></pre> <p>Clip data and mask to a bbox.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.create_from_list","title":"create_from_list  <code>classmethod</code>","text":"<pre><code>create_from_list(data: Sequence[ImageData]) -&gt; Self\n</code></pre> <p>Create ImageData from a sequence of ImageData objects.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sequence</code>)           \u2013            <p>sequence of ImageData.</p> </li> </ul>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.data_as_image","title":"data_as_image","text":"<pre><code>data_as_image() -&gt; ndarray\n</code></pre> <p>Return the data array reshaped into an image processing/visualization software friendly order.</p> <p>(bands, rows, columns) -&gt; (rows, columns, bands).</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(data: bytes) -&gt; Self\n</code></pre> <p>Create ImageData from bytes.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>raster dataset as bytes.</p> </li> </ul>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.get_coverage_array","title":"get_coverage_array","text":"<pre><code>get_coverage_array(shape: Dict, shape_crs: CRS = WGS84_CRS, cover_scale: int = 10) -&gt; NDArray[floating]\n</code></pre> <p>Get Coverage array for a Geometry.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Dict</code>)           \u2013            <p>GeoJSON geometry or Feature.</p> </li> <li> <code>shape_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Coordinates Reference System of shape.</p> </li> <li> <code>cover_scale</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Scale used when generating coverage estimates of each raster cell by vector feature. Coverage is generated by rasterizing the feature at a finer resolution than the raster then using a summation to aggregate to the raster resolution and dividing by the square of cover_scale to get coverage value for each cell. Increasing cover_scale will increase the accuracy of coverage values; three orders magnitude finer resolution (cover_scale=1000) is usually enough to get coverage estimates with &lt;1% error in individual edge cells coverage estimates, though much smaller values (e.g., cover_scale=10) are often sufficient (&lt;10% error) and require less memory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[floating]</code>           \u2013            <p>numpy.array: percent coverage.</p> </li> </ul> <p>Note: code adapted from perrygeo/python-rasterstats!136 by @sgoodm</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.post_process","title":"post_process","text":"<pre><code>post_process(in_range: Optional[Sequence[IntervalTuple]] = None, out_dtype: Union[str, number] = 'uint8', color_formula: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Post-process image data.</p> <p>Parameters:</p> <ul> <li> <code>in_range</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>input min/max bounds value to rescale from.</p> </li> <li> <code>out_dtype</code>               (<code>str</code>, default:                   <code>'uint8'</code> )           \u2013            <p>output datatype after rescaling. Defaults to <code>uint8</code>.</p> </li> <li> <code>color_formula</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>color-ops formula (see: vincentsarago/color-ops).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>keyword arguments to forward to <code>rio_tiler.utils.linear_rescale</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code> (              <code>ImageData</code> )          \u2013            <p>new ImageData object with the updated data.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; img.post_process(in_range=((0, 16000), ))\n</code></pre> <pre><code>&gt;&gt;&gt; img.post_process(color_formula=\"Gamma RGB 4.1\")\n</code></pre>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.render","title":"render","text":"<pre><code>render(add_mask: bool = True, img_format: str = 'PNG', colormap: Optional[ColorMapType] = None, **kwargs) -&gt; bytes\n</code></pre> <p>Render data to image blob.</p> <p>Parameters:</p> <ul> <li> <code>add_mask</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>add mask to output image. Defaults to <code>True</code>.</p> </li> <li> <code>img_format</code>               (<code>str</code>, default:                   <code>'PNG'</code> )           \u2013            <p>output image format. Defaults to <code>PNG</code>.</p> </li> <li> <code>colormap</code>               (<code>dict or sequence</code>, default:                   <code>None</code> )           \u2013            <p>RGBA Color Table dictionary or sequence.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>keyword arguments to forward to <code>rio_tiler.utils.render</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>image.</p> </li> </ul>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.reproject","title":"reproject","text":"<pre><code>reproject(dst_crs: CRS, resolution: Optional[Tuple[float, float]] = None, reproject_method: WarpResampling = 'nearest') -&gt; ImageData\n</code></pre> <p>Reproject data and mask.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.rescale","title":"rescale","text":"<pre><code>rescale(in_range: Sequence[IntervalTuple], out_range: Sequence[IntervalTuple] = ((0, 255),), out_dtype: Union[str, number] = 'uint8') -&gt; Self\n</code></pre> <p>Rescale data in place.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.resize","title":"resize","text":"<pre><code>resize(height: int, width: int, resampling_method: RIOResampling = 'nearest') -&gt; ImageData\n</code></pre> <p>Resize data and mask.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.statistics","title":"statistics","text":"<pre><code>statistics(categorical: bool = False, categories: Optional[List[float]] = None, percentiles: Optional[List[int]] = None, hist_options: Optional[Dict] = None, coverage: Optional[ndarray] = None) -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return statistics from ImageData.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.ImageData.to_raster","title":"to_raster","text":"<pre><code>to_raster(dst_path: str, *, driver: str = 'GTIFF', **kwargs: Any) -&gt; None\n</code></pre> <p>Save ImageData array to file.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.Info","title":"Info","text":"<p>               Bases: <code>Bounds</code></p> <p>Dataset Info.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData","title":"PointData","text":"<p>Point Data class.</p> <p>Attributes:</p> <ul> <li> <code>array</code>               (<code>MaskedArray</code>)           \u2013            <p>pixel values.</p> </li> <li> <code>band_names</code>               (<code>list</code>)           \u2013            <p>name of each band. Defaults to <code>[\"1\", \"2\", \"3\"]</code> for 3 bands image.</p> </li> <li> <code>coordinates</code>               (<code>tuple</code>)           \u2013            <p>Point's coordinates.</p> </li> <li> <code>crs</code>               (<code>CRS</code>)           \u2013            <p>Coordinates Reference System of the bounds.</p> </li> <li> <code>assets</code>               (<code>list</code>)           \u2013            <p>list of assets used to construct the data values.</p> </li> <li> <code>metadata</code>               (<code>dict</code>)           \u2013            <p>Additional metadata. Defaults to <code>{}</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData._mask","title":"_mask  <code>property</code>","text":"<pre><code>_mask\n</code></pre> <p>Return <code>inverted/merged</code> mask from data array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>Number of band.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Return data part of the masked array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.mask","title":"mask  <code>property</code>","text":"<pre><code>mask: ndarray\n</code></pre> <p>Return Mask in form of rasterio dataset mask.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow for variable expansion.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData._validate_coordinates","title":"_validate_coordinates","text":"<pre><code>_validate_coordinates(attribute, value)\n</code></pre> <p>coordinates has to be a 2d list.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData._validate_data","title":"_validate_data","text":"<pre><code>_validate_data(attribute, value)\n</code></pre> <p>PointsData data has to be a 1d array.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.apply_expression","title":"apply_expression","text":"<pre><code>apply_expression(expression: str) -&gt; PointData\n</code></pre> <p>Apply expression to the image data.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.PointData.create_from_list","title":"create_from_list  <code>classmethod</code>","text":"<pre><code>create_from_list(data: Sequence[PointData]) -&gt; Self\n</code></pre> <p>Create PointData from a sequence of PointsData objects.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sequence</code>)           \u2013            <p>sequence of PointData.</p> </li> </ul>"},{"location":"api/rio_tiler/models/#rio_tiler.models.masked_and_3d","title":"masked_and_3d","text":"<pre><code>masked_and_3d(array: ndarray) -&gt; MaskedArray\n</code></pre> <p>Makes sure we have a 3D array and mask</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.rescale_image","title":"rescale_image","text":"<pre><code>rescale_image(array: MaskedArray, in_range: Sequence[IntervalTuple], out_range: Sequence[IntervalTuple] = ((0, 255),), out_dtype: Union[str, number] = 'uint8') -&gt; MaskedArray\n</code></pre> <p>Rescale image data in-place.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.to_coordsbbox","title":"to_coordsbbox","text":"<pre><code>to_coordsbbox(bbox) -&gt; Optional[BoundingBox]\n</code></pre> <p>Convert bbox to CoordsBbox nameTuple.</p>"},{"location":"api/rio_tiler/models/#rio_tiler.models.to_masked","title":"to_masked","text":"<pre><code>to_masked(array: ndarray) -&gt; MaskedArray\n</code></pre> <p>Makes sure we have a MaskedArray.</p>"},{"location":"api/rio_tiler/profiles/","title":"rio_tiler.profiles","text":""},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles","title":"rio_tiler.profiles","text":"<p>Image file profiles.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.ImagesProfiles","title":"ImagesProfiles","text":"<p>               Bases: <code>UserDict</code></p> <p>GDAL Image creation options.</p> <p>ref: github.com/mapnik/mapnik/wiki/Image-IO#default-output-details.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.ImagesProfiles.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Like normal item access but return a copy of the key.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.ImagesProfiles.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialize ImagesProfiles dict.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.ImagesProfiles.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Like normal item access but return a copy of the key.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.JPEGProfile","title":"JPEGProfile","text":"<p>               Bases: <code>Profile</code></p> <p>JPEG creation options ref: www.gdal.org/frmt_jpeg.html.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.PNGProfile","title":"PNGProfile","text":"<p>               Bases: <code>Profile</code></p> <p>PNG creation options ref: www.gdal.org/frmt_png.html.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.PNGRAWProfile","title":"PNGRAWProfile","text":"<p>               Bases: <code>Profile</code></p> <p>PNG creation options ref: www.gdal.org/frmt_png.html.</p>"},{"location":"api/rio_tiler/profiles/#rio_tiler.profiles.WEBPProfile","title":"WEBPProfile","text":"<p>               Bases: <code>Profile</code></p> <p>WEBP creation options ref: www.gdal.org/frmt_webp.html.</p>"},{"location":"api/rio_tiler/reader/","title":"rio_tiler.reader","text":""},{"location":"api/rio_tiler/reader/#rio_tiler.reader","title":"rio_tiler.reader","text":"<p>rio-tiler.reader: low level reader.</p>"},{"location":"api/rio_tiler/reader/#rio_tiler.reader.Options","title":"Options","text":"<p>               Bases: <code>TypedDict</code></p> <p>Reader Options.</p>"},{"location":"api/rio_tiler/reader/#rio_tiler.reader._apply_buffer","title":"_apply_buffer","text":"<pre><code>_apply_buffer(buffer: float, bounds: BBox, height: int, width: int) -&gt; Tuple[BBox, int, int]\n</code></pre> <p>Apply buffer on bounds.</p>"},{"location":"api/rio_tiler/reader/#rio_tiler.reader.part","title":"part","text":"<pre><code>part(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], bounds: BBox, height: Optional[int] = None, width: Optional[int] = None, max_size: Optional[int] = None, dst_crs: Optional[CRS] = None, bounds_crs: Optional[CRS] = None, indexes: Optional[Indexes] = None, minimum_overlap: Optional[float] = None, padding: Optional[int] = None, buffer: Optional[float] = None, nodata: Optional[NoData] = None, vrt_options: Optional[Dict] = None, out_dtype: Optional[Union[str, dtype]] = None, align_bounds_with_dataset: bool = False, resampling_method: RIOResampling = 'nearest', reproject_method: WarpResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; ImageData\n</code></pre> <p>Read part of a dataset.</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>bounds</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top). By default the coordinates are considered to be in either the dataset CRS or in the <code>dst_crs</code> if set. Use <code>bounds_crs</code> to set a specific CRS.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the image.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the image.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit output size image if not width and height.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Target coordinate reference system.</p> </li> <li> <code>bounds_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite bounds Coordinate Reference System.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>minimum_overlap</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Minimum % overlap for which to raise an error with dataset not covering enough of the tile.</p> </li> <li> <code>padding</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Padding to apply to each bbox edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</p> </li> <li> <code>buffer</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Buffer to apply to each bbox edge. Defaults to <code>0.</code>.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>vrt_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to be passed to the rasterio.warp.WarpedVRT class.</p> </li> <li> <code>align_bounds_with_dataset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Align input bounds with dataset transform. Defaults to <code>False</code>.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>ImageData</p> </li> </ul>"},{"location":"api/rio_tiler/reader/#rio_tiler.reader.point","title":"point","text":"<pre><code>point(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], coordinates: Tuple[float, float], indexes: Optional[Indexes] = None, coord_crs: CRS = WGS84_CRS, nodata: Optional[NoData] = None, vrt_options: Optional[Dict] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', reproject_method: WarpResampling = 'nearest', interpolate: bool = False, unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; PointData\n</code></pre> <p>Read a pixel value for a point.</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>coordinates</code>               (<code>tuple</code>)           \u2013            <p>Coordinates in form of (X, Y).</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>coord_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>vrt_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to be passed to the rasterio.warp.WarpedVRT class.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Only used when <code>interpolate=True</code>. Defaults to <code>nearest</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>interpolate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Interpolate pixels around the coordinates. Defaults to <code>False</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/reader/#rio_tiler.reader.read","title":"read","text":"<pre><code>read(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], dst_crs: Optional[CRS] = None, height: Optional[int] = None, width: Optional[int] = None, max_size: Optional[int] = None, indexes: Optional[Indexes] = None, window: Optional[Window] = None, nodata: Optional[NoData] = None, vrt_options: Optional[Dict] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', reproject_method: WarpResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; ImageData\n</code></pre> <p>Low level read function.</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Target coordinate reference system.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the image.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the image.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit output size image if not width and height.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>window</code>               (<code>Window</code>, default:                   <code>None</code> )           \u2013            <p>Window to read.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>vrt_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to be passed to the rasterio.warp.WarpedVRT class.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>ImageData</p> </li> </ul>"},{"location":"api/rio_tiler/tasks/","title":"rio_tiler.tasks","text":""},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks","title":"rio_tiler.tasks","text":"<p>rio_tiler.tasks: tools for handling rio-tiler's future tasks.</p>"},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks.create_tasks","title":"create_tasks","text":"<pre><code>create_tasks(reader: Callable, asset_list: Sequence, threads: int, *args, **kwargs) -&gt; TaskType\n</code></pre> <p>Create Future Tasks.</p>"},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks.filter_tasks","title":"filter_tasks","text":"<pre><code>filter_tasks(tasks: TaskType, allowed_exceptions: Optional[Tuple] = None) -&gt; Generator\n</code></pre> <p>Filter Tasks to remove Exceptions.</p> <p>Parameters:</p> <ul> <li> <code>tasks</code>               (<code>sequence</code>)           \u2013            <p>Sequence of 'concurrent.futures._base.Future' or 'Callable'</p> </li> <li> <code>allowed_exceptions</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>List of exceptions which won't be raised.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator</code>           \u2013            <p>Task results.</p> </li> </ul>"},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks.multi_arrays","title":"multi_arrays","text":"<pre><code>multi_arrays(asset_list: Sequence, reader: Callable[..., ImageData], *args: Any, threads: int = MAX_THREADS, allowed_exceptions: Optional[Tuple] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Merge arrays returned from tasks.</p>"},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks.multi_points","title":"multi_points","text":"<pre><code>multi_points(asset_list: Sequence, reader: Callable[..., PointData], *args: Any, threads: int = MAX_THREADS, allowed_exceptions: Optional[Tuple] = None, **kwargs: Any) -&gt; PointData\n</code></pre> <p>Merge points returned from tasks.</p>"},{"location":"api/rio_tiler/tasks/#rio_tiler.tasks.multi_values","title":"multi_values","text":"<pre><code>multi_values(asset_list: Sequence, reader: Callable, *args: Any, threads: int = MAX_THREADS, allowed_exceptions: Optional[Tuple] = None, **kwargs: Any) -&gt; Dict\n</code></pre> <p>Merge values returned from tasks.</p>"},{"location":"api/rio_tiler/utils/","title":"rio_tiler.utils","text":""},{"location":"api/rio_tiler/utils/#rio_tiler.utils","title":"rio_tiler.utils","text":"<p>rio_tiler.utils: utility functions.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.CRS_to_uri","title":"CRS_to_uri","text":"<pre><code>CRS_to_uri(crs: CRS) -&gt; Optional[str]\n</code></pre> <p>Convert CRS to URI.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.CRS_to_urn","title":"CRS_to_urn","text":"<pre><code>CRS_to_urn(crs: CRS) -&gt; Optional[str]\n</code></pre> <p>Convert CRS to URN.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._CRS_authority_info","title":"_CRS_authority_info","text":"<pre><code>_CRS_authority_info(crs: CRS) -&gt; Optional[Tuple[str, str, str]]\n</code></pre> <p>Convert CRS to URI.</p> <p>Code adapted from github.com/developmentseed/morecantile/blob/1829fe12408e4a1feee7493308f3f02257ef4caf/morecantile/models.py#L148-L161</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._array_gdal_name","title":"_array_gdal_name","text":"<pre><code>_array_gdal_name(data: ndarray) -&gt; str\n</code></pre> <p>Return GDAL MEM dataset name.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._chunks","title":"_chunks","text":"<pre><code>_chunks(my_list: Sequence, chuck_size: int) -&gt; Generator[Sequence, None, None]\n</code></pre> <p>Yield successive n-sized chunks from l.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._get_width_height","title":"_get_width_height","text":"<pre><code>_get_width_height(max_size, dataset_height, dataset_width) -&gt; Tuple[int, int]\n</code></pre> <p>Get Output Width/Height based on a max_size and dataset shape.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._missing_size","title":"_missing_size","text":"<pre><code>_missing_size(w: Optional[int] = None, h: Optional[int] = None)\n</code></pre> <p>Check if one and only one size (width, height) is valid.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._requested_tile_aligned_with_internal_tile","title":"_requested_tile_aligned_with_internal_tile","text":"<pre><code>_requested_tile_aligned_with_internal_tile(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], bounds: BBox, bounds_crs: CRS = WEB_MERCATOR_CRS) -&gt; bool\n</code></pre> <p>Check if tile is aligned with internal tiles.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils._validate_shape_input","title":"_validate_shape_input","text":"<pre><code>_validate_shape_input(shape: Dict) -&gt; Dict\n</code></pre> <p>Ensure input shape is valid and reduce features to geometry</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.cast_to_sequence","title":"cast_to_sequence","text":"<pre><code>cast_to_sequence(val: Optional[Any] = None) -&gt; Sequence\n</code></pre> <p>Cast input to sequence if not Tuple of List.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.create_cutline","title":"create_cutline","text":"<pre><code>create_cutline(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], geometry: Dict, geometry_crs: CRS = None, op: Optional[Callable[[float], Any]] = None) -&gt; str\n</code></pre> <p>Create WKT Polygon Cutline for GDALWarpOptions.</p> <p>Ref: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>geometry</code>               (<code>dict</code>)           \u2013            <p>GeoJSON feature or GeoJSON geometry. By default the coordinates are considered to be in the dataset CRS. Use <code>geometry_crs</code> to set a specific CRS.</p> </li> <li> <code>geometry_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Input geometry Coordinate Reference System</p> </li> </ul> <p>Returns:     str: WKT geometry in form of `POLYGON ((x y, x y, ...)))</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.get_array_statistics","title":"get_array_statistics","text":"<pre><code>get_array_statistics(data: MaskedArray, categorical: bool = False, categories: Optional[List[float]] = None, percentiles: Optional[List[int]] = None, coverage: Optional[NDArray[floating]] = None, **kwargs: Any) -&gt; List[Dict[Any, Any]]\n</code></pre> <p>Calculate per band array statistics.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>MaskedArray</code>)           \u2013            <p>input masked array data to get the statistics from.</p> </li> <li> <code>categorical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>treat input data as categorical data. Defaults to <code>False</code>.</p> </li> <li> <code>categories</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of categories to return value for.</p> </li> <li> <code>percentiles</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of percentile values to calculate. Defaults to <code>[2, 98]</code>.</p> </li> <li> <code>coverage</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>Data coverage fraction.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>options to forward to <code>numpy.histogram</code> function (only applies for non-categorical data).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>List[Dict[Any, Any]]</code> )          \u2013            <p>list of array statistics (dict)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = numpy.ma.zeros((1, 256, 256))\n&gt;&gt;&gt; get_array_statistics(data)\n[\n    {\n        'min': 0.0,\n        'max': 0.0,\n        'mean': 0.0,\n        'count': 65536.0,\n        'sum': 0.0,\n        'std': 0.0,\n        'median': 0.0,\n        'majority': 0.0,\n        'minority': 0.0,\n        'unique': 1.0,\n        'percentile_2': 0.0,\n        'percentile_98': 0.0,\n        'histogram': [\n            [0, 0, 0, 0, 0, 65536, 0, 0, 0, 0],\n            [-0.5, -0.4, -0.3, -0.19999999999999996, -0.09999999999999998, 0.0, 0.10000000000000009, 0.20000000000000007, 0.30000000000000004, 0.4, 0.5]\n        ],\n        'valid_pixels': 65536.0,\n        'masked_pixels': 0.0,\n        'valid_percent': 100.0\n    }\n]\n</code></pre>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.get_overview_level","title":"get_overview_level","text":"<pre><code>get_overview_level(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], bounds: BBox, height: int, width: int, dst_crs: CRS = WEB_MERCATOR_CRS) -&gt; int\n</code></pre> <p>Return the overview level corresponding to the tile resolution.</p> <p>Freely adapted from github.com/OSGeo/gdal/blob/41993f127e6e1669fbd9e944744b7c9b2bd6c400/gdal/apps/gdalwarp_lib.cpp#L2293-L2362</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>bounds</code>               (<code>tuple</code>)           \u2013            <p>Bounding box coordinates in target crs (dst_crs).</p> </li> <li> <code>height</code>               (<code>int</code>)           \u2013            <p>Desired output height of the array for the input bounds.</p> </li> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Desired output width of the array for the input bounds.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>WEB_MERCATOR_CRS</code> )           \u2013            <p>Target Coordinate Reference System. Defaults to <code>epsg:3857</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Overview level.</p> </li> </ul>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.get_vrt_transform","title":"get_vrt_transform","text":"<pre><code>get_vrt_transform(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT], bounds: BBox, height: Optional[int] = None, width: Optional[int] = None, dst_crs: CRS = WEB_MERCATOR_CRS, window_precision: int = 6, align_bounds_with_dataset: bool = False) -&gt; Tuple[Affine, int, int]\n</code></pre> <p>Calculate VRT transform.</p> <p>Parameters:</p> <ul> <li> <code>src_dst</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>bounds</code>               (<code>tuple</code>)           \u2013            <p>Bounding box coordinates in target crs (dst_crs).</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array for the input bounds.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array for the input bounds.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>WEB_MERCATOR_CRS</code> )           \u2013            <p>Target Coordinate Reference System. Defaults to <code>epsg:3857</code>.</p> </li> <li> <code>align_bounds_with_dataset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Align input bounds with dataset transform. Defaults to <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[Affine, int, int]</code> )          \u2013            <p>VRT transform (affine.Affine), width (int) and height (int)</p> </li> </ul>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.has_alpha_band","title":"has_alpha_band","text":"<pre><code>has_alpha_band(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT]) -&gt; bool\n</code></pre> <p>Check for alpha band or mask in source.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.has_mask_band","title":"has_mask_band","text":"<pre><code>has_mask_band(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT]) -&gt; bool\n</code></pre> <p>Check for mask band in source.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.linear_rescale","title":"linear_rescale","text":"<pre><code>linear_rescale(image: ndarray, in_range: IntervalTuple, out_range: IntervalTuple = (0, 255)) -&gt; ndarray\n</code></pre> <p>Apply linear rescaling to a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>ndarray</code>)           \u2013            <p>array to rescale.</p> </li> <li> <code>in_range</code>               (<code>tuple</code>)           \u2013            <p>array min/max value to rescale from.</p> </li> <li> <code>out_range</code>               (<code>tuple</code>, default:                   <code>(0, 255)</code> )           \u2013            <p>output min/max bounds to rescale to. Defaults to <code>(0, 255)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>numpy.ndarray: linear rescaled array.</p> </li> </ul>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.mapzen_elevation_rgb","title":"mapzen_elevation_rgb","text":"<pre><code>mapzen_elevation_rgb(data: ndarray) -&gt; ndarray\n</code></pre> <p>Encode elevation value to RGB values compatible with Mapzen tangram.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Image array to encode.</p> </li> </ul> <p>Returns     numpy.ndarray: Elevation encoded in a RGB array.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.non_alpha_indexes","title":"non_alpha_indexes","text":"<pre><code>non_alpha_indexes(src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT]) -&gt; Tuple\n</code></pre> <p>Return indexes of non-alpha bands.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.normalize_bounds","title":"normalize_bounds","text":"<pre><code>normalize_bounds(bounds: BBox) -&gt; BBox\n</code></pre> <p>Return BBox in correct minx, miny, maxx, maxy order.</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.pansharpening_brovey","title":"pansharpening_brovey","text":"<pre><code>pansharpening_brovey(rgb: ndarray, pan: ndarray, weight: float, pan_dtype: str) -&gt; ndarray\n</code></pre> <p>Apply Brovey pansharpening method.</p> <p>Brovey Method: Each resampled, multispectral pixel is multiplied by the ratio of the corresponding panchromatic pixel intensity to the sum of all the multispectral intensities.</p> <p>Original code from mapbox/rio-pansharpen</p>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.render","title":"render","text":"<pre><code>render(data: ndarray, mask: Optional[ndarray] = None, img_format: str = 'PNG', colormap: Optional[ColorMapType] = None, **creation_options: Any) -&gt; bytes\n</code></pre> <p>Translate numpy.ndarray to image bytes.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Image array to encode.</p> </li> <li> <code>mask</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Mask array.</p> </li> <li> <code>img_format</code>               (<code>str</code>, default:                   <code>'PNG'</code> )           \u2013            <p>Image format. See: for the list of supported format by GDAL: www.gdal.org/formats_list.html. Defaults to <code>PNG</code>.</p> </li> <li> <code>colormap</code>               (<code>dict or sequence</code>, default:                   <code>None</code> )           \u2013            <p>RGBA Color Table dictionary or sequence.</p> </li> <li> <code>creation_options</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Image driver creation options to forward to GDAL.</p> </li> </ul> <p>Returns     bytes: image body.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with Reader(\"my_tif.tif\") as src:\n    img = src.preview()\n    with open('test.jpg', 'wb') as f:\n        f.write(render(img.data, img.mask, img_format=\"jpeg\"))\n</code></pre>"},{"location":"api/rio_tiler/utils/#rio_tiler.utils.resize_array","title":"resize_array","text":"<pre><code>resize_array(data: ndarray, height: int, width: int, resampling_method: RIOResampling = 'nearest') -&gt; ndarray\n</code></pre> <p>resize array to a given height and width.</p>"},{"location":"api/rio_tiler/io/base/","title":"rio_tiler.io.base","text":""},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base","title":"rio_tiler.io.base","text":"<p>rio_tiler.io.base: ABC class for rio-tiler readers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader","title":"BaseReader","text":"<p>               Bases: <code>SpatialMixin</code></p> <p>Rio-tiler.io BaseReader.</p> <p>Attributes:</p> <ul> <li> <code>input</code>               (<code>any</code>)           \u2013            <p>Reader's input.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_value, traceback)\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.feature","title":"feature  <code>abstractmethod</code>","text":"<pre><code>feature(shape: Dict) -&gt; ImageData\n</code></pre> <p>Read a Dataset for a GeoJSON feature.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>dict</code>)           \u2013            <p>Valid GeoJSON feature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.info","title":"info  <code>abstractmethod</code>","text":"<pre><code>info() -&gt; Info\n</code></pre> <p>Return Dataset's info.</p> <p>Returns:</p> <ul> <li> <code>Info</code>           \u2013            <p>rio_tile.models.Info: Dataset info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.part","title":"part  <code>abstractmethod</code>","text":"<pre><code>part(bbox: BBox) -&gt; ImageData\n</code></pre> <p>Read a Part of a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top) in target crs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.point","title":"point  <code>abstractmethod</code>","text":"<pre><code>point(lon: float, lat: float) -&gt; PointData\n</code></pre> <p>Read a value from a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Longitude.</p> </li> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Latitude.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>rio_tiler.models.PointData: PointData instance with data, mask and spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.preview","title":"preview  <code>abstractmethod</code>","text":"<pre><code>preview() -&gt; ImageData\n</code></pre> <p>Read a preview of a Dataset.</p> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.statistics","title":"statistics  <code>abstractmethod</code>","text":"<pre><code>statistics() -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return bands statistics from a dataset.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, BandStatistics]</code>           \u2013            <p>Dict[str, rio_tiler.models.BandStatistics]: bands statistics.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.BaseReader.tile","title":"tile  <code>abstractmethod</code>","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int) -&gt; ImageData\n</code></pre> <p>Read a Map tile from the Dataset.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader","title":"MultiBandReader","text":"<p>               Bases: <code>SpatialMixin</code></p> <p>Multi Band Reader.</p> <p>This Abstract Base Class Reader is suited for dataset that stores spectral bands as separate files  (e.g. Sentinel 2).</p> <p>Attributes:</p> <ul> <li> <code>input</code>               (<code>any</code>)           \u2013            <p>input data.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> <li> <code>minzoom</code>               (<code>int</code>)           \u2013            <p>Set dataset's minzoom.</p> </li> <li> <code>maxzoom</code>               (<code>int</code>)           \u2013            <p>Set dataset's maxzoom.</p> </li> <li> <code>reader_options</code>               (<code>(dict, option)</code>)           \u2013            <p>options to forward to the reader. Defaults to <code>{}</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_value, traceback)\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader._get_band_url","title":"_get_band_url  <code>abstractmethod</code>","text":"<pre><code>_get_band_url(band: str) -&gt; str\n</code></pre> <p>Validate band name and construct url.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.feature","title":"feature","text":"<pre><code>feature(shape: Dict, bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>dict</code>)           \u2013            <p>Valid GeoJSON feature.</p> </li> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.feature</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.info","title":"info","text":"<pre><code>info(bands: Optional[Union[Sequence[str], str]] = None, **kwargs: Any) -&gt; Info\n</code></pre> <p>Return metadata from multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>band names to fetch info from. Required keyword argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Info</code> )          \u2013            <p>Multiple bands info in form of {\"band1\": rio_tile.models.Info}.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.parse_expression","title":"parse_expression","text":"<pre><code>parse_expression(expression: str) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.part","title":"part","text":"<pre><code>part(bbox: BBox, bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge parts from multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top) in target crs.</p> </li> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the 'self.reader.part' method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.point","title":"point","text":"<pre><code>point(lon: float, lat: float, bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; PointData\n</code></pre> <p>Read a pixel values from multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Longitude.</p> </li> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Latitude.</p> </li> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.point</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.preview","title":"preview","text":"<pre><code>preview(bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge previews from multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.preview</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.statistics","title":"statistics","text":"<pre><code>statistics(bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, categorical: bool = False, categories: Optional[List[float]] = None, percentiles: Optional[List[int]] = None, hist_options: Optional[Dict] = None, max_size: int = 1024, **kwargs: Any) -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from. Required keyword argument.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>categorical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>treat input data as categorical data. Defaults to False.</p> </li> <li> <code>categories</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of categories to return value for.</p> </li> <li> <code>percentiles</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of percentile values to calculate. Defaults to <code>[2, 98]</code>.</p> </li> <li> <code>hist_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to forward to numpy.histogram function.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.preview</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, BandStatistics]</code> )          \u2013            <p>Multiple assets statistics in form of {\"{band}/{expression}\": rio_tiler.models.BandStatistics, ...}.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBandReader.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, bands: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge Web Map tiles multiple bands.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> <li> <code>bands</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>bands to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the band list (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.tile</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader","title":"MultiBaseReader","text":"<p>               Bases: <code>SpatialMixin</code></p> <p>MultiBaseReader Reader.</p> <p>This Abstract Base Class Reader is suited for dataset that are composed of multiple assets (e.g. STAC).</p> <p>Attributes:</p> <ul> <li> <code>input</code>               (<code>any</code>)           \u2013            <p>input data.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> <li> <code>minzoom</code>               (<code>int</code>)           \u2013            <p>Set dataset's minzoom.</p> </li> <li> <code>maxzoom</code>               (<code>int</code>)           \u2013            <p>Set dataset's maxzoom.</p> </li> <li> <code>reader_options</code>               (<code>(dict, option)</code>)           \u2013            <p>options to forward to the reader. Defaults to <code>{}</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_value, traceback)\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader._get_asset_info","title":"_get_asset_info  <code>abstractmethod</code>","text":"<pre><code>_get_asset_info(asset: str) -&gt; AssetInfo\n</code></pre> <p>Validate asset name and construct url.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader._get_reader","title":"_get_reader","text":"<pre><code>_get_reader(asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]\n</code></pre> <p>Get Asset Reader and options.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader._update_statistics","title":"_update_statistics","text":"<pre><code>_update_statistics(img: ImageData, indexes: Optional[Indexes] = None, statistics: Optional[Sequence[Tuple[float, float]]] = None)\n</code></pre> <p>Update ImageData Statistics from AssetInfo.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.feature","title":"feature","text":"<pre><code>feature(shape: Dict, assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_as_band: bool = False, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>dict</code>)           \u2013            <p>Valid GeoJSON feature.</p> </li> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.feature</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.info","title":"info","text":"<pre><code>info(assets: Optional[Union[Sequence[str], str]] = None, **kwargs: Any) -&gt; Dict[str, Info]\n</code></pre> <p>Return metadata from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from. Required keyword argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, Info]</code> )          \u2013            <p>Multiple assets info in form of {\"asset1\": rio_tile.models.Info}.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.merged_statistics","title":"merged_statistics","text":"<pre><code>merged_statistics(assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, categorical: bool = False, categories: Optional[List[float]] = None, percentiles: Optional[List[int]] = None, hist_options: Optional[Dict] = None, max_size: int = 1024, **kwargs: Any) -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>categorical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>treat input data as categorical data. Defaults to False.</p> </li> <li> <code>categories</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of categories to return value for.</p> </li> <li> <code>percentiles</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of percentile values to calculate. Defaults to <code>[2, 98]</code>.</p> </li> <li> <code>hist_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to forward to numpy.histogram function.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.preview</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, BandStatistics]</code>           \u2013            <p>Dict[str, rio_tiler.models.BandStatistics]: bands statistics.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.parse_expression","title":"parse_expression","text":"<pre><code>parse_expression(expression: str, asset_as_band: bool = False) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.part","title":"part","text":"<pre><code>part(bbox: BBox, assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_as_band: bool = False, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge parts from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top) in target crs.</p> </li> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.part</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.point","title":"point","text":"<pre><code>point(lon: float, lat: float, assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_as_band: bool = False, **kwargs: Any) -&gt; PointData\n</code></pre> <p>Read pixel value from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Longitude.</p> </li> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Latitude.</p> </li> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.point</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.preview","title":"preview","text":"<pre><code>preview(assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_as_band: bool = False, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge previews from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.preview</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.statistics","title":"statistics","text":"<pre><code>statistics(assets: Optional[Union[Sequence[str], str]] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_expression: Optional[Dict[str, str]] = None, **kwargs: Any) -&gt; Dict[str, Dict[str, BandStatistics]]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>asset_expression</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for each asset (e.g. {\"asset1\": \"b1/b2+b3\", \"asset2\": ...}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.statistics</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, Dict[str, BandStatistics]]</code> )          \u2013            <p>Multiple assets statistics in form of {\"asset1\": {\"1\": rio_tiler.models.BandStatistics, ...}}.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.MultiBaseReader.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, assets: Optional[Union[Sequence[str], str]] = None, expression: Optional[str] = None, asset_indexes: Optional[Dict[str, Indexes]] = None, asset_as_band: bool = False, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read and merge Wep Map tiles from multiple assets.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> <li> <code>assets</code>               (<code>sequence of str or str</code>, default:                   <code>None</code> )           \u2013            <p>assets to fetch info from.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression for the asset list (e.g. asset1/asset2+asset3).</p> </li> <li> <code>asset_indexes</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.reader.tile</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin","title":"SpatialMixin","text":"<p>Spatial Info Mixin.</p> <p>Attributes:</p> <ul> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> </ul>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin._dst_geom_in_tms_crs","title":"_dst_geom_in_tms_crs  <code>cached</code> <code>property</code>","text":"<pre><code>_dst_geom_in_tms_crs\n</code></pre> <p>Return dataset geom info in TMS projection.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin._maxzoom","title":"_maxzoom  <code>cached</code> <code>property</code>","text":"<pre><code>_maxzoom: int\n</code></pre> <p>Calculate dataset maximum zoom level.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin._minzoom","title":"_minzoom  <code>cached</code> <code>property</code>","text":"<pre><code>_minzoom: int\n</code></pre> <p>Calculate dataset minimum zoom level.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin.get_geographic_bounds","title":"get_geographic_bounds","text":"<pre><code>get_geographic_bounds(crs: CRS) -&gt; BBox\n</code></pre> <p>Return Geographic Bounds for a Geographic CRS.</p>"},{"location":"api/rio_tiler/io/base/#rio_tiler.io.base.SpatialMixin.tile_exists","title":"tile_exists","text":"<pre><code>tile_exists(tile_x: int, tile_y: int, tile_z: int) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the tile intersects the dataset bounds.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/","title":"rio_tiler.io.rasterio","text":""},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio","title":"rio_tiler.io.rasterio","text":"<p>rio_tiler.io.rasterio: rio-tiler reader built on top Rasterio</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader","title":"ImageReader","text":"<p>               Bases: <code>Reader</code></p> <p>Non Geo Image Reader</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.maxzoom","title":"maxzoom  <code>property</code>","text":"<pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.minzoom","title":"minzoom  <code>property</code>","text":"<pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Define _kwargs, open dataset and get info.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.feature","title":"feature","text":"<pre><code>feature(shape: Dict, indexes: Optional[Indexes] = None, expression: Optional[str] = None, max_size: Optional[int] = None, height: Optional[int] = None, width: Optional[int] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; ImageData\n</code></pre> <p>Read part of an Image defined by a geojson feature.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.part","title":"part","text":"<pre><code>part(bbox: BBox, indexes: Optional[Union[int, Sequence]] = None, expression: Optional[str] = None, max_size: Optional[int] = None, height: Optional[int] = None, width: Optional[int] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; ImageData\n</code></pre> <p>Read part of an Image.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top).</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.point","title":"point","text":"<pre><code>point(x: float, y: float, indexes: Optional[Indexes] = None, expression: Optional[str] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; PointData\n</code></pre> <p>Read a pixel value from an Image.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>X coordinate.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>Y coordinate.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.ImageReader.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, tilesize: int = 256, indexes: Optional[Indexes] = None, expression: Optional[str] = None, out_dtype: Optional[Union[str, dtype]] = None, resampling_method: RIOResampling = 'nearest', unscale: bool = False, post_process: Optional[Callable[[MaskedArray], MaskedArray]] = None) -&gt; ImageData\n</code></pre> <p>Read a Web Map tile from an Image.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> <li> <code>tilesize</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>Output image size. Defaults to <code>256</code>.</p> </li> <li> <code>indexes</code>               (<code>int or sequence of int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>unscale</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>.</p> </li> <li> <code>post_process</code>               (<code>callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to apply on output data and mask values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.LocalTileMatrixSet","title":"LocalTileMatrixSet","text":"<p>Fake TMS for non-geo image.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.LocalTileMatrixSet._ul","title":"_ul","text":"<pre><code>_ul(*tile: Tile) -&gt; Coords\n</code></pre> <p>Return the upper left coordinate of the (x, y, z) tile.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.LocalTileMatrixSet.xy_bounds","title":"xy_bounds","text":"<pre><code>xy_bounds(*tile: Tile) -&gt; BoundingBox\n</code></pre> <p>Return the bounding box of the (x, y, z) tile</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader","title":"Reader","text":"<p>               Bases: <code>BaseReader</code></p> <p>Rasterio Reader.</p> <p>Attributes:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>dataset path.</p> </li> <li> <code>dataset</code>               (<code>DatasetReader or DatasetWriter or WarpedVRT</code>)           \u2013            <p>Rasterio dataset.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> <li> <code>colormap</code>               (<code>dict</code>)           \u2013            <p>Overwrite internal colormap.</p> </li> <li> <code>options</code>               (<code>dict</code>)           \u2013            <p>Options to forward to low-level reader methods.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with Reader(src_path) as src:\n    src.tile(...)\n</code></pre> <pre><code>&gt;&gt;&gt; # Set global options\n    with Reader(src_path, options={\"unscale\": True, \"nodata\": 0}) as src:\n        src.tile(...)\n</code></pre> <pre><code>&gt;&gt;&gt; with rasterio.open(src_path) as src_dst:\n        with WarpedVRT(src_dst, ...) as vrt_dst:\n            with Reader(None, dataset=vrt_dst) as src:\n                src.tile(...)\n</code></pre> <pre><code>&gt;&gt;&gt; with rasterio.open(src_path) as src_dst:\n        with Reader(None, dataset=src_dst) as src:\n            src.tile(...)\n</code></pre>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.maxzoom","title":"maxzoom  <code>property</code>","text":"<pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.minzoom","title":"minzoom  <code>property</code>","text":"<pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Define _kwargs, open dataset and get info.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_value, traceback)\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader._get_colormap","title":"_get_colormap","text":"<pre><code>_get_colormap()\n</code></pre> <p>Retrieve the internal colormap.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close rasterio dataset.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.feature","title":"feature","text":"<pre><code>feature(shape: Dict, dst_crs: Optional[CRS] = None, shape_crs: CRS = WGS84_CRS, indexes: Optional[Indexes] = None, expression: Optional[str] = None, max_size: Optional[int] = None, height: Optional[int] = None, width: Optional[int] = None, buffer: Optional[NumType] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read part of a Dataset defined by a geojson feature.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>dict</code>)           \u2013            <p>Valid GeoJSON feature.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite target coordinate reference system.</p> </li> <li> <code>shape_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Input geojson coordinate reference system. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>buffer</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Buffer on each side of the given aoi. It must be a multiple of <code>0.5</code>. Output image size will be expanded to <code>output imagesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>Reader.part</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.info","title":"info","text":"<pre><code>info() -&gt; Info\n</code></pre> <p>Return Dataset info.</p>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.part","title":"part","text":"<pre><code>part(bbox: BBox, dst_crs: Optional[CRS] = None, bounds_crs: CRS = WGS84_CRS, indexes: Optional[Union[int, Sequence]] = None, expression: Optional[str] = None, max_size: Optional[int] = None, height: Optional[int] = None, width: Optional[int] = None, buffer: Optional[float] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read part of a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top) in target crs (\"dst_crs\").</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite target coordinate reference system.</p> </li> <li> <code>bounds_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Bounds Coordinate Reference System. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>buffer</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Buffer on each side of the given aoi. It must be a multiple of <code>0.5</code>. Output image size will be expanded to <code>output imagesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>rio_tiler.reader.part</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.point","title":"point","text":"<pre><code>point(lon: float, lat: float, coord_crs: CRS = WGS84_CRS, indexes: Optional[Indexes] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; PointData\n</code></pre> <p>Read a pixel value from a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Longitude.</p> </li> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Latitude.</p> </li> <li> <code>coord_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>rio_tiler.reader.point</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.preview","title":"preview","text":"<pre><code>preview(indexes: Optional[Indexes] = None, expression: Optional[str] = None, max_size: int = 1024, height: Optional[int] = None, width: Optional[int] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Return a preview of a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>self.read</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.read","title":"read","text":"<pre><code>read(indexes: Optional[Indexes] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read the Dataset.</p> <p>Parameters:</p> <ul> <li> <code>indexes</code>               (<code>sequence of int or int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>rio_tiler.reader.read</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.statistics","title":"statistics","text":"<pre><code>statistics(categorical: bool = False, categories: Optional[List[float]] = None, percentiles: Optional[List[int]] = None, hist_options: Optional[Dict] = None, max_size: int = 1024, indexes: Optional[Indexes] = None, expression: Optional[str] = None, **kwargs: Any) -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return bands statistics from a dataset.</p> <p>Parameters:</p> <ul> <li> <code>categorical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>treat input data as categorical data. Defaults to False.</p> </li> <li> <code>categories</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of categories to return value for.</p> </li> <li> <code>percentiles</code>               (<code>list of numbers</code>, default:                   <code>None</code> )           \u2013            <p>list of percentile values to calculate. Defaults to <code>[2, 98]</code>.</p> </li> <li> <code>hist_options</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Options to forward to numpy.histogram function.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024.</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to <code>self.read</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, BandStatistics]</code>           \u2013            <p>Dict[str, rio_tiler.models.BandStatistics]: bands statistics.</p> </li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#rio_tiler.io.rasterio.Reader.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, tilesize: int = 256, indexes: Optional[Indexes] = None, expression: Optional[str] = None, buffer: Optional[float] = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read a Web Map tile from a Dataset.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> <li> <code>tilesize</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>Output image size. Defaults to <code>256</code>.</p> </li> <li> <code>indexes</code>               (<code>int or sequence of int</code>, default:                   <code>None</code> )           \u2013            <p>Band indexes.</p> </li> <li> <code>expression</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>rio-tiler expression (e.g. b1/b2+b3).</p> </li> <li> <code>buffer</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * tile_buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</p> </li> <li> <code>kwargs</code>               (<code>optional</code>, default:                   <code>{}</code> )           \u2013            <p>Options to forward to the <code>Reader.part</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/stac/","title":"rio_tiler.io.stac","text":""},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac","title":"rio_tiler.io.stac","text":"<p>rio_tiler.io.stac: STAC reader.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.STACReader","title":"STACReader","text":"<p>               Bases: <code>MultiBaseReader</code></p> <p>STAC Reader.</p> <p>Attributes:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>STAC Item path, URL or S3 URL.</p> </li> <li> <code>item</code>               (<code>(dict or Item, STAC)</code>)           \u2013            <p>Stac Item.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> <li> <code>minzoom</code>               (<code>int</code>)           \u2013            <p>Set minzoom for the tiles.</p> </li> <li> <code>maxzoom</code>               (<code>int</code>)           \u2013            <p>Set maxzoom for the tiles.</p> </li> <li> <code>include_assets</code>               (<code>set of string</code>)           \u2013            <p>Only Include specific assets.</p> </li> <li> <code>exclude_assets</code>               (<code>set of string</code>)           \u2013            <p>Exclude specific assets.</p> </li> <li> <code>include_asset_types</code>               (<code>set of string</code>)           \u2013            <p>Only include some assets base on their type.</p> </li> <li> <code>exclude_asset_types</code>               (<code>set of string</code>)           \u2013            <p>Exclude some assets base on their type.</p> </li> <li> <code>default_assets</code>               (<code>list of string</code>)           \u2013            <p>Default assets to use if none are defined.</p> </li> <li> <code>reader</code>               (<code>BaseReader</code>)           \u2013            <p>rio-tiler Reader. Defaults to <code>rio_tiler.io.Reader</code>.</p> </li> <li> <code>reader_options</code>               (<code>dict</code>)           \u2013            <p>Additional option to forward to the Reader. Defaults to <code>{}</code>.</p> </li> <li> <code>fetch_options</code>               (<code>dict</code>)           \u2013            <p>Options to pass to <code>rio_tiler.io.stac.fetch</code> function fetching the STAC Items. Defaults to <code>{}</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with STACReader(stac_path) as stac:\n    stac.tile(...)\n</code></pre> <pre><code>&gt;&gt;&gt; with STACReader(stac_path, reader=MyCustomReader, reader_options={...}) as stac:\n    stac.tile(...)\n</code></pre> <pre><code>&gt;&gt;&gt; my_stac = {\n        \"type\": \"Feature\",\n        \"stac_version\": \"1.0.0\",\n        ...\n    }\n    with STACReader(None, item=my_stac) as stac:\n        # the dict will be translated to a pystac item\n        assert isinstance(stac.item, pystac.Item)\n        stac.tile(...)\n</code></pre>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.STACReader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Fetch STAC Item and get list of valid assets.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.STACReader._get_asset_info","title":"_get_asset_info","text":"<pre><code>_get_asset_info(asset: str) -&gt; AssetInfo\n</code></pre> <p>Validate asset names and return asset's info.</p> <p>Parameters:</p> <ul> <li> <code>asset</code>               (<code>str</code>)           \u2013            <p>STAC asset name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssetInfo</code> (              <code>AssetInfo</code> )          \u2013            <p>STAC asset info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.STACReader._get_reader","title":"_get_reader","text":"<pre><code>_get_reader(asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]\n</code></pre> <p>Get Asset Reader.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.STACReader.get_asset_list","title":"get_asset_list","text":"<pre><code>get_asset_list() -&gt; List[str]\n</code></pre> <p>Get valid asset list</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac._get_assets","title":"_get_assets","text":"<pre><code>_get_assets(stac_item: Item, include: Optional[Set[str]] = None, exclude: Optional[Set[str]] = None, include_asset_types: Optional[Set[str]] = None, exclude_asset_types: Optional[Set[str]] = None) -&gt; Iterator\n</code></pre> <p>Get valid asset list.</p> <p>Parameters:</p> <ul> <li> <code>stac_item</code>               (<code>Item</code>)           \u2013            <p>STAC Item.</p> </li> <li> <code>include</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Only Include specific assets.</p> </li> <li> <code>exclude</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Exclude specific assets.</p> </li> <li> <code>include_asset_types</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Only include some assets base on their type.</p> </li> <li> <code>exclude_asset_types</code>               (<code>Optional[Set[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Exclude some assets base on their type.</p> </li> </ul> <p>Yields     str: valid STAC asset name.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac._to_pystac_item","title":"_to_pystac_item","text":"<pre><code>_to_pystac_item(item: Union[None, Dict, Item]) -&gt; Union[None, Item]\n</code></pre> <p>Attr converter to convert to Dict to pystac.Item</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Union[Dict, Item]</code>)           \u2013            <p>STAC Item.</p> </li> </ul> <p>Returns     pystac.Item: pystac STAC item object.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.aws_get_object","title":"aws_get_object","text":"<pre><code>aws_get_object(bucket: str, key: str, request_pays: bool = False, client: client = None) -&gt; bytes\n</code></pre> <p>AWS s3 get object content.</p>"},{"location":"api/rio_tiler/io/stac/#rio_tiler.io.stac.fetch","title":"fetch","text":"<pre><code>fetch(filepath: str, **kwargs: Any) -&gt; Dict\n</code></pre> <p>Fetch STAC items.</p> <p>A LRU cache is set on top of this function.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>STAC item URL.</p> </li> <li> <code>kwargs</code>               (<code>any</code>, default:                   <code>{}</code> )           \u2013            <p>additional options to pass to client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict</code> )          \u2013            <p>STAC Item content.</p> </li> </ul>"},{"location":"api/rio_tiler/io/xarray/","title":"rio_tiler.io.xarray","text":""},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray","title":"rio_tiler.io.xarray","text":"<p>rio_tiler.io.xarray: Xarray Reader.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader","title":"XarrayReader","text":"<p>               Bases: <code>BaseReader</code></p> <p>Xarray Reader.</p> <p>Attributes:</p> <ul> <li> <code>dataset</code>               (<code>DataArray</code>)           \u2013            <p>Xarray DataArray dataset.</p> </li> <li> <code>tms</code>               (<code>TileMatrixSet</code>)           \u2013            <p>TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ds = xarray.open_dataset(\n        \"https://pangeo.blob.core.windows.net/pangeo-public/daymet-rio-tiler/na-wgs84.zarr\",\n        engine=\"zarr\",\n        decode_coords=\"all\",\n        consolidated=True,\n    )\n    da = ds[\"tmax\"]\n</code></pre> <pre><code>with XarrayReader(da) as dst:\n    img = dst.tile(...)\n</code></pre>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.band_descriptions","title":"band_descriptions  <code>property</code>","text":"<pre><code>band_descriptions: List[str]\n</code></pre> <p>Return list of <code>band descriptions</code> in DataArray.</p> <p><code>Bands</code> are all dimensions not defined as spatial dims by rioxarray.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.maxzoom","title":"maxzoom  <code>property</code>","text":"<pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.minzoom","title":"minzoom  <code>property</code>","text":"<pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Set bounds and CRS.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader._sel_indexes","title":"_sel_indexes","text":"<pre><code>_sel_indexes(indexes: Indexes | None = None) -&gt; Tuple[DataArray, List[str], List[str]]\n</code></pre> <p>Select <code>band</code> indexes in DataArray.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.feature","title":"feature","text":"<pre><code>feature(shape: Dict, dst_crs: CRS | None = None, shape_crs: CRS = WGS84_CRS, reproject_method: WarpResampling = 'nearest', auto_expand: bool = True, nodata: NoData | None = None, indexes: Indexes | None = None, max_size: int | None = None, height: int | None = None, width: int | None = None, resampling_method: RIOResampling = 'nearest', out_dtype: str | dtype | None = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read part of a dataset defined by a geojson feature.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>dict</code>)           \u2013            <p>Valid GeoJSON feature.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite target coordinate reference system.</p> </li> <li> <code>shape_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Input geojson coordinate reference system. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>auto_expand</code>               (<code>boolean</code>, default:                   <code>True</code> )           \u2013            <p>When True, rioxarray's clip_box will expand clip search if only 1D raster found with clip. When False, will throw <code>OneDimensionalRaster</code> error if only 1 x or y data point is found. Defaults to True.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.info","title":"info","text":"<pre><code>info() -&gt; Info\n</code></pre> <p>Return xarray.DataArray info.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.part","title":"part","text":"<pre><code>part(bbox: BBox, dst_crs: CRS | None = None, bounds_crs: CRS = WGS84_CRS, reproject_method: WarpResampling = 'nearest', auto_expand: bool = True, nodata: NoData | None = None, indexes: Indexes | None = None, max_size: int | None = None, height: int | None = None, width: int | None = None, resampling_method: RIOResampling = 'nearest', out_dtype: str | dtype | None = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read part of a dataset.</p> <p>Parameters:</p> <ul> <li> <code>bbox</code>               (<code>tuple</code>)           \u2013            <p>Output bounds (left, bottom, right, top) in target crs (\"dst_crs\").</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite target coordinate reference system.</p> </li> <li> <code>bounds_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Bounds Coordinate Reference System. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>auto_expand</code>               (<code>boolean</code>, default:                   <code>True</code> )           \u2013            <p>When True, rioxarray's clip_box will expand clip search if only 1D raster found with clip. When False, will throw <code>OneDimensionalRaster</code> error if only 1 x or y data point is found. Defaults to True.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.point","title":"point","text":"<pre><code>point(lon: float, lat: float, coord_crs: CRS = WGS84_CRS, nodata: NoData | None = None, indexes: Indexes | None = None, out_dtype: str | dtype | None = None, **kwargs: Any) -&gt; PointData\n</code></pre> <p>Read a pixel value from a dataset.</p> <p>Parameters:</p> <ul> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Longitude.</p> </li> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Latitude.</p> </li> <li> <code>coord_crs</code>               (<code>CRS</code>, default:                   <code>WGS84_CRS</code> )           \u2013            <p>Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointData</code>           \u2013            <p>PointData</p> </li> </ul>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.preview","title":"preview","text":"<pre><code>preview(max_size: int = 1024, height: int | None = None, width: int | None = None, nodata: NoData | None = None, indexes: Indexes | None = None, dst_crs: CRS | None = None, reproject_method: WarpResampling = 'nearest', resampling_method: RIOResampling = 'nearest', out_dtype: str | dtype | None = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Return a preview of a dataset.</p> <p>Parameters:</p> <ul> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output height of the array.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Output width of the array.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> <li> <code>dst_crs</code>               (<code>CRS</code>, default:                   <code>None</code> )           \u2013            <p>target coordinate reference system.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>resampling_method</code>               (<code>RIOResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>RasterIO resampling algorithm. Defaults to <code>nearest</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and input spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.statistics","title":"statistics","text":"<pre><code>statistics(categorical: bool = False, categories: List[float] | None = None, percentiles: List[int] | None = None, hist_options: Dict | None = None, nodata: NoData | None = None, indexes: Indexes | None = None, **kwargs: Any) -&gt; Dict[str, BandStatistics]\n</code></pre> <p>Return statistics from a dataset.</p>"},{"location":"api/rio_tiler/io/xarray/#rio_tiler.io.xarray.XarrayReader.tile","title":"tile","text":"<pre><code>tile(tile_x: int, tile_y: int, tile_z: int, tilesize: int = 256, reproject_method: WarpResampling = 'nearest', auto_expand: bool = True, nodata: NoData | None = None, indexes: Indexes | None = None, out_dtype: str | dtype | None = None, **kwargs: Any) -&gt; ImageData\n</code></pre> <p>Read a Web Map tile from a dataset.</p> <p>Parameters:</p> <ul> <li> <code>tile_x</code>               (<code>int</code>)           \u2013            <p>Tile's horizontal index.</p> </li> <li> <code>tile_y</code>               (<code>int</code>)           \u2013            <p>Tile's vertical index.</p> </li> <li> <code>tile_z</code>               (<code>int</code>)           \u2013            <p>Tile's zoom level index.</p> </li> <li> <code>tilesize</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>Output image size. Defaults to <code>256</code>.</p> </li> <li> <code>reproject_method</code>               (<code>WarpResampling</code>, default:                   <code>'nearest'</code> )           \u2013            <p>WarpKernel resampling algorithm. Defaults to <code>nearest</code>.</p> </li> <li> <code>auto_expand</code>               (<code>boolean</code>, default:                   <code>True</code> )           \u2013            <p>When True, rioxarray's clip_box will expand clip search if only 1D raster found with clip. When False, will throw <code>OneDimensionalRaster</code> error if only 1 x or y data point is found. Defaults to True.</p> </li> <li> <code>nodata</code>               (<code>int or float</code>, default:                   <code>None</code> )           \u2013            <p>Overwrite dataset internal nodata value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageData</code>           \u2013            <p>rio_tiler.models.ImageData: ImageData instance with data, mask and tile spatial info.</p> </li> </ul>"},{"location":"api/rio_tiler/mosaic/reader/","title":"rio_tiler.mosaic.reader","text":""},{"location":"api/rio_tiler/mosaic/reader/#rio_tiler.mosaic.reader","title":"rio_tiler.mosaic.reader","text":"<p>rio_tiler.mosaic: create tile from multiple assets.</p>"},{"location":"api/rio_tiler/mosaic/reader/#rio_tiler.mosaic.reader.mosaic_point_reader","title":"mosaic_point_reader","text":"<pre><code>mosaic_point_reader(mosaic_assets: Sequence, reader: Callable[..., PointData], *args: Any, pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod, chunk_size: Optional[int] = None, threads: int = MAX_THREADS, allowed_exceptions: Tuple = (PointOutsideBounds,), **kwargs) -&gt; Tuple[PointData, List]\n</code></pre> <p>Merge multiple assets.</p> <p>Args:</p> <pre><code>mosaic_assets (sequence): List of assets.\nreader (callable): Reader function. The function MUST take `(asset, *args, **kwargs)` as arguments, and MUST return a PointData object.\nargs (Any): Argument to forward to the reader function.\npixel_selection (MosaicMethod, optional): Instance of MosaicMethodBase class. Defaults to `rio_tiler.mosaic.methods.defaults.FirstMethod`.\nchunk_size (int, optional): Control the number of asset to process per loop.\nthreads (int, optional): Number of threads to use. If &lt;= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5.\nallowed_exceptions (tuple, optional): List of exceptions which will be ignored. Note: `PointOutsideBounds` is likely to be raised and should be included in the allowed_exceptions. Defaults to `(TileOutsideBounds, )`.\nkwargs (optional): Reader callable's keywords options.\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[PointData, List]</code> )          \u2013            <p>PointData and assets (list).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def reader(asset: str, *args, **kwargs) -&gt; PointData:\n        with Reader(asset) as src:\n            return src.point(*args, **kwargs)\n</code></pre> <pre><code>pt = mosaic_point_reader([\"cog.tif\", \"cog2.tif\"], reader, 0, 0)\n</code></pre>"},{"location":"api/rio_tiler/mosaic/reader/#rio_tiler.mosaic.reader.mosaic_reader","title":"mosaic_reader","text":"<pre><code>mosaic_reader(mosaic_assets: Sequence, reader: Callable[..., ImageData], *args: Any, pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod, chunk_size: Optional[int] = None, threads: int = MAX_THREADS, allowed_exceptions: Tuple = (TileOutsideBounds,), **kwargs) -&gt; Tuple[ImageData, List]\n</code></pre> <p>Merge multiple assets.</p> <p>Args:</p> <pre><code>mosaic_assets (sequence): List of assets.\nreader (callable): Reader function. The function MUST take `(asset, *args, **kwargs)` as arguments, and MUST return an ImageData.\nargs (Any): Argument to forward to the reader function.\npixel_selection (MosaicMethod, optional): Instance of MosaicMethodBase class. Defaults to `rio_tiler.mosaic.methods.defaults.FirstMethod`.\nchunk_size (int, optional): Control the number of asset to process per loop.\nthreads (int, optional): Number of threads to use. If &lt;= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5.\nallowed_exceptions (tuple, optional): List of exceptions which will be ignored. Note: `TileOutsideBounds` is likely to be raised and should be included in the allowed_exceptions. Defaults to `(TileOutsideBounds, )`.\nkwargs (optional): Reader callable's keywords options.\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[ImageData, List]</code> )          \u2013            <p>ImageData and assets (list).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def reader(asset: str, *args, **kwargs) -&gt; ImageData:\n        with Reader(asset) as src:\n            return src.tile(*args, **kwargs)\n</code></pre> <pre><code>x, y, z = 10, 10, 4\nimg = mosaic_reader([\"cog.tif\", \"cog2.tif\"], reader, x, y, z)\n</code></pre> <pre><code>&gt;&gt;&gt; def reader(asset: str, *args, **kwargs) -&gt; ImageData:\n        with Reader(asset) as src:\n            return src.preview(*args, **kwargs)\n</code></pre> <pre><code>img = mosaic_reader([\"cog.tif\", \"cog2.tif\"], reader)\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/base/","title":"rio_tiler.mosaic.methods.base","text":""},{"location":"api/rio_tiler/mosaic/methods/base/#rio_tiler.mosaic.methods.base","title":"rio_tiler.mosaic.methods.base","text":"<p>rio-tiler.mosaic.methods abc class.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#rio_tiler.mosaic.methods.base.MosaicMethodBase","title":"MosaicMethodBase  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for rio-tiler-mosaic methods objects.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#rio_tiler.mosaic.methods.base.MosaicMethodBase.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return data.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#rio_tiler.mosaic.methods.base.MosaicMethodBase.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre> <p>Check if the mosaic filling is done.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>bool</p> </li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/base/#rio_tiler.mosaic.methods.base.MosaicMethodBase.feed","title":"feed  <code>abstractmethod</code>","text":"<pre><code>feed(array: MaskedArray)\n</code></pre> <p>Fill mosaic array.</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>data</p> </li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/","title":"rio_tiler.mosaic.methods.defaults","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults","title":"rio_tiler.mosaic.methods.defaults","text":"<p>rio_tiler.mosaic.methods.defaults: default mosaic filling methods.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.CountMethod","title":"CountMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Stack the arrays and return the valid pixel count.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.CountMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return valid data count of the data stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.CountMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.CountMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.FirstMethod","title":"FirstMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Feed the mosaic array with the first pixel available.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.FirstMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.FirstMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.HighestMethod","title":"HighestMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Feed the mosaic array with the highest pixel values.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.HighestMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.HighestMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandHighMethod","title":"LastBandHighMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Feed the mosaic array using the last band as decision factor (highest value).</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandHighMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return data.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandHighMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandHighMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandLowMethod","title":"LastBandLowMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Feed the mosaic array using the last band as decision factor (lowest value).</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandLowMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return data.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandLowMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LastBandLowMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LowestMethod","title":"LowestMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Feed the mosaic array with the lowest pixel values.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LowestMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.LowestMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MeanMethod","title":"MeanMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Stack the arrays and return the Mean pixel value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MeanMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return Mean of the data stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MeanMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MeanMethod.feed","title":"feed","text":"<pre><code>feed(array: MaskedArray)\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MedianMethod","title":"MedianMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Stack the arrays and return the Median pixel value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MedianMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return Median of the data stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MedianMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.MedianMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.StdevMethod","title":"StdevMethod  <code>dataclass</code>","text":"<p>               Bases: <code>MosaicMethodBase</code></p> <p>Stack the arrays and return the Standard Deviation value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.StdevMethod.data","title":"data  <code>property</code>","text":"<pre><code>data: Optional[MaskedArray]\n</code></pre> <p>Return STDDEV of the data stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.StdevMethod.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Mosaic Method repr.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#rio_tiler.mosaic.methods.defaults.StdevMethod.feed","title":"feed","text":"<pre><code>feed(array: Optional[MaskedArray])\n</code></pre> <p>Add array to the stack.</p>"},{"location":"examples/STAC_datacube_support/","title":"Add support for STAC Datacube extension","text":"<p><code>rio-tiler</code> supports GDAL and Xarray Based dataset (DataArray) but supporting both together in a STACReader if tricky because a Xarray based reader might need some <code>reader_options</code> provider before openning the dataset.</p> <p>The goal of this notebook is to show how to create a STAC Reader which support the Datacube extension to avoid maximize the compatibility between all the dataset.</p> In\u00a0[4]: Copied! <pre>from typing import List\n\nimport attr\nimport xarray\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io import XarrayReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\n\n\n@attr.s\nclass NetCDFReader(XarrayReader):\n    \"\"\"Reader: Open NetCDF file and access DataArray.\"\"\"\n\n    src_path: str = attr.ib()\n    variable: str = attr.ib()\n\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    ds: xarray.Dataset = attr.ib(init=False)\n    input: xarray.DataArray = attr.ib(init=False)\n\n    _dims: List = attr.ib(init=False, factory=list)\n\n    def __attrs_post_init__(self):\n        \"\"\"Set bounds and CRS.\"\"\"\n        self.ds = xarray.open_dataset(self.src_path, decode_coords=\"all\")\n        da = self.ds[self.variable]\n\n        # Make sure we have a valid CRS\n        crs = da.rio.crs or \"epsg:4326\"\n        da = da.rio.write_crs(crs)\n\n        if \"time\" in da.dims:\n            da = da.isel(time=0)\n\n        self.input = da\n\n        super().__attrs_post_init__()\n</pre> from typing import List  import attr import xarray from morecantile import TileMatrixSet from rio_tiler.io import XarrayReader from rio_tiler.constants import WEB_MERCATOR_TMS   @attr.s class NetCDFReader(XarrayReader):     \"\"\"Reader: Open NetCDF file and access DataArray.\"\"\"      src_path: str = attr.ib()     variable: str = attr.ib()      tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)      ds: xarray.Dataset = attr.ib(init=False)     input: xarray.DataArray = attr.ib(init=False)      _dims: List = attr.ib(init=False, factory=list)      def __attrs_post_init__(self):         \"\"\"Set bounds and CRS.\"\"\"         self.ds = xarray.open_dataset(self.src_path, decode_coords=\"all\")         da = self.ds[self.variable]          # Make sure we have a valid CRS         crs = da.rio.crs or \"epsg:4326\"         da = da.rio.write_crs(crs)          if \"time\" in da.dims:             da = da.isel(time=0)          self.input = da          super().__attrs_post_init__() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\n\nwith NetCDFReader(\"data/dataset_2d.nc\", variable=\"dataset\") as src:\n    print(src.info())\n\n    # NOTE: We can use the preview method because we know the data is relatively small\n    # but don't use this for large dataset stored on the cloud (because it would download the whole data)\n    img = src.preview()\n\nplt.imshow(img.data_as_image())\n</pre> import matplotlib.pyplot as plt  with NetCDFReader(\"data/dataset_2d.nc\", variable=\"dataset\") as src:     print(src.info())      # NOTE: We can use the preview method because we know the data is relatively small     # but don't use this for large dataset stored on the cloud (because it would download the whole data)     img = src.preview()  plt.imshow(img.data_as_image()) <pre>bounds=(-170.085, -80.08, 169.914999999975, 79.91999999999659) crs='http://www.opengis.net/def/crs/EPSG/0/4326' band_metadata=[('b1', {})] band_descriptions=[('b1', 'value')] dtype='float64' nodata_type='Nodata' colorinterp=None scales=None offsets=None colormap=None name='dataset' count=1 width=2000 height=1000 attrs={'valid_min': 1.0, 'valid_max': 1000.0, 'fill_value': 0}\n</pre> Out[5]: <pre>&lt;matplotlib.image.AxesImage at 0x14a48efa0&gt;</pre> In\u00a0[7]: Copied! <pre>from typing import Set, Type, Tuple, Dict\nfrom rio_tiler.types import AssetInfo\nfrom rio_tiler.io import STACReader, BaseReader\nfrom rio_tiler.io.stac import STAC_ALTERNATE_KEY\n\nvalid_types = {\n    \"image/tiff; application=geotiff\",\n    \"application/x-netcdf\",\n}\n\n\n@attr.s\nclass CustomSTACReader(STACReader):\n    include_asset_types: Set[str] = attr.ib(default=valid_types)\n\n    def get_asset_list(self) -&gt; List[str]:\n        \"\"\"Get valid asset list\"\"\"\n        include = self.include_assets\n        exclude = self.exclude_assets\n        include_asset_types = self.include_asset_types\n        exclude_asset_types = self.exclude_asset_types\n\n        assets = []\n        for asset, asset_info in self.item.get_assets().items():\n            _type = asset_info.media_type\n\n            if exclude and asset in exclude:\n                continue\n\n            if (\n                _type\n                and (exclude_asset_types and _type in exclude_asset_types)\n                or (include and asset not in include)\n            ):\n                continue\n\n            if (\n                _type\n                and (include_asset_types and _type not in include_asset_types)\n                or (include and asset not in include)\n            ):\n                continue\n\n            # Here check for the datacube extension\n            extras = asset_info.extra_fields\n            if variables := extras.get(\"cube:variables\"):\n                assets += [f\"{asset}:{v}\" for v in list(variables)]\n            else:\n                assets.append(asset)\n\n        return assets\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"media_type\", None)\n        if asset_type and asset_type in [\n            \"application/x-netcdf\",\n        ]:\n            return NetCDFReader, asset_info.get(\"reader_options\", {})\n\n        return Reader, asset_info.get(\"reader_options\", {})\n\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        \"\"\"Validate asset names and return asset's info.\n\n        Args:\n            asset (str): STAC asset name.\n\n        Returns:\n            AssetInfo: STAC asset info.\n\n        \"\"\"\n        asset, vrt_options = self._parse_vrt_asset(asset)\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        variable = None\n        if \":\" in asset:\n            asset, variable = asset.split(\":\")\n\n        asset_info = self.item.assets[asset]\n        extras = asset_info.extra_fields\n\n        info = AssetInfo(\n            url=asset_info.get_absolute_href() or asset_info.href,\n            metadata=extras if not vrt_options else None,\n        )\n\n        if STAC_ALTERNATE_KEY and extras.get(\"alternate\"):\n            if alternate := extras[\"alternate\"].get(STAC_ALTERNATE_KEY):\n                info[\"url\"] = alternate[\"href\"]\n\n        if asset_info.media_type:\n            info[\"media_type\"] = asset_info.media_type\n\n        # https://github.com/stac-extensions/file\n        if head := extras.get(\"file:header_size\"):\n            info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}\n\n        # https://github.com/stac-extensions/raster\n        if extras.get(\"raster:bands\") and not vrt_options:\n            bands = extras.get(\"raster:bands\")\n            stats = [\n                (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])\n                for b in bands\n                if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))\n            ]\n            # check that stats data are all double and make warning if not\n            if (\n                stats\n                and all(isinstance(v, (int, float)) for stat in stats for v in stat)\n                and len(stats) == len(bands)\n            ):\n                info[\"dataset_statistics\"] = stats\n            else:\n                warnings.warn(\n                    \"Some statistics data in STAC are invalid, they will be ignored.\"\n                )\n\n        if vrt_options:\n            info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"\n\n        if variable is not None:\n            info[\"reader_options\"] = {\"variable\": variable}\n\n        return info\n</pre> from typing import Set, Type, Tuple, Dict from rio_tiler.types import AssetInfo from rio_tiler.io import STACReader, BaseReader from rio_tiler.io.stac import STAC_ALTERNATE_KEY  valid_types = {     \"image/tiff; application=geotiff\",     \"application/x-netcdf\", }   @attr.s class CustomSTACReader(STACReader):     include_asset_types: Set[str] = attr.ib(default=valid_types)      def get_asset_list(self) -&gt; List[str]:         \"\"\"Get valid asset list\"\"\"         include = self.include_assets         exclude = self.exclude_assets         include_asset_types = self.include_asset_types         exclude_asset_types = self.exclude_asset_types          assets = []         for asset, asset_info in self.item.get_assets().items():             _type = asset_info.media_type              if exclude and asset in exclude:                 continue              if (                 _type                 and (exclude_asset_types and _type in exclude_asset_types)                 or (include and asset not in include)             ):                 continue              if (                 _type                 and (include_asset_types and _type not in include_asset_types)                 or (include and asset not in include)             ):                 continue              # Here check for the datacube extension             extras = asset_info.extra_fields             if variables := extras.get(\"cube:variables\"):                 assets += [f\"{asset}:{v}\" for v in list(variables)]             else:                 assets.append(asset)          return assets      def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:         \"\"\"Get Asset Reader.\"\"\"         asset_type = asset_info.get(\"media_type\", None)         if asset_type and asset_type in [             \"application/x-netcdf\",         ]:             return NetCDFReader, asset_info.get(\"reader_options\", {})          return Reader, asset_info.get(\"reader_options\", {})      def _get_asset_info(self, asset: str) -&gt; AssetInfo:         \"\"\"Validate asset names and return asset's info.          Args:             asset (str): STAC asset name.          Returns:             AssetInfo: STAC asset info.          \"\"\"         asset, vrt_options = self._parse_vrt_asset(asset)         if asset not in self.assets:             raise InvalidAssetName(                 f\"'{asset}' is not valid, should be one of {self.assets}\"             )          variable = None         if \":\" in asset:             asset, variable = asset.split(\":\")          asset_info = self.item.assets[asset]         extras = asset_info.extra_fields          info = AssetInfo(             url=asset_info.get_absolute_href() or asset_info.href,             metadata=extras if not vrt_options else None,         )          if STAC_ALTERNATE_KEY and extras.get(\"alternate\"):             if alternate := extras[\"alternate\"].get(STAC_ALTERNATE_KEY):                 info[\"url\"] = alternate[\"href\"]          if asset_info.media_type:             info[\"media_type\"] = asset_info.media_type          # https://github.com/stac-extensions/file         if head := extras.get(\"file:header_size\"):             info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}          # https://github.com/stac-extensions/raster         if extras.get(\"raster:bands\") and not vrt_options:             bands = extras.get(\"raster:bands\")             stats = [                 (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])                 for b in bands                 if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))             ]             # check that stats data are all double and make warning if not             if (                 stats                 and all(isinstance(v, (int, float)) for stat in stats for v in stat)                 and len(stats) == len(bands)             ):                 info[\"dataset_statistics\"] = stats             else:                 warnings.warn(                     \"Some statistics data in STAC are invalid, they will be ignored.\"                 )          if vrt_options:             info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"          if variable is not None:             info[\"reader_options\"] = {\"variable\": variable}          return info In\u00a0[8]: Copied! <pre>with CustomSTACReader(\"data/stac_netcdf.json\") as src:\n    print(src)\n    print(src.assets)\n    print(src._get_asset_info(\"netcdf:dataset\"))\n    img = src.preview(assets=[\"netcdf:dataset\"])\n\nplt.imshow(img.data_as_image())\n</pre> with CustomSTACReader(\"data/stac_netcdf.json\") as src:     print(src)     print(src.assets)     print(src._get_asset_info(\"netcdf:dataset\"))     img = src.preview(assets=[\"netcdf:dataset\"])  plt.imshow(img.data_as_image()) <pre>CustomSTACReader(bounds=(-170.085, 79.91999999999659, 169.91499999997504, -80.08), crs=CRS.from_epsg(4326), transform=[0.16999999999998752, 0, -170.085, 0, 0.1599999999999966, -80.08, 0, 0, 1], height=1000, width=2000, input='data/stac_netcdf.json', item=&lt;Item id=my_stac&gt;, tms=&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;, minzoom=0, maxzoom=3, include_assets=None, exclude_assets=None, exclude_asset_types=None, assets=['netcdf:dataset'], default_assets=None, reader=&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, reader_options={}, fetch_options={}, ctx=&lt;class 'rasterio.env.Env'&gt;, include_asset_types={'application/x-netcdf', 'image/tiff; application=geotiff'})\n['netcdf:dataset']\n{'url': '/Users/vincentsarago/Dev/CogeoTiff/rio-tiler/docs/src/examples/data/dataset_2d.nc', 'metadata': {'cube:variables': {'dataset': {'dimensions': ['y', 'x'], 'type': 'data'}}}, 'media_type': 'application/x-netcdf', 'reader_options': {'variable': 'dataset'}}\n</pre> Out[8]: <pre>&lt;matplotlib.image.AxesImage at 0x14a96c2e0&gt;</pre> In\u00a0[11]: Copied! <pre>from typing import Set, Type, Tuple, Dict\nfrom rio_tiler.types import AssetInfo\nfrom rio_tiler.io import STACReader, BaseReader\n\nvalid_types = {\n    \"image/tiff; application=geotiff\",\n    \"application/x-netcdf\",\n}\n\n\n@attr.s\nclass CustomSTACReader(STACReader):\n    include_asset_types: Set[str] = attr.ib(default=valid_types)\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"media_type\", None)\n        if asset_type and asset_type in [\n            \"application/x-netcdf\",\n        ]:\n            return NetCDFReader, asset_info.get(\"reader_options\", {})\n\n        return Reader, asset_info.get(\"reader_options\", {})\n\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        \"\"\"Validate asset names and return asset's info.\n\n        Args:\n            asset (str): STAC asset name.\n\n        Returns:\n            AssetInfo: STAC asset info.\n\n        \"\"\"\n        asset, vrt_options = self._parse_vrt_asset(asset)\n\n        # See how this is now before the asset validation\n        variable = None\n        if \":\" in asset:\n            asset, variable = asset.split(\":\")\n\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        asset_info = self.item.assets[asset]\n        extras = asset_info.extra_fields\n\n        info = AssetInfo(\n            url=asset_info.get_absolute_href() or asset_info.href,\n            metadata=extras if not vrt_options else None,\n        )\n\n        if STAC_ALTERNATE_KEY and extras.get(\"alternate\"):\n            if alternate := extras[\"alternate\"].get(STAC_ALTERNATE_KEY):\n                info[\"url\"] = alternate[\"href\"]\n\n        if asset_info.media_type:\n            info[\"media_type\"] = asset_info.media_type\n\n        # https://github.com/stac-extensions/file\n        if head := extras.get(\"file:header_size\"):\n            info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}\n\n        # https://github.com/stac-extensions/raster\n        if extras.get(\"raster:bands\") and not vrt_options:\n            bands = extras.get(\"raster:bands\")\n            stats = [\n                (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])\n                for b in bands\n                if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))\n            ]\n            # check that stats data are all double and make warning if not\n            if (\n                stats\n                and all(isinstance(v, (int, float)) for stat in stats for v in stat)\n                and len(stats) == len(bands)\n            ):\n                info[\"dataset_statistics\"] = stats\n            else:\n                warnings.warn(\n                    \"Some statistics data in STAC are invalid, they will be ignored.\"\n                )\n\n        if vrt_options:\n            info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"\n\n        if variable is not None:\n            info[\"reader_options\"] = {\"variable\": variable}\n\n        return info\n</pre> from typing import Set, Type, Tuple, Dict from rio_tiler.types import AssetInfo from rio_tiler.io import STACReader, BaseReader  valid_types = {     \"image/tiff; application=geotiff\",     \"application/x-netcdf\", }   @attr.s class CustomSTACReader(STACReader):     include_asset_types: Set[str] = attr.ib(default=valid_types)      def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:         \"\"\"Get Asset Reader.\"\"\"         asset_type = asset_info.get(\"media_type\", None)         if asset_type and asset_type in [             \"application/x-netcdf\",         ]:             return NetCDFReader, asset_info.get(\"reader_options\", {})          return Reader, asset_info.get(\"reader_options\", {})      def _get_asset_info(self, asset: str) -&gt; AssetInfo:         \"\"\"Validate asset names and return asset's info.          Args:             asset (str): STAC asset name.          Returns:             AssetInfo: STAC asset info.          \"\"\"         asset, vrt_options = self._parse_vrt_asset(asset)          # See how this is now before the asset validation         variable = None         if \":\" in asset:             asset, variable = asset.split(\":\")          if asset not in self.assets:             raise InvalidAssetName(                 f\"'{asset}' is not valid, should be one of {self.assets}\"             )          asset_info = self.item.assets[asset]         extras = asset_info.extra_fields          info = AssetInfo(             url=asset_info.get_absolute_href() or asset_info.href,             metadata=extras if not vrt_options else None,         )          if STAC_ALTERNATE_KEY and extras.get(\"alternate\"):             if alternate := extras[\"alternate\"].get(STAC_ALTERNATE_KEY):                 info[\"url\"] = alternate[\"href\"]          if asset_info.media_type:             info[\"media_type\"] = asset_info.media_type          # https://github.com/stac-extensions/file         if head := extras.get(\"file:header_size\"):             info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}          # https://github.com/stac-extensions/raster         if extras.get(\"raster:bands\") and not vrt_options:             bands = extras.get(\"raster:bands\")             stats = [                 (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])                 for b in bands                 if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))             ]             # check that stats data are all double and make warning if not             if (                 stats                 and all(isinstance(v, (int, float)) for stat in stats for v in stat)                 and len(stats) == len(bands)             ):                 info[\"dataset_statistics\"] = stats             else:                 warnings.warn(                     \"Some statistics data in STAC are invalid, they will be ignored.\"                 )          if vrt_options:             info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"          if variable is not None:             info[\"reader_options\"] = {\"variable\": variable}          return info In\u00a0[12]: Copied! <pre>with CustomSTACReader(\"data/stac_netcdf.json\") as src:\n    print(src)\n    print(src.assets)\n    print(src._get_asset_info(\"netcdf:dataset\"))\n    img = src.preview(assets=[\"netcdf:dataset\"])\n\nplt.imshow(img.data_as_image())\n</pre> with CustomSTACReader(\"data/stac_netcdf.json\") as src:     print(src)     print(src.assets)     print(src._get_asset_info(\"netcdf:dataset\"))     img = src.preview(assets=[\"netcdf:dataset\"])  plt.imshow(img.data_as_image()) <pre>CustomSTACReader(bounds=(-170.085, 79.91999999999659, 169.91499999997504, -80.08), crs=CRS.from_epsg(4326), transform=[0.16999999999998752, 0, -170.085, 0, 0.1599999999999966, -80.08, 0, 0, 1], height=1000, width=2000, input='data/stac_netcdf.json', item=&lt;Item id=my_stac&gt;, tms=&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;, minzoom=0, maxzoom=3, include_assets=None, exclude_assets=None, exclude_asset_types=None, assets=['netcdf'], default_assets=None, reader=&lt;class 'rio_tiler.io.rasterio.Reader'&gt;, reader_options={}, fetch_options={}, ctx=&lt;class 'rasterio.env.Env'&gt;, include_asset_types={'application/x-netcdf', 'image/tiff; application=geotiff'})\n['netcdf']\n{'url': '/Users/vincentsarago/Dev/CogeoTiff/rio-tiler/docs/src/examples/data/dataset_2d.nc', 'metadata': {'cube:variables': {'dataset': {'dimensions': ['y', 'x'], 'type': 'data'}}}, 'media_type': 'application/x-netcdf', 'reader_options': {'variable': 'dataset'}}\n</pre> Out[12]: <pre>&lt;matplotlib.image.AxesImage at 0x14ac1c7f0&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/STAC_datacube_support/#add-support-for-stac-datacube-extension","title":"Add support for STAC Datacube extension\u00b6","text":""},{"location":"examples/STAC_datacube_support/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=7.0</li> <li>xarray</li> <li>rioxarray</li> <li>h5netcdf</li> <li>matplotlib</li> </ul>"},{"location":"examples/STAC_datacube_support/#1-simple-netcdf-reader","title":"1. Simple NetCDF reader\u00b6","text":""},{"location":"examples/STAC_datacube_support/#2-custom-stac-reader","title":"2. Custom STAC reader\u00b6","text":""},{"location":"examples/STAC_datacube_support/#3-supporting-netcdf-without-datacube","title":"3. Supporting NetCDF without datacube\u00b6","text":"<p>YOu can also support <code>NetCDF</code> files without the datacube extension by customizing the <code>_get_asset_info</code> and <code>_get_reader</code>. The customization consist by adding a <code>asset virtual format</code> (as we do for VRT) in form of <code>{asset_name}:{variable_name}</code></p>"},{"location":"examples/Using-nonEarth-dataset/","title":"Using Non Earth dataset","text":"<p>Starting with version 3.0, rio-tiler can work with non-earth based dataset (e.g Mars data). In this notebook we'll show how to read such dataset and how to create a simple <code>non-earth</code> Tile server.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n# !pip install matplotlib\n# !pip install tornado\n</pre> # !pip install rio-tiler # !pip install ipyleaflet # !pip install matplotlib # !pip install tornado In\u00a0[2]: Copied! <pre>from matplotlib.pyplot import imshow\n\n# In order to fully work, we'll need to build a custom TileMatrixSet\nfrom morecantile import TileMatrixSet\nfrom pyproj import CRS\n\nfrom rio_tiler.io import Reader\n\n# For this DEMO we will use this file\nsrc_path = \"https://raw.githubusercontent.com/cogeotiff/rio-tiler/main/tests/fixtures/cog_nonearth.tif\"\n</pre> from matplotlib.pyplot import imshow  # In order to fully work, we'll need to build a custom TileMatrixSet from morecantile import TileMatrixSet from pyproj import CRS  from rio_tiler.io import Reader  # For this DEMO we will use this file src_path = \"https://raw.githubusercontent.com/cogeotiff/rio-tiler/main/tests/fixtures/cog_nonearth.tif\" In\u00a0[\u00a0]: Copied! <pre># Let's first try with default\nwith Reader(src_path) as src:\n    print(src.info().model_dump_json())\n</pre> # Let's first try with default with Reader(src_path) as src:     print(src.info().model_dump_json()) In\u00a0[\u00a0]: Copied! <pre># Create a CUSTOM TMS using the europa ESRI:104915 projection\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs,\n    extent=europa_crs.area_of_use.bounds,\n    matrix_scale=[2, 1],\n)\n\n# Use Custom TMS instead of Web Mercator\nwith Reader(src_path, tms=europa_tms) as src:\n    print(src.info().model_dump_json())\n    img = src.preview()\n    imshow(img.data_as_image())\n</pre> # Create a CUSTOM TMS using the europa ESRI:104915 projection europa_crs = CRS.from_authority(\"ESRI\", 104915) europa_tms = TileMatrixSet.custom(     crs=europa_crs,     extent=europa_crs.area_of_use.bounds,     matrix_scale=[2, 1], )  # Use Custom TMS instead of Web Mercator with Reader(src_path, tms=europa_tms) as src:     print(src.info().model_dump_json())     img = src.preview()     imshow(img.data_as_image()) In\u00a0[\u00a0]: Copied! <pre># Read a Tile\nfrom rasterio.warp import transform_bounds\n\nwith Reader(src_path, tms=europa_tms) as src:\n    # get dataset bounds in TMS's CRS projection\n    bounds_in_tms = transform_bounds(src.crs, europa_tms.rasterio_crs, *src.bounds)\n    tile = src.tms._tile(bounds_in_tms[0], bounds_in_tms[1], src.minzoom)\n    print(tile)\n\n    img = src.tile(tile.x, tile.y, tile.z)\n    imshow(img.data_as_image())\n</pre> # Read a Tile from rasterio.warp import transform_bounds  with Reader(src_path, tms=europa_tms) as src:     # get dataset bounds in TMS's CRS projection     bounds_in_tms = transform_bounds(src.crs, europa_tms.rasterio_crs, *src.bounds)     tile = src.tms._tile(bounds_in_tms[0], bounds_in_tms[1], src.minzoom)     print(tile)      img = src.tile(tile.x, tile.y, tile.z)     imshow(img.data_as_image()) In\u00a0[7]: Copied! <pre>from ipyleaflet import Map, TileLayer, projections\n</pre> from ipyleaflet import Map, TileLayer, projections In\u00a0[8]: Copied! <pre>from concurrent import futures\n\nfrom morecantile import TileMatrixSet\nfrom pyproj import CRS\nfrom tornado import gen, web\nfrom tornado.concurrent import run_on_executor\nfrom tornado.httpserver import HTTPServer\n\nfrom rio_tiler.errors import TileOutsideBounds\nfrom rio_tiler.io import Reader\nfrom rio_tiler.profiles import img_profiles\n\n# Create a CUSTOM TMS using the europa ESRI:104915 projection\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs,\n    extent=europa_crs.area_of_use.bounds,\n    matrix_scale=[2, 1],\n)\n\n\nclass TileServer:\n    def __init__(self, src_path):\n        \"\"\"Initialize Tornado app.\"\"\"\n        self.server = None\n        self.app = web.Application(\n            [\n                (r\"^/tiles/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),\n            ]\n        )\n\n    def start(self):\n        \"\"\"Start tile server.\"\"\"\n        self.server = HTTPServer(self.app)\n        self.server.listen(8080)\n\n    def stop(self):\n        \"\"\"Stop tile server.\"\"\"\n        if self.server:\n            self.server.stop()\n\n\nclass TileHandler(web.RequestHandler):\n    \"\"\"Tile requests handler.\"\"\"\n\n    executor = futures.ThreadPoolExecutor(max_workers=16)\n\n    def initialize(self, url):\n        \"\"\"Initialize tiles handler.\"\"\"\n        self.url = url\n\n    @run_on_executor\n    def _get_tile(self, z, x, y):\n        try:\n            with Reader(self.url, tms=europa_tms) as src:\n                data = src.tile(x, y, z)\n        except TileOutsideBounds:\n            raise web.HTTPError(404)\n\n        image = data.post_process(in_range=((0, 0.5),))\n\n        prof = img_profiles.get(\"PNG\", {})\n        return image.render(img_format=\"PNG\", **prof)\n\n    @gen.coroutine\n    def get(self, z, x, y):\n        \"\"\"Retunrs tile data and header.\"\"\"\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET\")\n        self.set_header(\"Content-Type\", \"image/png\")\n        self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")\n        res = yield self._get_tile(int(z), int(x), int(y))\n        self.write(res)\n\n\nts = TileServer(src_path)\nts.start()\n</pre> from concurrent import futures  from morecantile import TileMatrixSet from pyproj import CRS from tornado import gen, web from tornado.concurrent import run_on_executor from tornado.httpserver import HTTPServer  from rio_tiler.errors import TileOutsideBounds from rio_tiler.io import Reader from rio_tiler.profiles import img_profiles  # Create a CUSTOM TMS using the europa ESRI:104915 projection europa_crs = CRS.from_authority(\"ESRI\", 104915) europa_tms = TileMatrixSet.custom(     crs=europa_crs,     extent=europa_crs.area_of_use.bounds,     matrix_scale=[2, 1], )   class TileServer:     def __init__(self, src_path):         \"\"\"Initialize Tornado app.\"\"\"         self.server = None         self.app = web.Application(             [                 (r\"^/tiles/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),             ]         )      def start(self):         \"\"\"Start tile server.\"\"\"         self.server = HTTPServer(self.app)         self.server.listen(8080)      def stop(self):         \"\"\"Stop tile server.\"\"\"         if self.server:             self.server.stop()   class TileHandler(web.RequestHandler):     \"\"\"Tile requests handler.\"\"\"      executor = futures.ThreadPoolExecutor(max_workers=16)      def initialize(self, url):         \"\"\"Initialize tiles handler.\"\"\"         self.url = url      @run_on_executor     def _get_tile(self, z, x, y):         try:             with Reader(self.url, tms=europa_tms) as src:                 data = src.tile(x, y, z)         except TileOutsideBounds:             raise web.HTTPError(404)          image = data.post_process(in_range=((0, 0.5),))          prof = img_profiles.get(\"PNG\", {})         return image.render(img_format=\"PNG\", **prof)      @gen.coroutine     def get(self, z, x, y):         \"\"\"Retunrs tile data and header.\"\"\"         self.set_header(\"Access-Control-Allow-Origin\", \"*\")         self.set_header(\"Access-Control-Allow-Methods\", \"GET\")         self.set_header(\"Content-Type\", \"image/png\")         self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")         res = yield self._get_tile(int(z), int(x), int(y))         self.write(res)   ts = TileServer(src_path) ts.start() In\u00a0[\u00a0]: Copied! <pre>bounds = (129.36834223297478, 13.985559117409744, 138.90253908503576, 23.13673177454536)\n\nm = Map(\n    center=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom=4,\n    basemap={},\n    crs=projections.EPSG4326,  # HACK: the europa TMS is in degree and covers -180, -90, 180, 90 like the WGS84\n)\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/{z}/{x}/{y}\",\n    min_zoom=4,\n    max_zoom=6,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> bounds = (129.36834223297478, 13.985559117409744, 138.90253908503576, 23.13673177454536)  m = Map(     center=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom=4,     basemap={},     crs=projections.EPSG4326,  # HACK: the europa TMS is in degree and covers -180, -90, 180, 90 like the WGS84 )  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/{z}/{x}/{y}\",     min_zoom=4,     max_zoom=6,     opacity=1, ) m.add_layer(layer) m In\u00a0[11]: Copied! <pre>ts.stop()\n</pre> ts.stop() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-nonEarth-dataset/#using-non-earth-dataset","title":"Using Non Earth dataset\u00b6","text":""},{"location":"examples/Using-nonEarth-dataset/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=7.0</li> <li>ipyleaflet</li> <li>matplotlib</li> <li>tornado</li> </ul>"},{"location":"examples/Using-nonEarth-dataset/#tile-server","title":"Tile Server\u00b6","text":""},{"location":"examples/Using-nonEarth-dataset/#requirements","title":"Requirements\u00b6","text":"<ul> <li>tornado</li> </ul>"},{"location":"examples/Using-rio-tiler-STACReader/","title":"Introduction to rio-tiler + STAC","text":"<p>The goal of this notebook is to give a quick introduction of the rio-tiler STACReader.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler matplotlib\n</pre> # !pip install rio-tiler matplotlib In\u00a0[1]: Copied! <pre>from matplotlib.pyplot import imshow, subplots\n\nfrom rio_tiler.io import STACReader\nfrom rio_tiler.models import ImageData\n</pre> from matplotlib.pyplot import imshow, subplots  from rio_tiler.io import STACReader from rio_tiler.models import ImageData In\u00a0[2]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\"\n</pre> # For this DEMO we will use this file src_path = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" In\u00a0[\u00a0]: Copied! <pre>?STACReader\n</pre> ?STACReader In\u00a0[\u00a0]: Copied! <pre>with STACReader(src_path) as stac:\n    pass\n\n# see the list of available assets\nprint(stac.assets)\n\n# print the bounds\nprint(stac.bounds)\nprint(stac.crs)\n</pre> with STACReader(src_path) as stac:     pass  # see the list of available assets print(stac.assets)  # print the bounds print(stac.bounds) print(stac.crs) In\u00a0[\u00a0]: Copied! <pre>with STACReader(src_path) as stac:\n    # This method will return a Dict of `{asset: rio_tiler.models.Info, asset2: rio_tiler.models.Info}`\n    # Checkout the docs https://cogeotiff.github.io/rio-tiler/models/#info for more info about the model.\n    info = stac.info(assets=(\"B01\", \"B02\"))\n    print(\"B01:\")\n    print(info[\"B01\"].model_dump(exclude_none=True))\n    print(\"B02:\")\n    print(info[\"B02\"].model_dump(exclude_none=True))\n</pre> with STACReader(src_path) as stac:     # This method will return a Dict of `{asset: rio_tiler.models.Info, asset2: rio_tiler.models.Info}`     # Checkout the docs https://cogeotiff.github.io/rio-tiler/models/#info for more info about the model.     info = stac.info(assets=(\"B01\", \"B02\"))     print(\"B01:\")     print(info[\"B01\"].model_dump(exclude_none=True))     print(\"B02:\")     print(info[\"B02\"].model_dump(exclude_none=True)) In\u00a0[\u00a0]: Copied! <pre>with STACReader(src_path) as stac:\n    meta = stac.statistics(\n        assets=(\"B01\", \"B02\", \"B03\", \"B04\"), max_size=256\n    )  # Here we use max_size option to limit the data transfer (default to 1024)\n    print(\"available assets statistics:\")\n    print(list(meta))\n    print()\n    print(\"statistics for asset B01:\")\n    # For each asset, we will get a Dict in form of {\"1\": BandStatistics(...), ...} with `1` being the band index.\n    print(meta[\"B01\"])\n</pre> with STACReader(src_path) as stac:     meta = stac.statistics(         assets=(\"B01\", \"B02\", \"B03\", \"B04\"), max_size=256     )  # Here we use max_size option to limit the data transfer (default to 1024)     print(\"available assets statistics:\")     print(list(meta))     print()     print(\"statistics for asset B01:\")     # For each asset, we will get a Dict in form of {\"1\": BandStatistics(...), ...} with `1` being the band index.     print(meta[\"B01\"]) In\u00a0[\u00a0]: Copied! <pre>fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)\n\naxs[0].plot(meta[\"B01\"][\"b1\"].histogram[1][0:-1], meta[\"B01\"][\"b1\"].histogram[0])\naxs[1].plot(meta[\"B02\"][\"b1\"].histogram[1][0:-1], meta[\"B02\"][\"b1\"].histogram[0])\naxs[2].plot(meta[\"B03\"][\"b1\"].histogram[1][0:-1], meta[\"B03\"][\"b1\"].histogram[0])\naxs[3].plot(meta[\"B04\"][\"b1\"].histogram[1][0:-1], meta[\"B04\"][\"b1\"].histogram[0])\n</pre> fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)  axs[0].plot(meta[\"B01\"][\"b1\"].histogram[1][0:-1], meta[\"B01\"][\"b1\"].histogram[0]) axs[1].plot(meta[\"B02\"][\"b1\"].histogram[1][0:-1], meta[\"B02\"][\"b1\"].histogram[0]) axs[2].plot(meta[\"B03\"][\"b1\"].histogram[1][0:-1], meta[\"B03\"][\"b1\"].histogram[0]) axs[3].plot(meta[\"B04\"][\"b1\"].histogram[1][0:-1], meta[\"B04\"][\"b1\"].histogram[0]) In\u00a0[\u00a0]: Copied! <pre>with STACReader(src_path) as stac:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    img = stac.preview(assets=(\"B04\", \"B03\", \"B02\"), max_size=256)\n    print(img.data.shape)\n    # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata\n    assert isinstance(img, ImageData)\n</pre> with STACReader(src_path) as stac:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     img = stac.preview(assets=(\"B04\", \"B03\", \"B02\"), max_size=256)     print(img.data.shape)     # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata     assert isinstance(img, ImageData) In\u00a0[\u00a0]: Copied! <pre># Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL)\n# in order to display the data we need to change the order (using rasterio.plot.array_to_image).\n# the ImageData class wraps the rasterio function in the `data_as_image()` method.\nprint(type(img))\nprint(img.data.shape)\n\nimage = img.data_as_image()\n# data_as_image() returns a numpy.ndarray in form of (col, row, band)\nprint(type(image))\nprint(image.shape)\n\nimshow(image)\n</pre> # Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL) # in order to display the data we need to change the order (using rasterio.plot.array_to_image). # the ImageData class wraps the rasterio function in the `data_as_image()` method. print(type(img)) print(img.data.shape)  image = img.data_as_image() # data_as_image() returns a numpy.ndarray in form of (col, row, band) print(type(image)) print(image.shape)  imshow(image) In\u00a0[\u00a0]: Copied! <pre># The sentinel data is stored as UInt16, we need to do some data rescaling to display data from 0 to 255\nprint(img.data.min(), img.data.max())\n\nimg.rescale(in_range=((0, 10000),))\nprint(img.data.min(), img.data.max())\n\nimage = img.data_as_image()\nimshow(image)\n</pre> # The sentinel data is stored as UInt16, we need to do some data rescaling to display data from 0 to 255 print(img.data.min(), img.data.max())  img.rescale(in_range=((0, 10000),)) print(img.data.min(), img.data.max())  image = img.data_as_image() imshow(image) In\u00a0[\u00a0]: Copied! <pre>with STACReader(src_path) as stac:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    img = stac.preview(expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\", max_size=256)\n    print(img.data.shape)\n    # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata\n    assert isinstance(img, ImageData)\n\n# NDVI data range should be between -1 and 1\nprint(img.data.min(), img.data.max())\n\nimg.rescale(in_range=((-1, 1),))\nimage = img.data_as_image()\nimshow(image)\n</pre> with STACReader(src_path) as stac:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     img = stac.preview(expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\", max_size=256)     print(img.data.shape)     # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata     assert isinstance(img, ImageData)  # NDVI data range should be between -1 and 1 print(img.data.min(), img.data.max())  img.rescale(in_range=((-1, 1),)) image = img.data_as_image() imshow(image) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-STACReader/#introduction-to-rio-tiler-stac","title":"Introduction to rio-tiler + STAC\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=7.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler-STACReader/#data","title":"Data\u00b6","text":"<p>For this demo we will use a STAC Item for the Sentinel-2 data stored as COGs on AWS.</p>"},{"location":"examples/Using-rio-tiler-STACReader/#sentinel-2-cogs","title":"Sentinel 2 COGs\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p>"},{"location":"examples/Using-rio-tiler-STACReader/#rio_tileriostacreader","title":"rio_tiler.io.STACReader\u00b6","text":"<p>In <code>rio-tiler</code> 2.0 we introduced STACReader, which is a python class providing usefull methods get and parse the STAC item and then read and inspect any GDAL/rasterio raster assets.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/readers/#stacreader</p>"},{"location":"examples/Using-rio-tiler-STACReader/#initialize-the-reader","title":"Initialize the Reader\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#info","title":"Info\u00b6","text":"<p>Get some info about some assets</p>"},{"location":"examples/Using-rio-tiler-STACReader/#statistics","title":"Statistics\u00b6","text":"<p>Return basic data statistics</p>"},{"location":"examples/Using-rio-tiler-STACReader/#plot-histogram-values","title":"Plot Histogram values\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#preview","title":"Preview\u00b6","text":"<p>Read a low resolution version of the data (useful when working with COG, because this method will only fetch the overview layer it needs)</p>"},{"location":"examples/Using-rio-tiler-STACReader/#display-the-data","title":"Display the data\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#use-expression","title":"Use Expression\u00b6","text":""},{"location":"examples/Using-rio-tiler-XarrayReader/","title":"Xarray + rio-tiler","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport xarray\n\nfrom rio_tiler.io.xarray import XarrayReader\n</pre> import matplotlib.pyplot as plt import xarray  from rio_tiler.io.xarray import XarrayReader In\u00a0[2]: Copied! <pre>ds = xarray.open_dataset(\n    \"https://mur-sst.s3.us-west-2.amazonaws.com/zarr-v1\",\n    engine=\"zarr\",\n    decode_coords=\"all\",\n    consolidated=True,\n)\nds\n</pre> ds = xarray.open_dataset(     \"https://mur-sst.s3.us-west-2.amazonaws.com/zarr-v1\",     engine=\"zarr\",     decode_coords=\"all\",     consolidated=True, ) ds Out[2]: <pre>&lt;xarray.Dataset&gt; Size: 117TB\nDimensions:           (time: 6443, lat: 17999, lon: 36000)\nCoordinates:\n  * lat               (lat) float32 72kB -89.99 -89.98 -89.97 ... 89.98 89.99\n  * lon               (lon) float32 144kB -180.0 -180.0 -180.0 ... 180.0 180.0\n  * time              (time) datetime64[ns] 52kB 2002-06-01T09:00:00 ... 2020...\nData variables:\n    analysed_sst      (time, lat, lon) float64 33TB ...\n    analysis_error    (time, lat, lon) float64 33TB ...\n    mask              (time, lat, lon) float32 17TB ...\n    sea_ice_fraction  (time, lat, lon) float64 33TB ...\nAttributes: (12/47)\n    Conventions:                CF-1.7\n    Metadata_Conventions:       Unidata Observation Dataset v1.0\n    acknowledgment:             Please acknowledge the use of these data with...\n    cdm_data_type:              grid\n    comment:                    MUR = \"Multi-scale Ultra-high Resolution\"\n    creator_email:              ghrsst@podaac.jpl.nasa.gov\n    ...                         ...\n    summary:                    A merged, multi-sensor L4 Foundation SST anal...\n    time_coverage_end:          20200116T210000Z\n    time_coverage_start:        20200115T210000Z\n    title:                      Daily MUR SST, Final product\n    uuid:                       27665bc0-d5fc-11e1-9b23-0800200c9a66\n    westernmost_longitude:      -180.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 6443</li><li>lat: 17999</li><li>lon: 36000</li></ul></li><li>Coordinates: (3)<ul><li>lat(lat)float32-89.99 -89.98 ... 89.98 89.99axis :Ycomment :nonelong_name :latitudestandard_name :latitudeunits :degrees_northvalid_max :90.0valid_min :-90.0<pre>array([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)</pre></li><li>lon(lon)float32-180.0 -180.0 ... 180.0 180.0axis :Xcomment :nonelong_name :longitudestandard_name :longitudeunits :degrees_eastvalid_max :180.0valid_min :-180.0<pre>array([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)</pre></li><li>time(time)datetime64[ns]2002-06-01T09:00:00 ... 2020-01-...axis :Tcomment :Nominal time of analyzed fieldslong_name :reference time of sst fieldstandard_name :time<pre>array(['2002-06-01T09:00:00.000000000', '2002-06-02T09:00:00.000000000',\n       '2002-06-03T09:00:00.000000000', ..., '2020-01-18T09:00:00.000000000',\n       '2020-01-19T09:00:00.000000000', '2020-01-20T09:00:00.000000000'],\n      dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (4)<ul><li>analysed_sst(time, lat, lon)float64...comment :\"Final\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationlong_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_max :32767valid_min :-32767<pre>[4174832052000 values with dtype=float64]</pre></li><li>analysis_error(time, lat, lon)float64...comment :nonelong_name :estimated error standard deviation of analysed_sstunits :kelvinvalid_max :32767valid_min :0<pre>[4174832052000 values with dtype=float64]</pre></li><li>mask(time, lat, lon)float32...comment :mask can be used to further filter the data.flag_masks :[1, 2, 4, 8, 16]flag_meanings :1=open-sea, 2=land, 5=open-lake, 9=open-sea with ice in the grid, 13=open-lake with ice in the gridflag_values :[1, 2, 5, 9, 13]long_name :sea/land field composite masksource :GMT \"grdlandmask\", ice flag from sea_ice_fraction datavalid_max :31valid_min :1<pre>[4174832052000 values with dtype=float32]</pre></li><li>sea_ice_fraction(time, lat, lon)float64...comment :ice data interpolated by a nearest neighbor approach.long_name :sea ice area fractionsource :EUMETSAT OSI-SAF, copyright EUMETSATstandard_name :sea ice area fractionunits :fraction (between 0 and 1)valid_max :100valid_min :0<pre>[4174832052000 values with dtype=float64]</pre></li></ul></li><li>Indexes: (3)<ul><li>latPandasIndex<pre>PandasIndex(Index([-89.98999786376953,  -89.9800033569336, -89.97000122070312,\n       -89.95999908447266, -89.94999694824219, -89.94000244140625,\n       -89.93000030517578, -89.91999816894531, -89.91000366210938,\n        -89.9000015258789,\n       ...\n         89.9000015258789,  89.91000366210938,  89.91999816894531,\n        89.93000030517578,  89.94000244140625,  89.94999694824219,\n        89.95999908447266,  89.97000122070312,   89.9800033569336,\n        89.98999786376953],\n      dtype='float32', name='lat', length=17999))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([-179.99000549316406, -179.97999572753906, -179.97000122070312,\n        -179.9600067138672,  -179.9499969482422, -179.94000244140625,\n       -179.92999267578125,  -179.9199981689453, -179.91000366210938,\n       -179.89999389648438,\n       ...\n        179.91000366210938,   179.9199981689453,  179.92999267578125,\n        179.94000244140625,   179.9499969482422,   179.9600067138672,\n        179.97000122070312,  179.97999572753906,  179.99000549316406,\n                     180.0],\n      dtype='float32', name='lon', length=36000))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2002-06-01 09:00:00', '2002-06-02 09:00:00',\n               '2002-06-03 09:00:00', '2002-06-04 09:00:00',\n               '2002-06-05 09:00:00', '2002-06-06 09:00:00',\n               '2002-06-07 09:00:00', '2002-06-08 09:00:00',\n               '2002-06-09 09:00:00', '2002-06-10 09:00:00',\n               ...\n               '2020-01-11 09:00:00', '2020-01-12 09:00:00',\n               '2020-01-13 09:00:00', '2020-01-14 09:00:00',\n               '2020-01-15 09:00:00', '2020-01-16 09:00:00',\n               '2020-01-17 09:00:00', '2020-01-18 09:00:00',\n               '2020-01-19 09:00:00', '2020-01-20 09:00:00'],\n              dtype='datetime64[ns]', name='time', length=6443, freq=None))</pre></li></ul></li><li>Attributes: (47)Conventions :CF-1.7Metadata_Conventions :Unidata Observation Dataset v1.0acknowledgment :Please acknowledge the use of these data with the following statement:  These data were provided by JPL under support by NASA MEaSUREs program.cdm_data_type :gridcomment :MUR = \"Multi-scale Ultra-high Resolution\"creator_email :ghrsst@podaac.jpl.nasa.govcreator_name :JPL MUR SST projectcreator_url :http://mur.jpl.nasa.govdate_created :20200124T010755Zeasternmost_longitude :180.0file_quality_level :3gds_version_id :2.0geospatial_lat_resolution :0.009999999776482582geospatial_lat_units :degrees northgeospatial_lon_resolution :0.009999999776482582geospatial_lon_units :degrees easthistory :created at nominal 4-day latency; replaced nrt (1-day latency) version.id :MUR-JPL-L4-GLOB-v04.1institution :Jet Propulsion Laboratorykeywords :Oceans &gt; Ocean Temperature &gt; Sea Surface Temperaturekeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :These data are available free of charge under data policy of JPL PO.DAAC.metadata_link :http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&amp;shortName=MUR-JPL-L4-GLOB-v04.1naming_authority :org.ghrsstnetcdf_version_id :4.1northernmost_latitude :90.0platform :Terra, Aqua, GCOM-W, MetOp-A, MetOp-B, Buoys/Shipsprocessing_level :L4product_version :04.1project :NASA Making Earth Science Data Records for Use in Research Environments (MEaSUREs) Programpublisher_email :ghrsst-po@nceo.ac.ukpublisher_name :GHRSST Project Officepublisher_url :http://www.ghrsst.orgreferences :http://podaac.jpl.nasa.gov/Multi-scale_Ultra-high_Resolution_MUR-SSTsensor :MODIS, AMSR2, AVHRR, in-situsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAFsouthernmost_latitude :-90.0spatial_resolution :0.01 degreesstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Metadata Conventionstart_time :20200116T090000Zstop_time :20200116T090000Zsummary :A merged, multi-sensor L4 Foundation SST analysis product from JPL.time_coverage_end :20200116T210000Ztime_coverage_start :20200115T210000Ztitle :Daily MUR SST, Final productuuid :27665bc0-d5fc-11e1-9b23-0800200c9a66westernmost_longitude :-180.0</li></ul> In\u00a0[3]: Copied! <pre>da = ds[\"analysed_sst\"]\nda\n</pre> da = ds[\"analysed_sst\"] da Out[3]: <pre>&lt;xarray.DataArray 'analysed_sst' (time: 6443, lat: 17999, lon: 36000)&gt; Size: 33TB\n[4174832052000 values with dtype=float64]\nCoordinates:\n  * lat      (lat) float32 72kB -89.99 -89.98 -89.97 ... 89.97 89.98 89.99\n  * lon      (lon) float32 144kB -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time     (time) datetime64[ns] 52kB 2002-06-01T09:00:00 ... 2020-01-20T09...\nAttributes:\n    comment:        \"Final\" version using Multi-Resolution Variational Analys...\n    long_name:      analysed sea surface temperature\n    standard_name:  sea_surface_foundation_temperature\n    units:          kelvin\n    valid_max:      32767\n    valid_min:      -32767</pre>xarray.DataArray'analysed_sst'<ul><li>time: 6443</li><li>lat: 17999</li><li>lon: 36000</li></ul><ul><li>...<pre>[4174832052000 values with dtype=float64]</pre></li><li>Coordinates: (3)<ul><li>lat(lat)float32-89.99 -89.98 ... 89.98 89.99axis :Ycomment :nonelong_name :latitudestandard_name :latitudeunits :degrees_northvalid_max :90.0valid_min :-90.0<pre>array([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)</pre></li><li>lon(lon)float32-180.0 -180.0 ... 180.0 180.0axis :Xcomment :nonelong_name :longitudestandard_name :longitudeunits :degrees_eastvalid_max :180.0valid_min :-180.0<pre>array([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)</pre></li><li>time(time)datetime64[ns]2002-06-01T09:00:00 ... 2020-01-...axis :Tcomment :Nominal time of analyzed fieldslong_name :reference time of sst fieldstandard_name :time<pre>array(['2002-06-01T09:00:00.000000000', '2002-06-02T09:00:00.000000000',\n       '2002-06-03T09:00:00.000000000', ..., '2020-01-18T09:00:00.000000000',\n       '2020-01-19T09:00:00.000000000', '2020-01-20T09:00:00.000000000'],\n      dtype='datetime64[ns]')</pre></li></ul></li><li>Indexes: (3)<ul><li>latPandasIndex<pre>PandasIndex(Index([-89.98999786376953,  -89.9800033569336, -89.97000122070312,\n       -89.95999908447266, -89.94999694824219, -89.94000244140625,\n       -89.93000030517578, -89.91999816894531, -89.91000366210938,\n        -89.9000015258789,\n       ...\n         89.9000015258789,  89.91000366210938,  89.91999816894531,\n        89.93000030517578,  89.94000244140625,  89.94999694824219,\n        89.95999908447266,  89.97000122070312,   89.9800033569336,\n        89.98999786376953],\n      dtype='float32', name='lat', length=17999))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([-179.99000549316406, -179.97999572753906, -179.97000122070312,\n        -179.9600067138672,  -179.9499969482422, -179.94000244140625,\n       -179.92999267578125,  -179.9199981689453, -179.91000366210938,\n       -179.89999389648438,\n       ...\n        179.91000366210938,   179.9199981689453,  179.92999267578125,\n        179.94000244140625,   179.9499969482422,   179.9600067138672,\n        179.97000122070312,  179.97999572753906,  179.99000549316406,\n                     180.0],\n      dtype='float32', name='lon', length=36000))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2002-06-01 09:00:00', '2002-06-02 09:00:00',\n               '2002-06-03 09:00:00', '2002-06-04 09:00:00',\n               '2002-06-05 09:00:00', '2002-06-06 09:00:00',\n               '2002-06-07 09:00:00', '2002-06-08 09:00:00',\n               '2002-06-09 09:00:00', '2002-06-10 09:00:00',\n               ...\n               '2020-01-11 09:00:00', '2020-01-12 09:00:00',\n               '2020-01-13 09:00:00', '2020-01-14 09:00:00',\n               '2020-01-15 09:00:00', '2020-01-16 09:00:00',\n               '2020-01-17 09:00:00', '2020-01-18 09:00:00',\n               '2020-01-19 09:00:00', '2020-01-20 09:00:00'],\n              dtype='datetime64[ns]', name='time', length=6443, freq=None))</pre></li></ul></li><li>Attributes: (6)comment :\"Final\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationlong_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_max :32767valid_min :-32767</li></ul> In\u00a0[4]: Copied! <pre>da = ds[\"analysed_sst\"]\n\n# Make sure we have a valid CRS\ncrs = da.rio.crs or \"epsg:4326\"\nda.rio.write_crs(crs, inplace=True)\n\n# Select the first time stamp\nda = da.isel(time=0)\n\nwith XarrayReader(da) as dst:\n    print(dst.info())\n    print(dst.minzoom, dst.maxzoom)\n</pre> da = ds[\"analysed_sst\"]  # Make sure we have a valid CRS crs = da.rio.crs or \"epsg:4326\" da.rio.write_crs(crs, inplace=True)  # Select the first time stamp da = da.isel(time=0)  with XarrayReader(da) as dst:     print(dst.info())     print(dst.minzoom, dst.maxzoom) <pre>bounds=(-179.99500549324037, -89.99499786365084, 180.0050000000763, 89.99499786365084) crs='http://www.opengis.net/def/crs/EPSG/0/4326' band_metadata=[('b1', {})] band_descriptions=[('b1', 'value')] dtype='float64' nodata_type='Nodata' colorinterp=None scales=None offsets=None colormap=None name='analysed_sst' count=1 width=36000 height=17999 attrs={'comment': '\"Final\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolation', 'long_name': 'analysed sea surface temperature', 'standard_name': 'sea_surface_foundation_temperature', 'units': 'kelvin', 'valid_max': 32767, 'valid_min': -32767}\n0 6\n</pre> In\u00a0[5]: Copied! <pre>with XarrayReader(da) as dst:\n    img = dst.tile(31, 22, 6)\n\nplt.imshow(img.data_as_image())\n</pre> with XarrayReader(da) as dst:     img = dst.tile(31, 22, 6)  plt.imshow(img.data_as_image()) Out[5]: <pre>&lt;matplotlib.image.AxesImage at 0x11aeca1f0&gt;</pre> In\u00a0[6]: Copied! <pre>with XarrayReader(da) as dst:\n    img = dst.part(\n        [-5, 45, 0.0, 49],\n        max_size=1024,\n    )\n\nplt.imshow(img.data_as_image())\n</pre> with XarrayReader(da) as dst:     img = dst.part(         [-5, 45, 0.0, 49],         max_size=1024,     )  plt.imshow(img.data_as_image()) Out[6]: <pre>&lt;matplotlib.image.AxesImage at 0x11b6b6c40&gt;</pre> In\u00a0[7]: Copied! <pre>geojson = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"coordinates\": [\n            [\n                [-4.262517145703015, 49.58852771128011],\n                [-6.121754821536115, 48.07366436953052],\n                [-5.679508966604999, 47.26534294147169],\n                [-2.890652452854056, 46.8101748147248],\n                [-1.8527423498805433, 47.28371740880311],\n                [-1.6541805026549241, 49.26565692911578],\n                [-3.0440846882388257, 49.565118360747164],\n                [-4.262517145703015, 49.58852771128011],\n            ]\n        ],\n        \"type\": \"Polygon\",\n    },\n}\n\nwith XarrayReader(da) as dst:\n    img = dst.feature(\n        geojson,\n        max_size=1024,\n    )\n\nplt.imshow(img.data_as_image())\n</pre> geojson = {     \"type\": \"Feature\",     \"properties\": {},     \"geometry\": {         \"coordinates\": [             [                 [-4.262517145703015, 49.58852771128011],                 [-6.121754821536115, 48.07366436953052],                 [-5.679508966604999, 47.26534294147169],                 [-2.890652452854056, 46.8101748147248],                 [-1.8527423498805433, 47.28371740880311],                 [-1.6541805026549241, 49.26565692911578],                 [-3.0440846882388257, 49.565118360747164],                 [-4.262517145703015, 49.58852771128011],             ]         ],         \"type\": \"Polygon\",     }, }  with XarrayReader(da) as dst:     img = dst.feature(         geojson,         max_size=1024,     )  plt.imshow(img.data_as_image()) Out[7]: <pre>&lt;matplotlib.image.AxesImage at 0x11aeb80d0&gt;</pre> In\u00a0[8]: Copied! <pre>import fsspec\n\nfilesystem = fsspec.filesystem(\"https\")\n\nfp = filesystem.open(\n    \"https://dap.ceda.ac.uk/neodc/esacci/land_surface_temperature/data/MULTISENSOR_IRCDR/L3S/0.01/v2.00/monthly/2020/11/ESACCI-LST-L3S-LST-IRCDR_-0.01deg_1MONTHLY_DAY-20201101000000-fv2.00.nc\"\n)\nds = xarray.open_dataset(\n    fp,\n    engine=\"h5netcdf\",\n    decode_coords=\"all\",\n)\nds\n</pre> import fsspec  filesystem = fsspec.filesystem(\"https\")  fp = filesystem.open(     \"https://dap.ceda.ac.uk/neodc/esacci/land_surface_temperature/data/MULTISENSOR_IRCDR/L3S/0.01/v2.00/monthly/2020/11/ESACCI-LST-L3S-LST-IRCDR_-0.01deg_1MONTHLY_DAY-20201101000000-fv2.00.nc\" ) ds = xarray.open_dataset(     fp,     engine=\"h5netcdf\",     decode_coords=\"all\", ) ds Out[8]: <pre>&lt;xarray.Dataset&gt; Size: 36GB\nDimensions:          (time: 1, lat: 18000, lon: 36000, length_scale: 1,\n                      channel: 2)\nCoordinates:\n  * time             (time) datetime64[ns] 8B 2020-11-01\n  * lat              (lat) float32 72kB -90.0 -89.99 -89.98 ... 89.98 89.99\n  * lon              (lon) float32 144kB -180.0 -180.0 -180.0 ... 180.0 180.0\n  * channel          (channel) float32 8B 11.0 12.0\nDimensions without coordinates: length_scale\nData variables: (12/14)\n    dtime            (time, lat, lon) timedelta64[ns] 5GB ...\n    satze            (time, lat, lon) float32 3GB ...\n    sataz            (time, lat, lon) float32 3GB ...\n    solze            (time, lat, lon) float32 3GB ...\n    solaz            (time, lat, lon) float32 3GB ...\n    lst              (time, lat, lon) float32 3GB ...\n    ...               ...\n    lst_unc_loc_atm  (time, lat, lon) float32 3GB ...\n    lst_unc_loc_sfc  (time, lat, lon) float32 3GB ...\n    lst_unc_sys      (length_scale) float32 4B ...\n    lcc              (time, lat, lon) float32 3GB ...\n    n                (time, lat, lon) float32 3GB ...\n    lst_unc_loc_cor  (time, lat, lon) float32 3GB ...\nAttributes: (12/41)\n    source:                     ESA LST CCI IRCDR L3S V2.00\n    title:                      ESA LST CCI land surface temperature time ser...\n    institution:                University of Leicester\n    history:                    Created using software developed at Universit...\n    references:                 https://climate.esa.int/en/projects/land-surf...\n    Conventions:                CF-1.8\n    ...                         ...\n    geospatial_lon_resolution:  0.01\n    geospatial_lat_resolution:  0.01\n    key_variables:              land_surface_temperature\n    format_version:             CCI Data Standards v2.2\n    spatial_resolution:         0.01 degree\n    doi:                        10.5285/785ef9d3965442669bff899540747e28</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 1</li><li>lat: 18000</li><li>lon: 36000</li><li>length_scale: 1</li><li>channel: 2</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2020-11-01long_name :reference time of filestandard_name :time<pre>array(['2020-11-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>lat(lat)float32-90.0 -89.99 -89.98 ... 89.98 89.99long_name :latitude_coordinatesstandard_name :latitudeunits :degrees_northvalid_min :-90.0valid_max :90.0reference_datum :geographical coordinates, WGS84 projection<pre>array([-89.995   , -89.985   , -89.975006, ...,  89.975   ,  89.98499 ,\n        89.99499 ], dtype=float32)</pre></li><li>lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitude_coordinatesstandard_name :longitudeunits :degrees_eastvalid_min :-180.0valid_max :180.0reference_datum :geographical coordinates, WGS84 projection<pre>array([-179.995  , -179.985  , -179.97499, ...,  179.975  ,  179.98499,\n        179.995  ], dtype=float32)</pre></li><li>channel(channel)float3211.0 12.0long_name :channel wavelength in micronsunits :micronsvalid_min :0valid_max :15000<pre>array([10.999001, 11.999001], dtype=float32)</pre></li></ul></li><li>Data variables: (14)<ul><li>dtime(time, lat, lon)timedelta64[ns]...long_name :time difference from reference timevalid_min :0.0valid_max :2592000.0<pre>[648000000 values with dtype=timedelta64[ns]]</pre></li><li>satze(time, lat, lon)float32...long_name :satellite zenith angleunits :degreesvalid_min :0valid_max :18000<pre>[648000000 values with dtype=float32]</pre></li><li>sataz(time, lat, lon)float32...long_name :satellite azimuth angleunits :degreesvalid_min :-18000valid_max :18000<pre>[648000000 values with dtype=float32]</pre></li><li>solze(time, lat, lon)float32...long_name :solar zenith angleunits :degreesvalid_min :0valid_max :18000<pre>[648000000 values with dtype=float32]</pre></li><li>solaz(time, lat, lon)float32...long_name :solar azimuth angleunits :degreesvalid_min :-18000valid_max :18000<pre>[648000000 values with dtype=float32]</pre></li><li>lst(time, lat, lon)float32...long_name :land surface temperatureunits :kelvinvalid_min :-8315valid_max :7685<pre>[648000000 values with dtype=float32]</pre></li><li>lst_uncertainty(time, lat, lon)float32...long_name :land surface temperature total uncertaintyunits :kelvinvalid_min :0valid_max :10000<pre>[648000000 values with dtype=float32]</pre></li><li>lst_unc_ran(time, lat, lon)float32...long_name :uncertainty from uncorrelated errorsunits :kelvinvalid_min :0valid_max :10000<pre>[648000000 values with dtype=float32]</pre></li><li>lst_unc_loc_atm(time, lat, lon)float32...long_name :uncertainty from locally correlated errors on atmospheric scalesunits :kelvinvalid_min :0valid_max :10000<pre>[648000000 values with dtype=float32]</pre></li><li>lst_unc_loc_sfc(time, lat, lon)float32...long_name :uncertainty from locally correlated errors on surface scalesunits :kelvinvalid_min :0valid_max :10000<pre>[648000000 values with dtype=float32]</pre></li><li>lst_unc_sys(length_scale)float32...long_name :uncertainty from large-scale systematic errorsunits :kelvinvalid_min :0valid_max :10000<pre>[1 values with dtype=float32]</pre></li><li>lcc(time, lat, lon)float32...long_name :land cover classunits :1flag_meanings :cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban Bare_areas_of_soil_types_not_contained_in_biomes_203_to_207 Unconsolidated_bare_areas_of_soil_types_not_contained_in_biomes_203_to_207 Consolidated_bare_areas_of_soil_types_not_contained_in_biomes_203_to_207 Bare_areas_of_soil_type_Entisols_Orthents Bare_areas_of_soil_type_Shifting_sand Bare_areas_of_soil_type_Aridisols_Calcids Bare_areas_of_soil_type_Aridisols_Cambids Bare_areas_of_soil_type_Gelisols_Orthels water snow_and_ice Sea_iceflag_values :[ 10  11  12  20  30  40  50  60  61  62  70  71  72  80  81  82  90 100  110 120 121 122 130 140 150 151 152 153 160 170 180 190 200 201 202 203  204 205 206 207 210 220 230]valid_min :10valid_max :230<pre>[648000000 values with dtype=float32]</pre></li><li>n(time, lat, lon)float32...long_name :number of clear-sky pixelsvalid_min :0valid_max :18750<pre>[648000000 values with dtype=float32]</pre></li><li>lst_unc_loc_cor(time, lat, lon)float32...long_name :uncertainty from locally correlated errors on LST correctionsunits :kelvinvalid_min :0valid_max :10000<pre>[648000000 values with dtype=float32]</pre></li></ul></li><li>Indexes: (4)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2020-11-01'], dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([-89.99500274658203, -89.98500061035156, -89.97500610351562,\n       -89.96500396728516, -89.95500183105469, -89.94499969482422,\n       -89.93500518798828, -89.92500305175781, -89.91500091552734,\n        -89.9050064086914,\n       ...\n        89.90499114990234,  89.91498565673828,  89.92499542236328,\n        89.93498992919922,  89.94499969482422,  89.95499420166016,\n         89.9649887084961,   89.9749984741211,  89.98499298095703,\n        89.99498748779297],\n      dtype='float32', name='lat', length=18000))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ -179.9949951171875, -179.98500061035156, -179.97499084472656,\n       -179.96499633789062,  -179.9550018310547,  -179.9449920654297,\n       -179.93499755859375, -179.92498779296875,  -179.9149932861328,\n       -179.90499877929688,\n       ...\n        179.90499877929688,  179.91500854492188,  179.92498779296875,\n        179.93499755859375,  179.94500732421875,  179.95498657226562,\n        179.96499633789062,  179.97500610351562,   179.9849853515625,\n         179.9949951171875],\n      dtype='float32', name='lon', length=36000))</pre></li><li>channelPandasIndex<pre>PandasIndex(Index([10.999001, 11.999001], dtype='float32', name='channel'))</pre></li></ul></li><li>Attributes: (41)source :ESA LST CCI IRCDR L3S V2.00title :ESA LST CCI land surface temperature time series from multiple IR sensors on LEO platforms.institution :University of Leicesterhistory :Created using software developed at University of Leicesterreferences :https://climate.esa.int/en/projects/land-surface-temperatureConventions :CF-1.8product_version :2.00summary :This file contains level L3S global land surface temperatures from SLSTRA. L3S data are derived from more than one sensor combined on a space and/or time grid.keywords :Earth Science; Land Surface; Land Temperature; Land Surface Temperatureid :ESACCI-LST-L3S-LST-IRCDR_-0.01deg_1MONTHLY_DAY-20201101000000-fv2.00.ncnaming_authority :le.ac.ukkeywords_vocabulary :NASA Global change Master Directory (GCMD) Science Keywordscdm_data_type :gridcomment :These data were produced as part of the ESA LST CCI project.date_created :20220616T135237Zcreator_name :University of Leicester Surface Temperature Groupcreator_url :https://climate.esa.int/en/projects/land-surface-temperaturecreator_email :djg20@le.ac.ukproject :Climate Change Initiative - European Space Agencygeospatial_lat_min :-89.995geospatial_lat_max :89.99499geospatial_lon_min :-179.995geospatial_lon_max :179.995geospatial_vertical_min :0.0geospatial_vertical_max :0.0time_coverage_start :20201101T000000time_coverage_end :20201130T235959time_coverage_duration :P1Mtime_coverage_resolution :P1Mstandard_name_vocabulary :CF Standard Name Table v71license :ESA CCI Data Policy: free and open accessplatform :Sentinel-3Asensor :SLSTRAgeospatial_lat_units :degrees_northgeospatial_lon_units :degrees_eastgeospatial_lon_resolution :0.01geospatial_lat_resolution :0.01key_variables :land_surface_temperatureformat_version :CCI Data Standards v2.2spatial_resolution :0.01 degreedoi :10.5285/785ef9d3965442669bff899540747e28</li></ul> In\u00a0[9]: Copied! <pre>da = ds[\"lst\"]\n\n# # Make sure we have a valid CRS\ncrs = da.rio.crs or \"epsg:4326\"\nda.rio.write_crs(crs, inplace=True)\n\n# Select the first time stamp\n# da = da.isel(time=0)\nda\n</pre> da = ds[\"lst\"]  # # Make sure we have a valid CRS crs = da.rio.crs or \"epsg:4326\" da.rio.write_crs(crs, inplace=True)  # Select the first time stamp # da = da.isel(time=0) da Out[9]: <pre>&lt;xarray.DataArray 'lst' (time: 1, lat: 18000, lon: 36000)&gt; Size: 3GB\n[648000000 values with dtype=float32]\nCoordinates:\n  * time         (time) datetime64[ns] 8B 2020-11-01\n  * lat          (lat) float32 72kB -90.0 -89.99 -89.98 ... 89.97 89.98 89.99\n  * lon          (lon) float32 144kB -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n    spatial_ref  int64 8B 0\nAttributes:\n    long_name:  land surface temperature\n    units:      kelvin\n    valid_min:  -8315\n    valid_max:  7685</pre>xarray.DataArray'lst'<ul><li>time: 1</li><li>lat: 18000</li><li>lon: 36000</li></ul><ul><li>...<pre>[648000000 values with dtype=float32]</pre></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2020-11-01long_name :reference time of filestandard_name :time<pre>array(['2020-11-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>lat(lat)float32-90.0 -89.99 -89.98 ... 89.98 89.99long_name :latitude_coordinatesstandard_name :latitudeunits :degrees_northvalid_min :-90.0valid_max :90.0reference_datum :geographical coordinates, WGS84 projection<pre>array([-89.995   , -89.985   , -89.975006, ...,  89.975   ,  89.98499 ,\n        89.99499 ], dtype=float32)</pre></li><li>lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitude_coordinatesstandard_name :longitudeunits :degrees_eastvalid_min :-180.0valid_max :180.0reference_datum :geographical coordinates, WGS84 projection<pre>array([-179.995  , -179.985  , -179.97499, ...,  179.975  ,  179.98499,\n        179.995  ], dtype=float32)</pre></li><li>spatial_ref()int640crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984grid_mapping_name :latitude_longitudespatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]<pre>array(0)</pre></li></ul></li><li>Indexes: (3)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2020-11-01'], dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([-89.99500274658203, -89.98500061035156, -89.97500610351562,\n       -89.96500396728516, -89.95500183105469, -89.94499969482422,\n       -89.93500518798828, -89.92500305175781, -89.91500091552734,\n        -89.9050064086914,\n       ...\n        89.90499114990234,  89.91498565673828,  89.92499542236328,\n        89.93498992919922,  89.94499969482422,  89.95499420166016,\n         89.9649887084961,   89.9749984741211,  89.98499298095703,\n        89.99498748779297],\n      dtype='float32', name='lat', length=18000))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ -179.9949951171875, -179.98500061035156, -179.97499084472656,\n       -179.96499633789062,  -179.9550018310547,  -179.9449920654297,\n       -179.93499755859375, -179.92498779296875,  -179.9149932861328,\n       -179.90499877929688,\n       ...\n        179.90499877929688,  179.91500854492188,  179.92498779296875,\n        179.93499755859375,  179.94500732421875,  179.95498657226562,\n        179.96499633789062,  179.97500610351562,   179.9849853515625,\n         179.9949951171875],\n      dtype='float32', name='lon', length=36000))</pre></li></ul></li><li>Attributes: (4)long_name :land surface temperatureunits :kelvinvalid_min :-8315valid_max :7685</li></ul> In\u00a0[10]: Copied! <pre>with XarrayReader(da) as dst:\n    print(dst.info())\n    print(dst.minzoom, dst.maxzoom)\n</pre> with XarrayReader(da) as dst:     print(dst.info())     print(dst.minzoom, dst.maxzoom) <pre>bounds=(-179.99999511705187, -90.00000274631076, 179.99999511705187, 89.9999874875217) crs='http://www.opengis.net/def/crs/EPSG/0/4326' band_metadata=[('b1', {'long_name': 'reference time of file', 'standard_name': 'time'})] band_descriptions=[('b1', '2020-11-01T00:00:00.000000000')] dtype='float32' nodata_type='Nodata' colorinterp=None scales=None offsets=None colormap=None name='lst' count=1 width=36000 height=18000 attrs={'long_name': 'land surface temperature', 'units': 'kelvin', 'valid_min': -8315, 'valid_max': 7685}\n0 6\n</pre> In\u00a0[11]: Copied! <pre>with XarrayReader(da) as dst:\n    img = dst.tile(31, 22, 6)\n\nplt.imshow(img.data_as_image())\n</pre> with XarrayReader(da) as dst:     img = dst.tile(31, 22, 6)  plt.imshow(img.data_as_image()) Out[11]: <pre>&lt;matplotlib.image.AxesImage at 0x11b0d3e20&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-XarrayReader/#mur-sst","title":"MUR SST\u00b6","text":""},{"location":"examples/Using-rio-tiler-XarrayReader/#netcdf","title":"NetCDF\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/","title":"rio-tiler.mosaic","text":"<p>In This notebook you'll learn how to:</p> <ul> <li>use create mercator tiles from multiple observations (assets) using <code>rio_tiler.mosaic</code> submodule</li> <li>create custom <code>pixel_selection</code> methods</li> <li>look for sentinel-2-cogs data</li> <li>create custom tiler using <code>STACReader</code></li> </ul> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n# !pip install matplotlib\n</pre> # !pip install rio-tiler # !pip install ipyleaflet # !pip install matplotlib In\u00a0[2]: Copied! <pre>import datetime\nimport json\n\nimport httpx\nimport morecantile\nimport numpy\nfrom ipyleaflet import GeoJSON, Map, basemaps\nfrom matplotlib.pyplot import figure\nfrom rasterio.features import bounds as featureBounds\n\nfrom rio_tiler.io import Reader, STACReader\nfrom rio_tiler.models import ImageData\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.mosaic.methods.base import MosaicMethodBase\n</pre> import datetime import json  import httpx import morecantile import numpy from ipyleaflet import GeoJSON, Map, basemaps from matplotlib.pyplot import figure from rasterio.features import bounds as featureBounds  from rio_tiler.io import Reader, STACReader from rio_tiler.models import ImageData from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults from rio_tiler.mosaic.methods.base import MosaicMethodBase In\u00a0[3]: Copied! <pre>stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n</pre> stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\" In\u00a0[4]: Copied! <pre># use geojson.io\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [30.810813903808594, 29.454247067148533],\n                        [30.88600158691406, 29.454247067148533],\n                        [30.88600158691406, 29.51879923863822],\n                        [30.810813903808594, 29.51879923863822],\n                        [30.810813903808594, 29.454247067148533],\n                    ]\n                ],\n            },\n        }\n    ],\n}\n\nbounds = featureBounds(geojson)\n</pre> # use geojson.io geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [30.810813903808594, 29.454247067148533],                         [30.88600158691406, 29.454247067148533],                         [30.88600158691406, 29.51879923863822],                         [30.810813903808594, 29.51879923863822],                         [30.810813903808594, 29.454247067148533],                     ]                 ],             },         }     ], }  bounds = featureBounds(geojson) In\u00a0[\u00a0]: Copied! <pre># Date filter\ndate_min = \"2019-06-01\"\ndate_max = \"2019-09-01\"\n\nstart = datetime.datetime.strptime(date_min, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(date_max, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\nquery = {\n    \"collections\": [\n        \"sentinel-s2-l2a-cogs\"\n    ],  # Make sure to query only sentinel-2 COGs collection\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\"eo:cloud_cover\": {\"lt\": 5}},  # Use low cloud cover\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 1000,\n    \"fields\": {\n        \"include\": [\n            \"id\",\n            \"properties.datetime\",\n            \"properties.eo:cloud_cover\",\n        ],  # Make returned response ligth\n        \"exclude\": [\"links\"],\n    },\n}\n\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(data[\"context\"])\nprint()\nprint(\"Example:\")\nprint(json.dumps(data[\"features\"][0], indent=4))\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n\n# For this demo we will use the True color image `TCI` asset\nassets = [f[\"assets\"][\"visual\"][\"href\"] for f in data[\"features\"]]\n</pre> # Date filter date_min = \"2019-06-01\" date_max = \"2019-09-01\"  start = datetime.datetime.strptime(date_min, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\") end = datetime.datetime.strptime(date_max, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")  query = {     \"collections\": [         \"sentinel-s2-l2a-cogs\"     ],  # Make sure to query only sentinel-2 COGs collection     \"datetime\": f\"{start}/{end}\",     \"query\": {\"eo:cloud_cover\": {\"lt\": 5}},  # Use low cloud cover     \"intersects\": geojson[\"features\"][0][\"geometry\"],     \"limit\": 1000,     \"fields\": {         \"include\": [             \"id\",             \"properties.datetime\",             \"properties.eo:cloud_cover\",         ],  # Make returned response ligth         \"exclude\": [\"links\"],     }, }  headers = {     \"Content-Type\": \"application/json\",     \"Accept-Encoding\": \"gzip\",     \"Accept\": \"application/geo+json\", }   data = httpx.post(stac_endpoint, headers=headers, json=query).json() print(data[\"context\"]) print() print(\"Example:\") print(json.dumps(data[\"features\"][0], indent=4))  sceneid = [f[\"id\"] for f in data[\"features\"]] cloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]] dates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]  # For this demo we will use the True color image `TCI` asset assets = [f[\"assets\"][\"visual\"][\"href\"] for f in data[\"features\"]] In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    basemap=basemaps.OpenStreetMap.Mapnik,\n    center=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom=8,\n)\n\n# add scenes\ngeo_json = GeoJSON(\n    data=data,\n    style={\"opacity\": 1, \"dashArray\": \"1\", \"fillOpacity\": 0, \"weight\": 1},\n)\nm.add_layer(geo_json)\n\n# add AOI\ngeo_json = GeoJSON(\n    data=geojson,\n    style={\"opacity\": 1, \"dashArray\": \"1\", \"fillOpacity\": 1, \"weight\": 1},\n)\nm.add_layer(geo_json)\n\nm\n</pre> m = Map(     basemap=basemaps.OpenStreetMap.Mapnik,     center=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom=8, )  # add scenes geo_json = GeoJSON(     data=data,     style={\"opacity\": 1, \"dashArray\": \"1\", \"fillOpacity\": 0, \"weight\": 1}, ) m.add_layer(geo_json)  # add AOI geo_json = GeoJSON(     data=geojson,     style={\"opacity\": 1, \"dashArray\": \"1\", \"fillOpacity\": 1, \"weight\": 1}, ) m.add_layer(geo_json)  m In\u00a0[7]: Copied! <pre>def tiler(asset, *args, **kwargs):\n    with Reader(asset) as src:\n        return src.tile(*args, **kwargs)\n</pre> def tiler(asset, *args, **kwargs):     with Reader(asset) as src:         return src.tile(*args, **kwargs) In\u00a0[\u00a0]: Copied! <pre># List of z12 mercator tiles\ntms = morecantile.tms.get(\"WebMercatorQuad\")\n\ntiles = list(tms.tiles(*bounds, 12))\nprint(len(tiles))\n</pre> # List of z12 mercator tiles tms = morecantile.tms.get(\"WebMercatorQuad\")  tiles = list(tms.tiles(*bounds, 12)) print(len(tiles)) In\u00a0[\u00a0]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    assets,\n    tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    threads=1,\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     assets,     tiler,     tile.x,     tile.y,     tile.z,     threads=1, )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) <p>Print the number and list of assets used to construct the image</p> In\u00a0[\u00a0]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) In\u00a0[\u00a0]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    assets,\n    tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=defaults.MeanMethod(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     assets,     tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=defaults.MeanMethod(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) <p>Print the number and list of assets used to construct the image</p> In\u00a0[\u00a0]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) In\u00a0[13]: Copied! <pre>stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"\nstac_assets = [stac_item.format(sceneid=scene) for scene in sceneid]\n</pre> stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\" stac_assets = [stac_item.format(sceneid=scene) for scene in sceneid] In\u00a0[\u00a0]: Copied! <pre># Fisrt, let's checkout the STDEV of the NDVI values\n# Because we need to use multiple STAC assets, it's easier to use the STACReader\n\n\ndef custom_tiler(asset, *args, **kwargs):\n    with STACReader(asset) as stac:\n        return stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")\n\n\ntile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    stac_assets,\n    custom_tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=defaults.StdevMethod(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> # Fisrt, let's checkout the STDEV of the NDVI values # Because we need to use multiple STAC assets, it's easier to use the STACReader   def custom_tiler(asset, *args, **kwargs):     with STACReader(asset) as stac:         return stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")   tile = tiles[0]  img, assets_used = mosaic_reader(     stac_assets,     custom_tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=defaults.StdevMethod(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) In\u00a0[\u00a0]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) In\u00a0[16]: Copied! <pre># We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI\n\n\ndef custom_tiler(asset, *args, **kwargs):\n    with STACReader(asset) as stac:\n        img = stac.tile(*args, assets=\"visual\")\n        ndvi = stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")\n        return ImageData(\n            numpy.concatenate((img.data, ndvi.data)),\n            img.mask,\n            crs=img.crs,\n            bounds=img.bounds,\n        )\n</pre> # We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI   def custom_tiler(asset, *args, **kwargs):     with STACReader(asset) as stac:         img = stac.tile(*args, assets=\"visual\")         ndvi = stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")         return ImageData(             numpy.concatenate((img.data, ndvi.data)),             img.mask,             crs=img.crs,             bounds=img.bounds,         ) In\u00a0[17]: Copied! <pre>class CustomFourthBandH(MosaicMethodBase):\n    \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\"\n\n    @property\n    def data(self):\n        \"\"\"Return data and mask.\"\"\"\n        if self.mosaic is not None:\n            return self.mosaic[:-1].copy()\n\n        return None\n\n    def feed(self, array):\n        \"\"\"Add data to mosaic.\"\"\"\n\n        if self.mosaic is None:\n            self.mosaic = array\n            return\n\n        pidex = (\n            numpy.bitwise_and(array.data[-1] &gt; self.mosaic.data[-1], ~array.mask)\n            | self.mosaic.mask\n        )\n\n        mask = numpy.where(pidex, array.mask, self.mosaic.mask)\n        self.mosaic = numpy.ma.where(pidex, array, self.mosaic)\n        self.mosaic.mask = mask\n</pre> class CustomFourthBandH(MosaicMethodBase):     \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\"      @property     def data(self):         \"\"\"Return data and mask.\"\"\"         if self.mosaic is not None:             return self.mosaic[:-1].copy()          return None      def feed(self, array):         \"\"\"Add data to mosaic.\"\"\"          if self.mosaic is None:             self.mosaic = array             return          pidex = (             numpy.bitwise_and(array.data[-1] &gt; self.mosaic.data[-1], ~array.mask)             | self.mosaic.mask         )          mask = numpy.where(pidex, array.mask, self.mosaic.mask)         self.mosaic = numpy.ma.where(pidex, array, self.mosaic)         self.mosaic.mask = mask In\u00a0[\u00a0]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    stac_assets,\n    custom_tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=CustomFourthBandH(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\n\n# NOTE: because we are using NDVI + Visual, the output array, will be in float32\nax.imshow(img.data_as_image().astype(\"uint8\"))\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     stac_assets,     custom_tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=CustomFourthBandH(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1)  # NOTE: because we are using NDVI + Visual, the output array, will be in float32 ax.imshow(img.data_as_image().astype(\"uint8\"))  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) In\u00a0[\u00a0]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-mosaic/#rio-tilermosaic","title":"rio-tiler.mosaic\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>ipyleaflet</li> <li>rio-tiler~=7.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler-mosaic/#data","title":"Data\u00b6","text":"<p>For this demo we will use the Sentinel-2 data stored as COGs on AWS.</p>"},{"location":"examples/Using-rio-tiler-mosaic/#sentinel-2-cogs","title":"Sentinel 2 COGs\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0</p>"},{"location":"examples/Using-rio-tiler-mosaic/#search-for-data","title":"Search for data\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#define-area-of-interest-aoi","title":"Define Area of Interest (AOI)\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#stac-search","title":"STAC Search\u00b6","text":"<p>Use STAC API to search for data over our AOI</p> <p>Doc: https://github.com/radiantearth/stac-api-spec</p>"},{"location":"examples/Using-rio-tiler-mosaic/#define-the-tiler","title":"Define the tiler\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#firstmethod-fill-with-the-first-value-available","title":"FirstMethod: Fill with the first value available\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#meanmethod-get-the-mean-from-all-the-stack-of-data","title":"MeanMethod: Get the mean from all the stack of data\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#create-custom-pixel_selection-class","title":"Create Custom pixel_selection class\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#1-using-a-4th-band-for-decision-highest-ndvi","title":"1. Using a 4th band for decision: highest NDVI\u00b6","text":""},{"location":"examples/Using-rio-tiler/","title":"Introduction to rio-tiler","text":"<p>The goal of this notebook is to give a quick introduction of the main rio-tiler features.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler matplotlib\n</pre> # !pip install rio-tiler matplotlib In\u00a0[1]: Copied! <pre>import morecantile\nfrom matplotlib.pyplot import imshow, plot, subplots\n\nfrom rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n</pre> import morecantile from matplotlib.pyplot import imshow, plot, subplots  from rio_tiler.io import Reader from rio_tiler.models import ImageData In\u00a0[2]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n</pre> # For this DEMO we will use this file src_path = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\" In\u00a0[3]: Copied! <pre>?Reader\n</pre> ?Reader <pre>Init signature:\nReader(\n    input: str,\n    dataset: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.io.MemoryFile, rasterio.vrt.WarpedVRT] = None,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    colormap: Dict = None,\n    options: rio_tiler.reader.Options = NOTHING,\n) -&gt; None\nDocstring:     \nRasterio Reader.\n\nAttributes:\n    input (str): dataset path.\n    dataset (rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT, optional): Rasterio dataset.\n    tms (morecantile.TileMatrixSet, optional): TileMatrixSet grid definition. Defaults to `WebMercatorQuad`.\n    colormap (dict, optional): Overwrite internal colormap.\n    options (dict, optional): Options to forward to low-level reader methods.\n\nExamples:\n    &gt;&gt;&gt; with Reader(src_path) as src:\n        src.tile(...)\n\n    &gt;&gt;&gt; # Set global options\n        with Reader(src_path, options={\"unscale\": True, \"nodata\": 0}) as src:\n            src.tile(...)\n\n    &gt;&gt;&gt; with rasterio.open(src_path) as src_dst:\n            with WarpedVRT(src_dst, ...) as vrt_dst:\n                with Reader(None, dataset=vrt_dst) as src:\n                    src.tile(...)\n\n    &gt;&gt;&gt; with rasterio.open(src_path) as src_dst:\n            with Reader(None, dataset=src_dst) as src:\n                src.tile(...)\nInit docstring: Method generated by attrs for class Reader.\nFile:           ~/Dev/CogeoTiff/rio-tiler/rio_tiler/io/rasterio.py\nType:           ABCMeta\nSubclasses:     ImageReader\n</pre> In\u00a0[4]: Copied! <pre># As for Rasterio, using context manager is a good way to\n# make sure the dataset are closed when we exit.\nwith Reader(src_path) as src:\n    print(\"rasterio dataset:\")\n    print(src.dataset)\n    print()\n    print(\"metadata from rasterio:\")\n    print(src.dataset.meta)\n    print()\n    # Using rio-tiler Info() method\n    info = src.info()\n    print(\"rio-tiler dataset info:\")\n    print(src.info().json(exclude_none=True))\n\nprint(src.dataset.closed)\n</pre> # As for Rasterio, using context manager is a good way to # make sure the dataset are closed when we exit. with Reader(src_path) as src:     print(\"rasterio dataset:\")     print(src.dataset)     print()     print(\"metadata from rasterio:\")     print(src.dataset.meta)     print()     # Using rio-tiler Info() method     info = src.info()     print(\"rio-tiler dataset info:\")     print(src.info().json(exclude_none=True))  print(src.dataset.closed) <pre>rasterio dataset:\n&lt;open DatasetReader name='https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif' mode='r'&gt;\n\nmetadata from rasterio:\n{'driver': 'GTiff', 'dtype': 'float32', 'nodata': -9999.0, 'width': 2000, 'height': 2000, 'count': 1, 'crs': CRS.from_epsg(2056), 'transform': Affine(0.5, 0.0, 2573000.0,\n       0.0, -0.5, 1086000.0)}\n\nrio-tiler dataset info:\n{\"bounds\":[2573000.0,1085000.0,2574000.0,1086000.0],\"crs\":\"http://www.opengis.net/def/crs/EPSG/0/2056\",\"band_metadata\":[[\"b1\",{\"STATISTICS_COVARIANCES\":\"10685.98787505646\",\"STATISTICS_EXCLUDEDVALUES\":\"-9999\",\"STATISTICS_MAXIMUM\":\"2015.0944824219\",\"STATISTICS_MEAN\":\"1754.471184271\",\"STATISTICS_MINIMUM\":\"1615.8128662109\",\"STATISTICS_SKIPFACTORX\":\"1\",\"STATISTICS_SKIPFACTORY\":\"1\",\"STATISTICS_STDDEV\":\"103.37305197708\"}]],\"band_descriptions\":[[\"b1\",\"\"]],\"dtype\":\"float32\",\"nodata_type\":\"Nodata\",\"colorinterp\":[\"gray\"],\"scales\":[1.0],\"offsets\":[0.0],\"driver\":\"GTiff\",\"count\":1,\"width\":2000,\"height\":2000,\"overviews\":[2,4,8],\"nodata_value\":-9999.0}\nTrue\n</pre> In\u00a0[5]: Copied! <pre>with Reader(src_path) as src:\n    meta = src.statistics(max_size=256)\n\n    assert isinstance(meta, dict)\n    print(list(meta))\n    print(meta[\"b1\"].model_dump())\n</pre> with Reader(src_path) as src:     meta = src.statistics(max_size=256)      assert isinstance(meta, dict)     print(list(meta))     print(meta[\"b1\"].model_dump()) <pre>['b1']\n{'min': 1615.81982421875, 'max': 2015.094482421875, 'mean': 1754.5912663564086, 'count': 65536.0, 'sum': 114988893.2319336, 'std': 103.58233071842892, 'median': 1721.393310546875, 'majority': 1957.414794921875, 'minority': 1615.81982421875, 'unique': 61645.0, 'histogram': [[10417, 15877, 9360, 6441, 5490, 4938, 4231, 3141, 3532, 2109], [1615.81982421875, 1655.747314453125, 1695.6748046875, 1735.6021728515625, 1775.5296630859375, 1815.4571533203125, 1855.3846435546875, 1895.3121337890625, 1935.239501953125, 1975.1669921875, 2015.094482421875]], 'valid_percent': 100.0, 'masked_pixels': 0.0, 'valid_pixels': 65536.0, 'percentile_2': 1626.7139892578125, 'percentile_98': 1987.7581787109375}\n</pre> In\u00a0[6]: Copied! <pre># Band 1\nplot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])\n</pre> # Band 1 plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0]) Out[6]: <pre>[&lt;matplotlib.lines.Line2D at 0x138633f10&gt;]</pre> In\u00a0[7]: Copied! <pre>with Reader(src_path) as src:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    data = src.preview()\n    print(data.data.shape)\n    assert isinstance(data, ImageData)\n</pre> with Reader(src_path) as src:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     data = src.preview()     print(data.data.shape)     assert isinstance(data, ImageData) <pre>(1, 1024, 1024)\n</pre> In\u00a0[8]: Copied! <pre>print(f\"width: {data.width}\")\nprint(f\"height: {data.height}\")\nprint(f\"bands: {data.count}\")\nprint(f\"crs: {data.crs}\")\nprint(f\"bounds: {data.bounds}\")\nprint(f\"metadata: {data.metadata}\")\nprint(f\"assets: {data.assets}\")\nprint(f\"dataset stats: {data.dataset_statistics}\")  # If stored in the original dataset\n\nprint(type(data.data))\nprint(type(data.mask))\n</pre> print(f\"width: {data.width}\") print(f\"height: {data.height}\") print(f\"bands: {data.count}\") print(f\"crs: {data.crs}\") print(f\"bounds: {data.bounds}\") print(f\"metadata: {data.metadata}\") print(f\"assets: {data.assets}\") print(f\"dataset stats: {data.dataset_statistics}\")  # If stored in the original dataset  print(type(data.data)) print(type(data.mask)) <pre>width: 1024\nheight: 1024\nbands: 1\ncrs: EPSG:2056\nbounds: BoundingBox(left=2573000.0, bottom=1085000.0, right=2574000.0, top=1086000.0)\nmetadata: {'AREA_OR_POINT': 'Area'}\nassets: ['https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif']\ndataset stats: [(1615.8128662109, 2015.0944824219)]\n&lt;class 'numpy.ndarray'&gt;\n&lt;class 'numpy.ndarray'&gt;\n</pre> In\u00a0[9]: Copied! <pre># Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL)\n# in order to display the data we need to change the order (using rasterio.plot.array_to_image).\n# the ImageData class wraps the rasterio function in the `data_as_image()` method.\nprint(type(data))\nprint(data.data.shape)\n\nimage = data.data_as_image()\n# data_as_image() returns a numpy.ndarray\nprint(type(image))\nprint(image.shape)\n\nimshow(image)\n</pre> # Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL) # in order to display the data we need to change the order (using rasterio.plot.array_to_image). # the ImageData class wraps the rasterio function in the `data_as_image()` method. print(type(data)) print(data.data.shape)  image = data.data_as_image() # data_as_image() returns a numpy.ndarray print(type(image)) print(image.shape)  imshow(image) <pre>&lt;class 'rio_tiler.models.ImageData'&gt;\n(1, 1024, 1024)\n&lt;class 'numpy.ma.MaskedArray'&gt;\n(1024, 1024, 1)\n</pre> Out[9]: <pre>&lt;matplotlib.image.AxesImage at 0x138a2e550&gt;</pre> In\u00a0[10]: Copied! <pre>src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\"\n</pre> src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\" In\u00a0[11]: Copied! <pre>with Reader(src_path) as src:\n    info = src.info()\n    print(\"rio-tiler dataset info:\")\n    print(info.json(exclude_none=True))\n</pre> with Reader(src_path) as src:     info = src.info()     print(\"rio-tiler dataset info:\")     print(info.json(exclude_none=True)) <pre>rio-tiler dataset info:\n{\"bounds\":[544999.99999999,645000.0,549999.99999999,650000.0],\"crs\":\"http://www.opengis.net/def/crs/EPSG/0/6527\",\"band_metadata\":[[\"b1\",{}],[\"b2\",{}],[\"b3\",{}],[\"b4\",{}]],\"band_descriptions\":[[\"b1\",\"\"],[\"b2\",\"\"],[\"b3\",\"\"],[\"b4\",\"\"]],\"dtype\":\"uint16\",\"nodata_type\":\"None\",\"colorinterp\":[\"red\",\"green\",\"blue\",\"undefined\"],\"scales\":[1.0,1.0,1.0,1.0],\"offsets\":[0.0,0.0,0.0,0.0],\"driver\":\"GTiff\",\"count\":4,\"width\":5000,\"height\":5000,\"overviews\":[2,4,8,16]}\n</pre> In\u00a0[12]: Copied! <pre>with Reader(src_path) as src:\n    meta = src.statistics()\n\nprint(list(meta))\n\nfig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)\n# Red (index 1)\naxs[0].plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])\n\n# Green (index 2)\naxs[1].plot(meta[\"b2\"].histogram[1][0:-1], meta[\"b2\"].histogram[0])\n\n# Blue (index 3)\naxs[2].plot(meta[\"b3\"].histogram[1][0:-1], meta[\"b3\"].histogram[0])\n\n# Nir (index 3)\naxs[3].plot(meta[\"b4\"].histogram[1][0:-1], meta[\"b4\"].histogram[0])\n</pre> with Reader(src_path) as src:     meta = src.statistics()  print(list(meta))  fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150) # Red (index 1) axs[0].plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])  # Green (index 2) axs[1].plot(meta[\"b2\"].histogram[1][0:-1], meta[\"b2\"].histogram[0])  # Blue (index 3) axs[2].plot(meta[\"b3\"].histogram[1][0:-1], meta[\"b3\"].histogram[0])  # Nir (index 3) axs[3].plot(meta[\"b4\"].histogram[1][0:-1], meta[\"b4\"].histogram[0]) <pre>['b1', 'b2', 'b3', 'b4']\n</pre> Out[12]: <pre>[&lt;matplotlib.lines.Line2D at 0x138bcd5e0&gt;]</pre> In\u00a0[13]: Copied! <pre>with Reader(src_path) as src:\n    # Return only the third band\n    nir_band = src.preview(indexes=4)\n    print(nir_band.data.shape)\n    print(nir_band.data.dtype)\n\nimshow(nir_band.data_as_image())\n</pre> with Reader(src_path) as src:     # Return only the third band     nir_band = src.preview(indexes=4)     print(nir_band.data.shape)     print(nir_band.data.dtype)  imshow(nir_band.data_as_image()) <pre>(1, 1024, 1024)\nuint16\n</pre> Out[13]: <pre>&lt;matplotlib.image.AxesImage at 0x138c95160&gt;</pre> In\u00a0[14]: Copied! <pre>with Reader(src_path) as src:\n    # Return only the third band\n    nrg = src.preview(indexes=(4, 3, 1))\n\n    # Data is in Uint16 so we need to rescale\n    nrg.rescale(((nrg.data.min(), nrg.data.max()),))\n\nimshow(nrg.data_as_image())\n</pre> with Reader(src_path) as src:     # Return only the third band     nrg = src.preview(indexes=(4, 3, 1))      # Data is in Uint16 so we need to rescale     nrg.rescale(((nrg.data.min(), nrg.data.max()),))  imshow(nrg.data_as_image()) Out[14]: <pre>&lt;matplotlib.image.AxesImage at 0x138d3d250&gt;</pre> In\u00a0[15]: Copied! <pre>with Reader(src_path) as src:\n    # Apply NDVI band math\n    # (NIR - RED) / (NIR + RED)\n    ndvi = src.preview(expression=\"(b4-b1)/(b4+b1)\")\n    print(ndvi.data.shape)\n    print(ndvi.data.dtype)\n    print(\"NDVI range: \", ndvi.data.min(), ndvi.data.max())\n\nndvi.rescale(in_range=((-1, 1),))\nimshow(ndvi.data_as_image())\n</pre> with Reader(src_path) as src:     # Apply NDVI band math     # (NIR - RED) / (NIR + RED)     ndvi = src.preview(expression=\"(b4-b1)/(b4+b1)\")     print(ndvi.data.shape)     print(ndvi.data.dtype)     print(\"NDVI range: \", ndvi.data.min(), ndvi.data.max())  ndvi.rescale(in_range=((-1, 1),)) imshow(ndvi.data_as_image()) <pre>(1, 1024, 1024)\nfloat64\nNDVI range:  -0.2865547317109613 0.844091888413218\n</pre> Out[15]: <pre>&lt;matplotlib.image.AxesImage at 0x138dbd130&gt;</pre> In\u00a0[17]: Copied! <pre>with Reader(src_path) as src:\n    print(f\"Bounds in dataset CRS: {src.bounds}\")\n    print(f\"Bounds WGS84: {src.get_geographic_bounds('epsg:4326')}\")\n    print(f\"MinZoom (WebMercator): {src.minzoom}\")\n    print(f\"MaxZoom (WebMercator): {src.maxzoom}\")\n</pre> with Reader(src_path) as src:     print(f\"Bounds in dataset CRS: {src.bounds}\")     print(f\"Bounds WGS84: {src.get_geographic_bounds('epsg:4326')}\")     print(f\"MinZoom (WebMercator): {src.minzoom}\")     print(f\"MaxZoom (WebMercator): {src.maxzoom}\") <pre>Bounds in dataset CRS: (544999.99999999, 645000.0, 549999.99999999, 650000.0)\nBounds WGS84: (-74.3095632062702, 40.603994417539994, -74.29151245384847, 40.61775082944064)\nMinZoom (WebMercator): 14\nMaxZoom (WebMercator): 19\n</pre> In\u00a0[18]: Copied! <pre># rio-tiler defaults to the WebMercator Grids. The grid definition is provided by the morecantile module\n# Docs: https://github.com/developmentseed/morecantile\ntms = morecantile.tms.get(\"WebMercatorQuad\")\nprint(repr(tms))\n\n# Get the list of tiles for the COG minzoom\nwith Reader(src_path) as cog:\n    tile_cover = list(\n        tms.tiles(*cog.get_geographic_bounds(\"epsg:4326\"), zooms=cog.minzoom)\n    )\n\nprint(f\"Nb of Z{cog.minzoom} Mercator tiles: {len(tile_cover)}\")\nprint(tile_cover)\n</pre> # rio-tiler defaults to the WebMercator Grids. The grid definition is provided by the morecantile module # Docs: https://github.com/developmentseed/morecantile tms = morecantile.tms.get(\"WebMercatorQuad\") print(repr(tms))  # Get the list of tiles for the COG minzoom with Reader(src_path) as cog:     tile_cover = list(         tms.tiles(*cog.get_geographic_bounds(\"epsg:4326\"), zooms=cog.minzoom)     )  print(f\"Nb of Z{cog.minzoom} Mercator tiles: {len(tile_cover)}\") print(tile_cover) <pre>&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;\nNb of Z14 Mercator tiles: 2\n[Tile(x=4810, y=6165, z=14), Tile(x=4810, y=6166, z=14)]\n</pre> In\u00a0[19]: Copied! <pre>with Reader(src_path) as src:\n    img_1 = src.tile(*tile_cover[0])\n    img_1.rescale(((0, 40000),))\n    print(img_1.data.shape)\n\n    img_2 = src.tile(*tile_cover[1])\n    img_2.rescale(((0, 40000),))\n\n    print(img_2.data.shape)\n</pre> with Reader(src_path) as src:     img_1 = src.tile(*tile_cover[0])     img_1.rescale(((0, 40000),))     print(img_1.data.shape)      img_2 = src.tile(*tile_cover[1])     img_2.rescale(((0, 40000),))      print(img_2.data.shape) <pre>(4, 256, 256)\n(4, 256, 256)\n</pre> In\u00a0[20]: Copied! <pre># Show the first 3 bands (RGB)\nimshow(img_1.data_as_image()[:, :, 0:3])\n</pre> # Show the first 3 bands (RGB) imshow(img_1.data_as_image()[:, :, 0:3]) Out[20]: <pre>&lt;matplotlib.image.AxesImage at 0x139a29130&gt;</pre> In\u00a0[21]: Copied! <pre>imshow(img_2.data_as_image()[:, :, 0:3])\n</pre> imshow(img_2.data_as_image()[:, :, 0:3]) Out[21]: <pre>&lt;matplotlib.image.AxesImage at 0x139ba0d00&gt;</pre> In\u00a0[22]: Copied! <pre>with Reader(src_path) as src:\n    ndvi = src.tile(*tile_cover[0], expression=\"(b4-b1)/(b4+b1)\")\n    print(ndvi.data.shape)\n\nndvi.rescale(in_range=((-1, 1),))\nimshow(ndvi.data[0])\n</pre> with Reader(src_path) as src:     ndvi = src.tile(*tile_cover[0], expression=\"(b4-b1)/(b4+b1)\")     print(ndvi.data.shape)  ndvi.rescale(in_range=((-1, 1),)) imshow(ndvi.data[0]) <pre>(1, 256, 256)\n</pre> Out[22]: <pre>&lt;matplotlib.image.AxesImage at 0x139e1b280&gt;</pre> In\u00a0[23]: Copied! <pre>with Reader(src_path) as src:\n    # By default `part()` will read the highest resolution. We can limit this by using the `max_size` option.\n    img = src.part(\n        (-74.30680274963379, 40.60748547709819, -74.29478645324707, 40.61567903099978),\n        max_size=1024,\n    )\n    print(\"data shape: \", img.data.shape)\n    print(\"bounds: \", img.bounds)\n    print(\"CRS: \", img.crs)\n</pre> with Reader(src_path) as src:     # By default `part()` will read the highest resolution. We can limit this by using the `max_size` option.     img = src.part(         (-74.30680274963379, 40.60748547709819, -74.29478645324707, 40.61567903099978),         max_size=1024,     )     print(\"data shape: \", img.data.shape)     print(\"bounds: \", img.bounds)     print(\"CRS: \", img.crs) <pre>data shape:  (4, 699, 1024)\nbounds:  BoundingBox(left=-74.30680274963379, bottom=40.60748547709819, right=-74.29478645324707, top=40.61567903099978)\nCRS:  EPSG:4326\n</pre> In\u00a0[24]: Copied! <pre>img.rescale(((0, 40000),))\n\nimshow(img.data_as_image()[:, :, 0:3])\n</pre> img.rescale(((0, 40000),))  imshow(img.data_as_image()[:, :, 0:3]) Out[24]: <pre>&lt;matplotlib.image.AxesImage at 0x139e8bcd0&gt;</pre> In\u00a0[25]: Copied! <pre>with Reader(src_path) as src:\n    pt = src.point(-74.30680274963379, 40.60748547709819)\n\n    print(\"RGB-Nir values:\")\n    print([(b, pt.data[ii]) for ii, b in enumerate(pt.band_names)])\n\n    print(\"NDVI values:\")\n    ndvi = pt.apply_expression(\"(b4-b1)/(b4+b1)\")\n    print([(b, ndvi.data[ii]) for ii, b in enumerate(ndvi.band_names)])\n</pre> with Reader(src_path) as src:     pt = src.point(-74.30680274963379, 40.60748547709819)      print(\"RGB-Nir values:\")     print([(b, pt.data[ii]) for ii, b in enumerate(pt.band_names)])      print(\"NDVI values:\")     ndvi = pt.apply_expression(\"(b4-b1)/(b4+b1)\")     print([(b, ndvi.data[ii]) for ii, b in enumerate(ndvi.band_names)]) <pre>RGB-Nir values:\n[('b1', np.uint16(11002)), ('b2', np.uint16(15954)), ('b3', np.uint16(14478)), ('b4', np.uint16(32050))]\nNDVI values:\n[('(b4-b1)/(b4+b1)', np.float64(0.48889714763541764))]\n</pre> In\u00a0[26]: Copied! <pre>feat = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-74.30384159088135, 40.614245638811646],\n                [-74.30680274963379, 40.61121586776988],\n                [-74.30590152740477, 40.608967884350946],\n                [-74.30272579193115, 40.60748547709819],\n                [-74.29875612258911, 40.60786015456402],\n                [-74.2960524559021, 40.61012446497514],\n                [-74.29478645324707, 40.61390357476733],\n                [-74.29882049560547, 40.61515780103489],\n                [-74.30294036865233, 40.61567903099978],\n                [-74.3035626411438, 40.61502749290829],\n                [-74.30384159088135, 40.614245638811646],\n            ]\n        ],\n    },\n}\n</pre> feat = {     \"type\": \"Feature\",     \"properties\": {},     \"geometry\": {         \"type\": \"Polygon\",         \"coordinates\": [             [                 [-74.30384159088135, 40.614245638811646],                 [-74.30680274963379, 40.61121586776988],                 [-74.30590152740477, 40.608967884350946],                 [-74.30272579193115, 40.60748547709819],                 [-74.29875612258911, 40.60786015456402],                 [-74.2960524559021, 40.61012446497514],                 [-74.29478645324707, 40.61390357476733],                 [-74.29882049560547, 40.61515780103489],                 [-74.30294036865233, 40.61567903099978],                 [-74.3035626411438, 40.61502749290829],                 [-74.30384159088135, 40.614245638811646],             ]         ],     }, } In\u00a0[27]: Copied! <pre>with Reader(src_path) as src:\n    # we use the feature to define the bounds and the mask\n    # but we use `dst_crs` options to keep the projection from the input dataset\n    # By default `feature()` will read the highest resolution. We can limit this by using the `max_size` option.\n    img = src.feature(feat, dst_crs=src.crs, max_size=1024)\n    print(\"data shape: \", img.data.shape)\n    print(\"bounds: \", img.bounds)\n    print(\"CRS: \", img.crs)\n</pre> with Reader(src_path) as src:     # we use the feature to define the bounds and the mask     # but we use `dst_crs` options to keep the projection from the input dataset     # By default `feature()` will read the highest resolution. We can limit this by using the `max_size` option.     img = src.feature(feat, dst_crs=src.crs, max_size=1024)     print(\"data shape: \", img.data.shape)     print(\"bounds: \", img.bounds)     print(\"CRS: \", img.crs) <pre>data shape:  (4, 917, 1024)\nbounds:  BoundingBox(left=np.float64(545757.1269694079), bottom=np.float64(646262.094740576), right=np.float64(549099.8472835454), top=np.float64(649254.4633358669))\nCRS:  EPSG:6527\n</pre> In\u00a0[28]: Copied! <pre>img.rescale(((0, 40000),))\nimshow(img.data_as_image()[:, :, 0:3])\n</pre> img.rescale(((0, 40000),)) imshow(img.data_as_image()[:, :, 0:3]) Out[28]: <pre>&lt;matplotlib.image.AxesImage at 0x139f42520&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler/#introduction-to-rio-tiler","title":"Introduction to rio-tiler\u00b6","text":""},{"location":"examples/Using-rio-tiler/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=7.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler/#rio_tileriocogreader","title":"rio_tiler.io.COGReader\u00b6","text":"<p>In <code>rio-tiler</code> 2.0 we introduced COGReader (renamed Reader in 4.0), which is a python class providing usefull methods to read and inspect any GDAL/rasterio raster dataset.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/readers/#cogreader</p>"},{"location":"examples/Using-rio-tiler/#info","title":"Info\u00b6","text":"<p>Read GDAL/Rasterio dataset metadata</p>"},{"location":"examples/Using-rio-tiler/#statistics","title":"Statistics\u00b6","text":"<p>Return basic data statistics</p>"},{"location":"examples/Using-rio-tiler/#plot-histogram-values","title":"Plot Histogram values\u00b6","text":""},{"location":"examples/Using-rio-tiler/#preview","title":"Preview\u00b6","text":"<p>Read a low resolution version of the data (useful when working with COG, because this method will only fetch the overview layer it needs)</p>"},{"location":"examples/Using-rio-tiler/#the-imagedata-class","title":"The ImageData class\u00b6","text":"<p>To ease data manipulation, <code>rio-tiler</code> version 2.0 uses a new <code>ImageData</code> class that holds the arrays returned by rio-tiler/rasterio low level functions.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/models/#imagedata</p>"},{"location":"examples/Using-rio-tiler/#display-the-data","title":"Display the data\u00b6","text":""},{"location":"examples/Using-rio-tiler/#multi-spectral-data","title":"Multi Spectral Data\u00b6","text":"<p>For this demo we will use some High resolution RGB-Nir data hosted on AWS.</p>"},{"location":"examples/Using-rio-tiler/#using-expression","title":"Using Expression\u00b6","text":"<p><code>rio-tiler</code> reader methods accept <code>indexes</code> option to select the bands you want to read, but also <code>expression</code> to perform band math.</p>"},{"location":"examples/Using-rio-tiler/#tile","title":"Tile\u00b6","text":"<p>Read data for a specific slippy map tile coordinates</p>"},{"location":"examples/Using-rio-tiler/#part","title":"Part\u00b6","text":"<p>Read data for a given bounding box</p>"},{"location":"examples/Using-rio-tiler/#point","title":"Point\u00b6","text":"<p>Read the pixel value for a specific lon/lat coordinate</p>"},{"location":"examples/Using-rio-tiler/#featuregeojson","title":"Feature/GeoJSON\u00b6","text":"<p>Read value for a geojson feature defined area</p>"},{"location":"examples/Using-tms/","title":"Introduction to TileMatrixSets","text":"<p>The goal of this notebook is to give a quick introduction to the new TMS option in rio-tiler.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n</pre> # !pip install rio-tiler # !pip install ipyleaflet In\u00a0[8]: Copied! <pre>import morecantile\nfrom ipyleaflet import Map, TileLayer, projections\n</pre> import morecantile from ipyleaflet import Map, TileLayer, projections In\u00a0[9]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\"\n</pre> # For this DEMO we will use this file src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\" In\u00a0[13]: Copied! <pre>from concurrent import futures\n\nfrom tornado import gen, web\nfrom tornado.concurrent import run_on_executor\nfrom tornado.httpserver import HTTPServer\n\nfrom rio_tiler.errors import TileOutsideBounds\nfrom rio_tiler.io import Reader\nfrom rio_tiler.profiles import img_profiles\n\n\nclass TileServer:\n    def __init__(self, src_path):\n        \"\"\"Initialize Tornado app.\"\"\"\n        self.server = None\n        self.app = web.Application(\n            [\n                (r\"^/tiles/(\\w+)/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),\n            ]\n        )\n\n    def start(self):\n        \"\"\"Start tile server.\"\"\"\n        self.server = HTTPServer(self.app)\n        self.server.listen(8080)\n\n    def stop(self):\n        \"\"\"Stop tile server.\"\"\"\n        if self.server:\n            self.server.stop()\n\n\nclass TileHandler(web.RequestHandler):\n    \"\"\"Tile requests handler.\"\"\"\n\n    executor = futures.ThreadPoolExecutor(max_workers=16)\n\n    def initialize(self, url):\n        \"\"\"Initialize tiles handler.\"\"\"\n        self.url = url\n\n    @run_on_executor\n    def _get_tile(self, tms, z, x, y):\n        try:\n            with Reader(self.url, tms=morecantile.tms.get(tms)) as cog:\n                img = cog.tile(x, y, z, indexes=(1, 2, 3))\n        except TileOutsideBounds:\n            raise web.HTTPError(404)\n\n        prof = img_profiles.get(\"PNG\", {})\n        return img.render(img_format=\"PNG\", **prof)\n\n    @gen.coroutine\n    def get(self, tms, z, x, y):\n        \"\"\"Retunrs tile data and header.\"\"\"\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET\")\n        self.set_header(\"Content-Type\", \"image/png\")\n        self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")\n        res = yield self._get_tile(tms, int(z), int(x), int(y))\n        self.write(res)\n\n\nts = TileServer(src_path)\nts.start()\n</pre> from concurrent import futures  from tornado import gen, web from tornado.concurrent import run_on_executor from tornado.httpserver import HTTPServer  from rio_tiler.errors import TileOutsideBounds from rio_tiler.io import Reader from rio_tiler.profiles import img_profiles   class TileServer:     def __init__(self, src_path):         \"\"\"Initialize Tornado app.\"\"\"         self.server = None         self.app = web.Application(             [                 (r\"^/tiles/(\\w+)/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),             ]         )      def start(self):         \"\"\"Start tile server.\"\"\"         self.server = HTTPServer(self.app)         self.server.listen(8080)      def stop(self):         \"\"\"Stop tile server.\"\"\"         if self.server:             self.server.stop()   class TileHandler(web.RequestHandler):     \"\"\"Tile requests handler.\"\"\"      executor = futures.ThreadPoolExecutor(max_workers=16)      def initialize(self, url):         \"\"\"Initialize tiles handler.\"\"\"         self.url = url      @run_on_executor     def _get_tile(self, tms, z, x, y):         try:             with Reader(self.url, tms=morecantile.tms.get(tms)) as cog:                 img = cog.tile(x, y, z, indexes=(1, 2, 3))         except TileOutsideBounds:             raise web.HTTPError(404)          prof = img_profiles.get(\"PNG\", {})         return img.render(img_format=\"PNG\", **prof)      @gen.coroutine     def get(self, tms, z, x, y):         \"\"\"Retunrs tile data and header.\"\"\"         self.set_header(\"Access-Control-Allow-Origin\", \"*\")         self.set_header(\"Access-Control-Allow-Methods\", \"GET\")         self.set_header(\"Content-Type\", \"image/png\")         self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")         res = yield self._get_tile(tms, int(z), int(x), int(y))         self.write(res)   ts = TileServer(src_path) ts.start() <p>List the supported TMS from morecantile</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Supported TMS:\")\nfor name in morecantile.tms.list():\n    print(\"-\", name)\n</pre> print(\"Supported TMS:\") for name in morecantile.tms.list():     print(\"-\", name) In\u00a0[\u00a0]: Copied! <pre>with Reader(src_path) as cog:\n    info = cog.info()\n    minzoom = cog.minzoom\n    maxzoom = cog.maxzoom\n    bounds = cog.get_geographic_bounds(cog.tms.rasterio_geographic_crs)\n\nprint(info.model_dump(exclude_none=True))\nprint(bounds)\nprint(minzoom, maxzoom)\n\ncenter = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2)\nm = Map(center=center, zoom=minzoom, basemap={})\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/WebMercatorQuad/{z}/{x}/{y}\",\n    min_zoom=minzoom,\n    max_zoom=maxzoom,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> with Reader(src_path) as cog:     info = cog.info()     minzoom = cog.minzoom     maxzoom = cog.maxzoom     bounds = cog.get_geographic_bounds(cog.tms.rasterio_geographic_crs)  print(info.model_dump(exclude_none=True)) print(bounds) print(minzoom, maxzoom)  center = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2) m = Map(center=center, zoom=minzoom, basemap={})  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/WebMercatorQuad/{z}/{x}/{y}\",     min_zoom=minzoom,     max_zoom=maxzoom,     opacity=1, ) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>with Reader(src_path, tms=morecantile.tms.get(\"WorldCRS84Quad\")) as cog:\n    info = cog.info()\n    minzoom = cog.minzoom\n    maxzoom = cog.maxzoom\n    bounds = cog.get_geographic_bounds(cog.tms.rasterio_geographic_crs)\n\nprint(info.model_dump(exclude_none=True))\n\ncenter = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2)\nm = Map(center=center, zoom=minzoom, basemap={}, crs=projections.EPSG4326)\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/WorldCRS84Quad/{z}/{x}/{y}\",\n    min_zoom=minzoom,\n    max_zoom=maxzoom,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> with Reader(src_path, tms=morecantile.tms.get(\"WorldCRS84Quad\")) as cog:     info = cog.info()     minzoom = cog.minzoom     maxzoom = cog.maxzoom     bounds = cog.get_geographic_bounds(cog.tms.rasterio_geographic_crs)  print(info.model_dump(exclude_none=True))  center = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2) m = Map(center=center, zoom=minzoom, basemap={}, crs=projections.EPSG4326)  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/WorldCRS84Quad/{z}/{x}/{y}\",     min_zoom=minzoom,     max_zoom=maxzoom,     opacity=1, ) m.add_layer(layer) m In\u00a0[18]: Copied! <pre>ts.stop()\n</pre> ts.stop() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-tms/#introduction-to-tilematrixsets","title":"Introduction to TileMatrixSets\u00b6","text":""},{"location":"examples/Using-tms/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=7.0</li> <li>ipyleaflet</li> </ul>"},{"location":"examples/Using-tms/#data","title":"Data\u00b6","text":"<p>For this demo we will use some High resolution RGB-Nir data hosted on AWS.</p>"},{"location":"examples/Using-tms/#tile-server","title":"Tile Server\u00b6","text":"<p>For this demo, we need to create a minimal tile server.</p>"},{"location":"examples/Using-tms/#webmercator-tms","title":"WebMercator TMS\u00b6","text":""},{"location":"examples/Using-tms/#wgs84-tms","title":"WGS84 TMS\u00b6","text":""},{"location":"migrations/v2_migration/","title":"v1.0 -> v2.0","text":"<p><code>rio-tiler</code> version 2.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 2.0.</p>"},{"location":"migrations/v2_migration/#python-3-only","title":"Python 3 only","text":"<p>First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead. For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.6 or later is required.</p> <p>If you need help moving from Python 2 to 3 check out the official transition documentation.</p>"},{"location":"migrations/v2_migration/#type-hints","title":"Type hints","text":"<p>As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools.</p> <p>This does not require any changes to your code as long as you're using Python 3.6+.</p> <p>For more information see:</p> <ul> <li>fastapi.tiangolo.com/python-types/</li> <li>kishstats.com/python/2019/01/07/python-type-hinting.html</li> <li>mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</li> </ul> <p>Typing example:</p> <pre><code>def get_vrt_transform(\n    src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT],\n    bounds: Tuple[float, float, float, float],\n    dst_crs: CRS = constants.WEB_MERCATOR_CRS,\n) -&gt; Tuple[Affine, int, int]:\n</code></pre>"},{"location":"migrations/v2_migration/#rasterio-117","title":"Rasterio &gt;= 1.1.7","text":"<p>Rasterio 1.1.7 or newer is required.</p>"},{"location":"migrations/v2_migration/#mercantile-morecantile","title":"Mercantile -&gt; Morecantile","text":"<p>With Morecantile we can support more than the Web Mercator TMS.</p> <p>See tms</p>"},{"location":"migrations/v2_migration/#new-rio_tilerio-submodules","title":"New rio_tiler.io submodules","text":"<p>We created revised submodules for working with COGs and STAC:</p> <ul> <li><code>rio_tiler.io.cogeo</code> is a modified version of the previous <code>rio_tiler.main.tile</code>.</li> <li><code>rio_tiler.io.stac</code> is a new module to work with SpatioTemporal Asset Catalogs (STAC).</li> </ul> <p>We now support reading files through a <code>ContextManager</code> to enable accessing the source rasterio dataset.</p> <pre><code># v1\nfrom rio_tiler.main import tile as cogTiler\ntile, mask = cogTiler('my_tif.tif', 691559, 956905, 21, tilesize=256)\n\n# v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    img = cog.tile(691559, 956905, 21, tilesize=256)\n\n    print(cog.dataset) # rasterio dataset (returned by rasterio.open())\n    print(cog.dataset.meta) # rasterio metadata\n    print(cog.bounds)       # WGS84 bounds\n    print(cog.colormap)     # internal colormap\n</code></pre> <p>Expression support is now directly available in the <code>COGReader</code></p> <pre><code>with COGReader(\"my_tif.tif\") as cog:\n    tile, mask = cog.tile(691559, 956905, 21, expression=\"b1/b2\")\n</code></pre> <p>See <code>COGReader</code> amd <code>STACReader</code> for more info.</p>"},{"location":"migrations/v2_migration/#internal-api-rio_tilerreader","title":"Internal API: rio_tiler.reader","text":"<p>Internal tile/data reading functions have been refactored and moved to a new <code>rio_tiler.reader</code> submodule.</p>"},{"location":"migrations/v2_migration/#tile","title":"tile","text":"<p>In <code>rio_tiler</code> v1 most of the magic was happening in <code>rio_tiler.utils._tile_read</code>. In the version 2, this function is now split in two, <code>rio_tiler.reader.part</code> and <code>rio_tiler_reader.read</code>, to reduce code reutilisation and to make the code more robust. The <code>part</code> function now takes <code>height</code> and <code>width</code> instead of a unique <code>tilesize</code> to specify the output array size.</p> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    # get tile bounds and read raster\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256) # Will check if tile is valid\n\n    # Or\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n    t, m = rio_tiler.reader.part(src_dst, tile_bounds, 256, 256)\n</code></pre> <p>Options changes:</p> <ul> <li><code>tile_edge_padding</code> -&gt; <code>padding</code>, and set to 0 by default</li> <li><code>minimum_tile_cover</code> -&gt; <code>minimum_overlap</code></li> <li><code>warp_vrt_option</code> -&gt; <code>vrt_options</code></li> <li><code>unscale</code> (New): add ability to apply scale and offset to the data (Default: False)</li> <li><code>force_binary_mask</code> (New): force mask to either be 0 or 255, set to <code>True</code> by default.</li> <li><code>post_process</code> (New): add post process callback to apply operation on the data and mask arrays.</li> </ul> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256, tile_edge_padding=4, minimum_tile_cover=0.3)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256, padding=4, minimum_overlap=0.3)\n</code></pre>"},{"location":"migrations/v2_migration/#alpha-band","title":"Alpha band","text":"<p>Since the first version, <code>rio-tiler</code> returns a tuple of (data, mask) in most of the <code>reading</code> function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126, where a user gets a 4 bands data array + a mask (instead of 3 bands + mask).</p> <p>In version 2, when no <code>indexes</code> options are passed, we remove the alpha channel from the output data array.</p> <pre><code># v1\nwith rasterio.open(\"my_tif_alpha.tif\") as src_dst:\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256, indexes=(1,2,3))\n\n# v2\nwith rasterio.open(\"my_tif_alpha.tif\") as src_dst:\n    # because rio-tiler will remove the alpha band we don't need to use the indexes option\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256)\n</code></pre>"},{"location":"migrations/v2_migration/#metadata","title":"metadata","text":"<p><code>rio_tiler.utils._raster_get_stats</code> has been replaced by <code>rio_tiler.reader.metadata</code> which uses the new <code>reader.part</code> and <code>reader.preview</code> functions. Meaning that now you can get metadata for a specific area by passing a bbox.</p> <p>To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use the <code>max_size</code> options, meaning the <code>overview_level</code> options have been removed.</p> <pre><code># v1\nimport rio_tiler\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    meta = rio_tiler.utils._raster_get_stats(src_dst)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    meta = rio_tiler.reader.metadata(src_dst)\n</code></pre> <p>Options changes</p> <ul> <li>removed <code>histogram_bins</code> and <code>histogram_range</code> which should now be passed in <code>hist_options</code> (e.g: hist_options={bins=10, range=(0, 10)})</li> <li>removed <code>overview_level</code></li> <li>added <code>bounds</code></li> </ul> <p>Output</p> <p>The output has also been updated. The new <code>metadata</code> output doesn't return min/max zoom and bounds is return in WGS84 by default.</p> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    rio_tiler.utils._raster_get_stats(src_dst)\n\n&gt; {\n    \"bounds\": {\n        \"value\": [-119.05915661478785, 13.102845359730287, -84.91821332299578, 33.995073647795806],\n        \"crs\": \"EPSG:4326\"\n    },\n    \"minzoom\": 3,\n    \"maxzoom\": 12,\n    \"band_descriptions\": [\n        [1,  \"band1\"]\n    ],\n    \"statistics\": {\n        \"1\": {\n            \"pc\": [1, 17],\n            \"min\": 1,\n            \"max\": 18,\n            \"std\": 4.418616203143802,\n            \"histogram\": [\n                [...],\n                [...]\n            ]\n        }\n    }\n}\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    rio_tiler.reader.metadata(src_dst)\n\n&gt; {\n    \"bounds\": [-119.05915661478785, 13.102845359730287, -84.91821332299578, 33.995073647795806],\n    \"statistics\": {\n        \"1\": {\n            \"percentiles\": [1, 16],\n            \"min\": 1,\n            \"max\": 18,\n            \"std\": 4.069636227214257,\n            \"histogram\": [\n                [...],\n                [...]\n            ]\n        }\n    },\n    \"nodata_type\": \"Nodata\",\n    \"band_metadata\": [[\"1\", {}]],\n    \"band_descriptions\": [[\"1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255 ],\n        \"2\": [148, 56, 112, 255],\n        ...\n    }\n}\n</code></pre>"},{"location":"migrations/v2_migration/#colormaps","title":"colormaps","text":"<p>In addition to a new colormap specific submodule <code>rio_tiler.colormap</code>, and colormap holder <code>rio_tiler.colormap.cmap</code>, in version 2, colormaps are now RGBA values.</p> <p>We also removed <code>PIL</code> colormap compatibility.</p> <pre><code># v1\ncmap = rio_tiler.utils.get_colormap(\"viridis\", format=\"gdal\")\nprint(cmap[0])\n&gt; [68, 1, 84]\n\n# v2\nfrom rio_tiler.colormap import cmap\n\ncolormap = cmap.get(\"viridis\")\nprint(colormap[0])\n&gt; [68, 1, 84, 255]\n</code></pre>"},{"location":"migrations/v2_migration/#render","title":"render","text":"<p>In version 1, to create an image blob from an array we used the <code>rio_tiler.utils.array_to_image</code> function. We have renamed and slightly refactored the function but it works the same.</p> <pre><code># v1\nimg = rio_tiler.utils.array_to_image(tile, mask, img_format=\"PNG\")\n\n# v2\nimg = rio_tiler.utils.render(tile, mask, img_format=\"PNG\")\n</code></pre>"},{"location":"migrations/v2_migration/#pydantic-models","title":"Pydantic models","text":"<p>The <code>.io</code> readers now returns pydantic models hosting the results. This enables easy API definition.</p> <p>See models</p>"},{"location":"migrations/v2_migration/#mission-specific-changes","title":"Mission specific changes","text":"<p>Mission-specific tilers have been moved to the <code>rio-tiler-pds</code> package.</p>"},{"location":"migrations/v3_migration/","title":"v2.0 -> v3.0","text":"<p><code>rio-tiler</code> version 3.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 3.0.</p>"},{"location":"migrations/v3_migration/#morecantile-20-30","title":"Morecantile 2.0 -&gt; 3.0","text":"<p>Morecantile 3.0 switched from rasterio to pyproj for the coordinates transformation processes (github.com/developmentseed/morecantile/blob/master/CHANGES.md#300a0-2021-09-09). Morecantile and Pyproj require python &gt;= 3.7 which means rio-tiler had to remove python 3.6 supports.</p>"},{"location":"migrations/v3_migration/#bounds-and-crs-properties","title":"Bounds and CRS properties","text":"<p>Previously the <code>BaseReader.bounds</code> property was set to the <code>wgs84</code> representation of the dataset bounds but to accommodate to non-earth dataset we changed this and decided to store the native dataset <code>bounds</code>. We've also added <code>BaseReader.crs</code> to make sure user can work with the <code>bounds</code> property.</p> <p>We've added a <code>BaseReader.geographic_bounds</code>, which will return the <code>bounds</code> in WGS84.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    print(cog.bounds)       # bounds in WGS84\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    print(cog.bounds)       # dataset bounds\n    assert cog.bounds == cog.dataset.bounds  # bounds should be equal to the dataset bounds\n    print(cog.crs)\n    assert cog.crs == cog.dataset.crs\n\n    print(cog.geographic_bounds)  # bounds in WGS84 projection\n</code></pre> <p>Note a <code>geographic_crs</code> attribute is available in <code>COGReader</code> and <code>STACReader</code> to control which CRS to use for the transformation from the dataset's CRS.  <code>geographic_crs</code> is outside the <code>__init__</code> method for Abstract Base Classes (e.g <code>BaseReader</code>)</p> <pre><code>MARS2000_SPHERE = CRS.from_proj4(\"+proj=longlat +R=3396190 +no_defs\")\nMARS_MERCATOR = CRS.from_proj4(\n    \"+proj=merc +R=3396190 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +no_defs\"\n)\nMARS_TMS = TileMatrixSet.custom(\n    [\n        -179.9999999999996,\n        -85.05112877980656,\n        179.9999999999996,\n        85.05112877980656,\n    ],\n    MARS_MERCATOR,\n    extent_crs=MARS2000_SPHERE,\n    title=\"Web Mercator Mars\",\n    geographic_crs=MARS2000_SPHERE,\n)\nwith COGReader(\n    \"martian_dataset.tif\",\n    tms=MARS_TMS,\n    geographic_crs=rasterio.crs.CRS.from_proj4(\"+proj=longlat +R=3396190 +no_defs\"),\n) as cog:\n    ...\n</code></pre>"},{"location":"migrations/v3_migration/#no-more-max_size","title":"No more <code>max_size</code>","text":"<p>We've removed the default option <code>max_size=1024</code> in <code>BaseReader.part</code> and <code>BaseReader.feature</code> to return the highest resolution dataset by default.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.part(bbox)\n    assert data.width =&lt; 1024\n    assert data.height =&lt; 1024\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.part(bbox) # Can return data &gt; 1024x1024\n    data = cog.part(bbox, max_size=1024)  # will return the same result as in rio-tiler v2\n</code></pre>"},{"location":"migrations/v3_migration/#metadata-and-statistics","title":"Metadata and Statistics","text":"<p>The <code>BaseReader.metadata</code> method has been deprecated in rio-tiler v3. The method was previously returning a combination of the <code>info()</code> and <code>stats()</code> methods responses.</p> <p>The reader's <code>.stats()</code> methods were also deprecated in favor of the newly <code>.statistics()</code> method which will return more verbose statistics.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.stats(bbox)\n\n&gt;&gt;&gt; {'1': ImageStatistics(percentiles=[1.0, 6896.0], min=1.0, max=7872.0, std=2271.0065537857326, histogram=[[503460.0, 0.0, 0.0, 161792.0, 283094.0, 0.0, 0.0, 0.0, 87727.0, 9431.0], [1.0, 788.1, 1575.2, 2362.3, 3149.4, 3936.5, 4723.6, 5510.7, 6297.8, 7084.900000000001, 7872.0]], valid_percent=100.0)}\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.cog.statistics(bbox)\n\n&gt;&gt;&gt; {'1': BandStatistics(min=1.0, max=7872.0, mean=2107.524612053134, count=1045504.0, sum=2203425412.0, std=2271.0065537857326, median=2800.0, majority=1.0, minority=7072.0, unique=15.0, histogram=[[503460.0, 0.0, 0.0, 161792.0, 283094.0, 0.0, 0.0, 0.0, 87727.0, 9431.0], [1.0, 788.1, 1575.2, 2362.3, 3149.4, 3936.5, 4723.6, 5510.7, 6297.8, 7084.900000000001, 7872.0]], valid_percent=100.0, masked_pixels=0.0, valid_pixels=1045504.0, percentile_2=1.0, percentile_98=6896.0)}\n</code></pre>"},{"location":"migrations/v3_migration/#asset_expression-and-asset_indexes","title":"<code>asset_expression</code> and <code>asset_indexes</code>","text":"<p>In 3.0, we changed how <code>asset_expression</code> was defined in <code>rio_tiler.io.MultiBaseReader</code> (the base class of STAC like datasets). In 2.0, it was defined as a <code>string</code> (e.g <code>b1+100</code>) and would be applied to all <code>assets</code> and in 3.0 it's now a <code>dict</code> in form of <code>{\"asset 1\": \"expression for asset 1\", ...}</code>.</p> <pre><code># v2\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression=\"b1*2\",  # expression was applied to each asset\n    )\n\n# v3\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression={\"data1\": \"b1*2\", \"data2\": \"b2*100\"},  # we can now pass per asset expression\n    )\n</code></pre> <p>We also added <code>asset_indexes</code> to return specific indexes per asset.</p> <pre><code># v2\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        indexes=1,  # first band of each asset would be returned\n    )\n\n# v3\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_indexes={\"data1\": (1, 2), \"data2\": (3,)},  # we can now pass per asset Indexes\n    )\n</code></pre>"},{"location":"migrations/v3_migration/#type-hints","title":"Type hints","text":"<p>We have moved rio-tiler's custom type definitions from <code>rio_tiler.constants</code> to <code>rio_tiler.types</code> submodules.</p> <pre><code># v2\nfrom rio_tiler.constants import BBox, ColorTuple, Indexes, NoData, NumType\n\n# v3\nfrom rio_tiler.types import BBox, ColorTuple, Indexes, NoData, NumType\n</code></pre> <p>New types have also been added:</p> <ul> <li><code>DataMaskType = Tuple[numpy.ndarray, numpy.ndarray]</code>: Tuple holding the data and the mask arrays (mostly used in <code>rio_tiler.readers.*</code> functions)</li> <li><code>ColorTuple  = Tuple[int, int, int, int]</code>: RGBA ColorMap entry</li> <li><code>IntervalTuple = Tuple[NumType, NumType]</code>: Min/Max interval entry (for colormap or rescaling)</li> <li><code>GDALColorMapType = Dict[int, ColorTuple]</code>: GDAL compatible colormap</li> <li><code>IntervalColorMapType = Sequence[Tuple[IntervalTuple, ColorTuple]]</code>: Intervals colormap</li> <li><code>ColorMapType = Union[GDALColorMapType, IntervalColorMapType]</code>: Supported colormap types</li> </ul>"},{"location":"migrations/v3_migration/#deprecation","title":"Deprecation","text":"<ul> <li><code>rio_tiler.io.base.BaseReader.metadata()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.stats()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.spatial_info()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.center</code> property</li> <li><code>rio_tiler.models.Metadata</code> model</li> <li><code>rio_tiler.models.ImageStatistics</code> model</li> <li><code>rio_tiler.reader.stats</code> function</li> <li><code>rio_tiler.reader.metadata</code> function</li> <li><code>rio_tiler.utils._stats</code> function</li> </ul>"},{"location":"migrations/v4_migration/","title":"Breaking changes","text":"<p><code>rio-tiler</code> version 4.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 4.0.</p>"},{"location":"migrations/v4_migration/#python-38","title":"Python &gt;=3.8","text":"<p>As for rasterio, we removed python 3.7 support (rasterio/rasterio#2445)</p>"},{"location":"migrations/v4_migration/#cogreader-reader","title":"COGReader -&gt; Reader","text":"<p>Because the main reader will not only work with COG but most of GDAL supported raster, we choose to rename it to <code>Reader</code>.</p> <pre><code># before\nfrom rio_tiler.io import COGReader\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io import Reader\nfrom rio_tiler.io.rasterio import Reader\n</code></pre> <p>Note: We created <code>rio_tiler.io.COGReader</code> alias to <code>Reader</code> for compatibility.</p>"},{"location":"migrations/v4_migration/#rio_tileriocogeo-rio_tileriorasterio","title":"rio_tiler.io.cogeo -&gt; rio_tiler.io.rasterio","text":"<p>Reader's submodule now reflect the backend they use (rasterio, xarray, stac, ...)</p> <pre><code># before\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io.rasterio import Reader\n</code></pre>"},{"location":"migrations/v4_migration/#band-names","title":"Band names","text":"<p>Band names are now prefixed with <code>b</code> (e.g <code>b1</code>, <code>b2</code>)</p> <pre><code># before\nwith COGReader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n   print(list(stats))\n   &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [(\"1\", {}), (\"2\", {}), (\"3\", {})]\n\n    print(info.band_descriptions)\n    &gt;&gt;&gt; [(\"1\", \"\"), (\"2\", \"\"), (\"3\", \"\")]\n\n# now\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n    print(list(stats))\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [(\"b1\", {}), (\"b2\", {}), (\"b3\", {})]\n\n    print(info.band_descriptions)\n    &gt;&gt;&gt; [(\"b1\", \"\"), (\"b2\", \"\"), (\"b3\", \"\")]\n</code></pre>"},{"location":"migrations/v4_migration/#multibasereader-_get_asset_url","title":"MultiBaseReader <code>_get_asset_url</code>","text":"<p>We replaced <code>_get_asset_url</code> method in <code>MultibaseReader</code> by <code>_get_asset_info</code> which should return a dictionary in form of <code>{\"url\": ..., \"env\": ...}</code> (ref: cogeotiff/rio-tiler!552)</p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    print(stac._get_asset_url(\"green\"))\n    &gt;&gt;&gt; \"green.tif\"\n\n# new\nwith STACReader(\"stac.json\") as stac:\n    print(stac._get_asset_info(\"green\"))\n    &gt;&gt;&gt; {\"url\": \"green.tif\", \"env\": {}}\n</code></pre>"},{"location":"migrations/v4_migration/#multibasereader-expressions","title":"MultiBaseReader Expressions","text":"<p>We updated the <code>expression</code> format for <code>MultiBaseReader</code> (e.g STAC) to include band names and not only the asset name</p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green/red\")\n\n# now\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green_b1/red_b1\")\n</code></pre> <p>In addition we also removed <code>asset_expression</code> option in <code>MultiBaseReader</code>. This can be achieved directly using expression.</p> <pre><code># before\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\", \"B02\"],\n        asset_expression={\n            \"B01\": \"b1+500\",  # add 500 to the first band\n            \"B02\": \"b1-100\",  # substract 100 to the first band\n        }\n    )\n\n# now\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        expression=\"B01_b1+500;B02_b1-100\",\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#no-more-gcpcogreader","title":"No more GCPCOGReader","text":"<p><code>rio_tiler.io.Reader</code> will now recognize if the files has internal GCPS.</p> <pre><code># before\nfrom rio_tiler.io import GCPCOGReader\n\nwith GCPCOGReader(\"my_tif_with_gcps.tif\") as src:\n    pass\n\n# now\nfrom rio_tiler.io import Reader\n\nwith Reader(\"my_tif_with_gcps.tif\") as src:\n    pass\n</code></pre>"},{"location":"migrations/v4_migration/#pointdata-object","title":"PointData object","text":"<p>As for method returning <code>images</code>, methods returning point values (<code>Reader.point()</code>) now return a <code>PointData</code> object.</p> <pre><code># before\nwith COGReader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith Reader(\"cog.tif\") as src:\n    print(src.point(10.20, -42.0))\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#low-level-reader-methods-return-imagedata-and-pointdata-objects","title":"Low-level reader methods return ImageData and PointData objects","text":"<p><code>rio_tiler.reader.read</code> and <code>rio_tiler.readers.part</code> now return <code>ImageData</code> object instead of <code>Tuple[ndarray, ndarray]</code>.</p> <pre><code>from rio_tiler.reader import read, part, point\nfrom rio_tiler.models import ImageData, PointData\n\n# before\nwith rasterio.open(\"image.tif\") as src:\n    data, mask = read(src)\n    pts = point(10.20, -42.0)\n    print(pts)\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith rasterio.open(\"image.tif\") as src:\n    img = read(src)\n    assert isinstance(img, ImageData)\n\n    pts = point(src, (10.20, -42.0))\n    assert isinstance(pts, PointData)\n    print(pts)\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#reader-options","title":"Reader options","text":"<p>We removed <code>nodata</code>, <code>unscale</code>, <code>resampling_method</code>, <code>vrt_options</code> and <code>post_process</code> options to <code>rio_tiler.io.Reader</code> init method and replaced with a global <code>options</code>: <pre><code># before\nwith COGReader(\"cog.tif\", nodata=1, resampling_method=\"bilinear\") as cog:\n    data = cog.preview()\n\n# now\nwith Reader(COGEO, options={\"nodata\": 1, \"resampling_method\": \"bilinear\"}) as src:\n    data = src.preview()\n</code></pre></p>"},{"location":"migrations/v4_migration/#base-classes-minzoom-and-maxzoom","title":"Base classes minzoom and maxzoom","text":"<p>We moved min/max zoom attribute from the <code>SpatialMixin</code> to the base classes definition directly. This means that each class should now take care of the definition of those two variables.</p> <pre><code># before\n@attr.s\nclass BandFileReader(MultiBandReader):\n    \"\"\"Test MultiBand\"\"\"\n\n    input: str = attr.ib()\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    reader: Type[BaseReader] = attr.ib(init=False, default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    def __attrs_post_init__(self):\n        ...\n\n# now\n@attr.s\nclass BandFileReader(MultiBandReader):\n    \"\"\"Test MultiBand\"\"\"\n\n    input: str = attr.ib()\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    reader: Type[BaseReader] = attr.ib(init=False, default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    minzoom: int = attr.ib()\n    maxzoom: int = attr.ib()\n\n    @minzoom.default\n    def _minzoom(self):\n        return self.tms.minzoom\n\n    @maxzoom.default\n    def _maxzoom(self):\n        return self.tms.maxzoom\n\n    def __attrs_post_init__(self):\n        ...\n</code></pre>"},{"location":"migrations/v4_migration/#new-features","title":"New Features","text":""},{"location":"migrations/v4_migration/#non-geo-reader","title":"Non-Geo reader","text":"<p>Because not all raster are geo-referenced, we added <code>rio_tiler.io.ImageReader</code> to allow opening and reading non-geo images. All methods are returning data in the pixel coordinate system.</p> <pre><code>with ImageReader(\"image.jpg\") as src:\n    info = src.info()\n\n    stats = src.statistics()\n\n    # Part of the image (Origin is top-lef, coordinates should be in form of (left, bottom, right, top))\n    im = src.part((0, 100, 100, 0))\n\n    # 256x256 Tile (Origin of the TMS is top-lef)\n    im = src.tile(0, 0, src.maxzoom)\n\n    # read pixel x=10, y=5 (Origin is top-left)\n    pt = src.point(10, 5)\n</code></pre>"},{"location":"migrations/v4_migration/#xarray-reader","title":"Xarray reader","text":"<p>We added an optional xarray compatible reader in rio-tiler v4.0. The reader takes a xarray.DataArray as input which should have a CRS and geo-spatial variables (x,y or longitude,latitude).</p> <pre><code>import rioxarray\nimport xarray\nfrom rio_tiler.io import XarrayReader\n\nwith xarray.open_dataset(\n    \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",\n    engine=\"zarr\",\n    decode_coords=\"all\"\n) as src:\n    ds = src[\"analysed_sst\"][:1]\n    # the SST dataset do not have a CRS info\n    # so we need to add it to `virtualy` within the Xarray DataArray\n    ds.rio.write_crs(\"epsg:4326\", inplace=True)\n\n    with XarrayReader(ds) as dst:\n        print(dst.info())\n        img = dst.tile(1, 1, 2)\n</code></pre> <p>Note: Users might experience some really bad performance depending on the chunking of the original zarr.</p>"},{"location":"migrations/v4_migration/#dataset-statistics","title":"Dataset Statistics","text":"<p>Starting with rio-tiler 4.0, if the input dataset has <code>statistics</code> (e.g <code>STATISTICS_MINIMUM</code>, <code>STATISTICS_MAXIMUM</code>) within its metadata, rio-tiler will try to use it to rescale automatically the output image.</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\") as src:\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [('b1',\n    {'STATISTICS_COVARIANCES': '10685.98787505646',\n    'STATISTICS_EXCLUDEDVALUES': '-9999',\n    'STATISTICS_MAXIMUM': '2015.0944824219',\n    'STATISTICS_MEAN': '1754.471184271',\n    'STATISTICS_MINIMUM': '1615.8128662109',\n    'STATISTICS_SKIPFACTORX': '1',\n    'STATISTICS_SKIPFACTORY': '1',\n    'STATISTICS_STDDEV': '103.37305197708'})]\n\n    img = src.preview()\n    # The min/max statistics are saved within every output image object\n    print(img.dataset_statistics)\n    &gt;&gt;&gt; [(1615.8128662109, 2015.0944824219)]\n\n    buffer = img.render()\n    &gt;&gt;&gt; rio-tiler/rio_tiler/models.py:516: InvalidDatatypeWarning: Invalid type: `float32` for the `PNG` driver. Data will be rescaled using min/max type bounds  or dataset_statistics.\n</code></pre>"},{"location":"migrations/v5_migration/","title":"v4.0 -> v5.0","text":"<p><code>rio-tiler</code> version 5.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 5.0.</p>"},{"location":"migrations/v5_migration/#per_dataset-per_band-mask","title":"PER_DATASET -&gt; PER_BAND mask","text":"<p>When we started to work on rio-tiler we chose to use <code>PER_DATASET</code> mask, a 2D <code>(height, width)</code> array which represent the masked array for the whole dataset, as <code>Alpha</code> or <code>Mask</code> bands are designed for. The <code>PER_DATASET</code> model suffers precision when dealing with datasets that use <code>nodata</code> value because combining all <code>band nodata mask</code> will exclude good data (see github.com/cogeotiff/rio-tiler/issues/579#issuecomment-1455223893).</p> <p>To support the <code>PER_BAND</code> model, we updated the <code>ImageData</code> class to use <code>numpy.ma.MaskedArray</code> which will hold both the data and the mask with the same shape. The <code>image data</code> is now hosted in <code>.array</code> ImageData/PointData attribute.</p> <pre><code># before\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.data, numpy.ndarray)\n    assert img.data.shape == (3, 128, 128)\n\n    assert isinstance(img.mask, numpy.ndarray)\n    assert img.mask.shape == (128, 128)\n\n# now\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n    assert img.array.data.shape == (3, 128, 128)\n    assert img.array.mask.shape == (3, 128, 128)\n</code></pre> <p>For compatibility reason we kept <code>data</code> and <code>mask</code> as properties in the <code>ImageData</code> class. <code>ImageData().mask</code> will represent the <code>PER_DATASET</code> mask.</p> <pre><code>with COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n\n    assert img.data.shape == (3, 128, 128)\n    assert img.mask.shape == (128, 128)\n</code></pre>"},{"location":"migrations/v5_migration/#imagedatapointdata","title":"ImageData/PointData","text":"<p>As explained, the <code>ImageData</code> and <code>PointData</code> classes now use <code>MaskedArray</code> as input.</p> <pre><code># before\narr = numpy.zeros((1, 256, 256))\nmask = numpy.zeros((256, 256), dtype=\"uint8\")\nim = ImageData(arr, mask)\n\n# now\narr = numpy.ma.MaskedArray(numpy.zeros((1, 256, 256)))\narr.mask = False\nim = ImageData(arr)\n</code></pre>"},{"location":"migrations/v5_migration/#post_process-callback","title":"post_process callback","text":"<p>Introduced in <code>2.0</code>, <code>rio-tiler</code>'s low level reader (<code>rio_tiler.reader.read</code>) accept a <code>post_process</code> option which should be a Callable that take some data as input and returns modified data. Because of the changes in ImageData input type (now as MaskedArray), the <code>post_process</code> callback should be design to be of type <code>Callable[[numpy.ma.MaskedArray], numpy.ma.MaskedArray]</code>.</p> <pre><code># before\ndef callback(data: numpy.ndarray, mask: numpy.ndarray) -&gt; Tuple[numpy.ndarray, numpy.ndarray]:\n    mask.fill(255)\n    data = data * 2\n    return data, mask\n\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(post_process=callback)\n\n# now\ndef callback(data: numpy.ma.MaskedArray) -&gt; numpy.ma.MaskedArray:\n    data = data * 2\n    return data\n\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(post_process=callback)\n</code></pre>"},{"location":"migrations/v5_migration/#mosaicmethod","title":"MosaicMethod","text":"<p>The <code>.data</code> property of <code>rio-tiler</code>'s MosaicMethods should now return <code>numpy.ma.MaskedArray</code>. This change should be almost non-breaking because the MosaicMethod where designed using MaskedArrays.</p> <pre><code># before\ndef data(self) -&gt; Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]:\n    \"\"\"Return data and mask.\"\"\"\n    if self.tile is not None:\n        data = numpy.ma.getdata(self.tile)\n        mask = ~numpy.logical_or.reduce(numpy.ma.getmaskarray(self.tile))  # create PER_DATASET Mask\n        return (data, mask * numpy.uint8(255))\n\n    else:\n        return None, None\n\n# now\n@property\ndef data(self) -&gt; Optional[numpy.ma.MaskedArray]:\n    \"\"\"Return data.\"\"\"\n    return self.mosaic  # `tile` has been renamed `array`\n</code></pre>"},{"location":"migrations/v5_migration/#reprojection-and-resizing-resampling-methods","title":"Reprojection and Resizing resampling methods","text":"<p>With <code>rio-tiler &gt;=5.0</code>, you can now select with resampling method to use for the <code>reprojection</code> and <code>resizing</code> processes independently by using the <code>reproject_method</code> and <code>resampling_method</code> options in <code>rio_tiler.reader</code>'s function.</p> <p>The <code>resampling_method</code> option will control the <code>IO</code> resampling (e.g resizing) while the <code>reproject_method</code> will be using in the <code>WarpedVRT</code> for the reprojection.</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"bilinear\",  # use `bilinear` for both resizing and reprojection\n    )\n\n# now\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"cubic\",  # use `cubic` for resizing\n        reproject_method=\"bilinear\",  # use `bilinear` for reprojection\n    )\n</code></pre> <p>Important</p> <p>In the <code>XarrayReader</code> we are still using only one <code>resampling_method</code> option because we are using <code>rioxarray</code> for read and reprojection processes and it does not have both options available.</p>"},{"location":"migrations/v5_migration/#boto3-optional-dependency","title":"Boto3 Optional dependency","text":"<p>When needing to access STAC items using <code>s3://</code> urls, you'll need to have <code>boto3</code> installed in your python environment.</p> <pre><code>python -m pip install rio-tiler[\"s3\"]  # or python -m pip install rio-tiler rasterio[\"s3\"]\n</code></pre> <p>Note: if you want to access <code>s3://</code> raster dataset you'll also need <code>boto3</code> in your environment (<code>rasterio</code>'s dependency).</p>"},{"location":"migrations/v5_migration/#changes-in-methodfunctionvariable-names","title":"changes in method/function/variable names","text":"<p>Some function or method names have changed in <code>rio-tiler</code> V5</p> <ul> <li> <p><code>rio_tiler.mosaic.methods.LastBandHigh</code> -&gt; <code>rio_tiler.mosaic.methods.LastBandHighMethod</code></p> </li> <li> <p><code>rio_tiler.mosaic.methods.LastBandLow</code> -&gt; <code>rio_tiler.mosaic.methods.LastBandLowMethod</code></p> </li> <li> <p>in the <code>MosaicMethodBase</code> the variable <code>tile</code> has been renamed <code>mosaic</code></p> </li> <li> <p><code>rio_tiler.utils.aws_get_object</code> -&gt; <code>rio_tiler.io.stac.aws_get_object</code></p> </li> <li> <p>In <code>ImageData</code>/<code>PointData</code> objects the pixel values are stored in a variable named <code>array</code> (it was <code>data</code> previously). A <code>.data</code> property has been added for compatibility.</p> </li> <li> <p>In <code>ImageData</code>/<code>PointData</code> the <code>.mask</code> attribute has been replaced by a <code>.mask</code> property</p> </li> </ul>"},{"location":"migrations/v7_migration/","title":"v6.0 -> v7.0","text":"<p><code>rio-tiler</code> version 7.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 7.0.</p> <p>Changelog: github.com/cogeotiff/rio-tiler/compare/6.7.0..7.0.0</p>"},{"location":"migrations/v7_migration/#info-model","title":"Info Model","text":""},{"location":"migrations/v7_migration/#bounds","title":"Bounds","text":"<p>The <code>bounds</code> property was replaced from the <code>geographic bounds</code> to the dataset <code>bounds</code>, and the associated CRS was also added as a new property.</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    info = src.info()\n    assert src.geographic_bounds == info.bounds\n\n# now\nwith Reader(\"cog.tif\") as src:\n    info = src.info()\n    assert src.bounds == info.bounds\n    assert info.crs\n</code></pre>"},{"location":"migrations/v7_migration/#minmax-zooms","title":"Min/Max zooms","text":"<p>We removed the <code>minzoom</code> and <code>maxzoom</code> properties from the <code>rio_tiler.models.Info</code> (and removed the <code>SpatialInfo</code> model). We chose to removed any <code>external</code> geographic metadata to ease the use of the <code>info()</code> method.</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    info = src.info()\n    assert info.minzoom\n    assert info.maxzoom\n\n# now\n# The min/max zooms are still Reader's properties\nwith Reader(\"cog.tif\") as src:\n    assert src.minzoom\n    assert src.maxzoom\n</code></pre>"},{"location":"migrations/v7_migration/#geographic-crs-and-bounds","title":"Geographic CRS and Bounds","text":"<p>we removed the <code>geographic_crs</code> attribute in the BaseReader class and replaced the <code>geographic_bounds</code> property with a <code>get_geographic_bounds(crs: rasterio.crs.CRS)</code> method.</p> <pre><code>from rasterio.crs import CRS\nfrom rio_tiler.io import Reader\n\n# before\nwith Reader(\"cog.tif\", geographic_crs=CRS.from_epsg(4326)) as src:\n    bounds = src.geographic_bounds\n\n# now\nwith Reader(\"cog.tif\") as src:\n    bounds = src.get_geographic_bounds(CRS.from_epsg(4326))\n</code></pre>"},{"location":"migrations/v7_migration/#colormaps","title":"ColorMaps","text":"<p>In previous version, the <code>ColorMaps.get(name: str)</code> method did not care about the Case of the name. This has been disabled and now the name should reflect the <code>basename</code> of the colormap file (<code>.npy</code>) or the name used while registering the colormap to the ColorMaps object.</p> <pre><code>from rio_tiler.colormap import cmap\n\n# before\nassert cmap.get(\"Viridis\")\n\n# now\nassert cmap.get(\"Viridis\")\n&gt;&gt; InvalidColorMapName: Invalid colormap name: Viridis\n</code></pre>"},{"location":"migrations/v7_migration/#new-features","title":"New Features","text":"<ul> <li> <p>add support for <code>.json</code> colormap files (in addition to <code>.npy</code> files)</p> </li> <li> <p>Enable dynamic definition of Asset reader in <code>MultiBaseReader</code></p> <pre><code>@attr.s\nclass STACReader(OfficialSTACReader):\n\n    include_asset_types: Set[str] = attr.ib(default=valid_types)\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Type[BaseReader]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"type\", None)\n\n        if asset_type and asset_type in [\n            \"application/x-hdf5\",\n            \"application/x-hdf\",\n            \"application/vnd.zarr\",\n            \"application/x-netcdf\",\n\n        ]:\n            return XarrayReader\n\n        return Reader\n</code></pre> </li> <li> <p>add <code>default_assets</code> for MultiBaseReader</p> </li> <li> <p>add <code>default_bands</code> for MultiBandReader</p> </li> <li> <p>add <code>transform</code>, <code>height</code> and <code>width</code> attributes in <code>SpatialMixin</code> class</p> </li> <li> <p>add support for STAC's Projection extension to derive bounds, crs, minzoom and maxzoom properties</p> </li> <li> <p>enable Alternate asset's HREF for STAC by using <code>RIO_TILER_STAC_ALTERNATE_KEY</code> environment variable</p> </li> <li> <p>add support for GDAL VRT Connection string for STAC Assets</p> <pre><code>with STACReader(\"file.grib\") as stac:\n    info = stac.info(assets=\"vrt://asset?bands=1\")\n</code></pre> </li> <li> <p>make <code>ImageData.rescale</code> and <code>ImageData.apply_color_formula</code> to return <code>self</code></p> </li> </ul>"}]}